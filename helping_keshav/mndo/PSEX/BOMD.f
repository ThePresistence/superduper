      SUBROUTINE BO_DYNAM(ARRAY,LM5,ICALL,SCFCAL)

C==========================================================================C
C Generated by Zhenggang Lan.                                              C
C This subroutine is used to perform ground-state Born-Oppenheimer (BO)    C
C Molecular Dynamics (MD) using the velocity verlet algorithm.             C
C It is a simplified version of the excited-state surface hopping code     C
C written by Eduardo Fabiano.                                              C
C It is divided into two main parts:                                       C
C  (1) Initialization                                                      C
C       all variables are set up, output files are initialized and         C
C       starting velocities are assigned                                   C
C  (2) MD loop                                                             C
C       the velocity verlet time propagation is performed                  C
C                                                                          C
C Units:                                                                   C
C   energy        kcal/mol                                                 C
C   time          ps                                                       C
C   distance      A                                                        C
C   velocity      A/ps                                                     C
C   temperature   K                                                        C
C   lin. moment.  AMU*A/ps                                                 C
C   ang. moment.  AMU*A^2/ps                                               C
C--------------------------------------------------------------------------C
C  VARIABLES  (in alphabetical order)                                      C
C                                                                          C
C AMS           Atomic masses                                              C
C ARRAY         Scratch array (for use in SCFCAL)                          C
C avstat        Flag to turn on statistics averaging                       C
C                If fstat = n > 1 the average value over n steps will be   C
C                saved                                                     C
C CG            Cartesian gradients of the ground state (from /CGRAD/)     C
C COORD         Coordinates                                                C
C delta         Scratch variable for velocity update                       C
C dt            Time step [in picoseconds]                                 C
C E_av          Average total energy                                       C
C E_old         Total energy from previous MD step                         C
C E_tot         Total energy                                               C
C ELMNT         Chemical symbols for elements                              C
C ENERGX        Energy of computed state                                   C
C ene_tol       Threshold for relative variation of total energy           C
C fsav          frequency for saving in trajectory and velocity file       C
C                 = 1  every step                                          C
C                 = n  every n steps                                       C
C fstat         frequency for saving in statistics file                    C
C                 = 1  every step                                          C
C                 = n  every n steps                                       C
C fvs           frequency for performing velocity scaling                  C
C                 = 1  every step                                          C
C                 = n  every n steps                                       C
C i             Counter                                                    C
C ic2           scratch variable for initialization of nran2 and nran3     C
C ICALL         control variable for SCF calculations and error flag       C
C init_stat     Initial state                                              C
C io_disk       Error flag for I/O                                         C
C iout          Level of output (=0 none; =1 minimal; =2 big; =3 debug)    C
C ist           Counter for MD loop                                        C
C istat         Current state to propagate                                 C
C IN2           MNDO options                                               C
C K             Kinetic energy                                             C
C K_av          Average kinetic energy                                     C
C L2_av         Average square angular momentum                            C
C Lx_av,Ly_av,Lz_av  Average cartesian components of angular momentum      C
C LM1           Maximum number of atoms (see LIMIT.f90)                    C
C LM1M          Maximum number of external points (see LIMIT.f90)          C
C LM5           Buffer length (for use in SCFCAL)                          C
C LMGRD         Maximum number of GUGA-CI gradient vectors (see LIMIT.f90) C
C LMV           Muximum number of geometrical variables (see LIMIT.f90)    C
C mdstep        current MD step                                            C
C NAT           Atomic numbers                                             C
C nf            Number of degrees of freedom                               C
C norot         Flag to select initial velocities such as angular momentum C
C                is zero                                                   C
C notra         Flag to select initial velocities such as linear momentum  C
C                is zero                                                   C
C nstep         Max number of MD steps                                     C
C NUMAT         Number of atoms                                            C
C P2_av         Average square linear momentum                             C
C Px_av,Py_av,Pz_av  Average cartesian componets of linear momentum        C
C rdummy        scratch variable for initialization of nran2 and nran3     C
C restart       Flag to allow restarting form file                         C
C rfile         Restart file name                                          C
C rnd_gen       Algorithm for the generation of random numbers             C
C                 standard  -> standard FORTRAN algorithm [RANDOM_NUMBER]  C
C                 PM_BD     -> Park and Miller algorithm with Bays-Durham  C
C                              shuffle                                     C
C                 knuth     -> Knuth subtractive algorithm                 C
C rnd_seed      Allocatable array for random seed                          C
C sca           conversion factor from kcal/(mol*A*AMU) to A/ps^2          C
C SCFCAL        External routine for SCF calculations                      C
C sfile         Statistics file name                                       C
C sunit         Fortran unit for statistics file                           C
C T_av          Average temperature                                        C
C Tfix          Temperature to be reached with velocity scaling            C
C T_ist         Instantaneous temperature                                  C
C temp0         Initial temperature                                        C
C v_av          Average potential energy                                   C
C vfile         Velocity file name                                         C
C vunit         Fortran unit for velocity file                             C
C vs            Flag to enable velocity scaling                            C
C vs_Emax       Maximum kinetic energy correction allowed in velocity      C
C               scaling procedure. Negative number means unlimited.        C
C vx,vy,vz      Cartesian components of velocity                           C
C xfile         Trajectory file name                                       C
C xunit         Fortran unit for trajectory file                           C
C write_rest    Flag to allow writing the restart file                     C
C write_stats   Flag to allow writing of statistics                        C
C write_traj    Flag to allow writing trajectory file                      C
C write_vel     Flag to allow writing of velocities                        C
C                                                                          C
C--------------------------------------------------------------------------C
C  CALLINGS                                                                C
C                                                                          C
C  bo_nmlst                  Management of name list variables             C
C  bo_read_rest              Read restart file                             C
C  bo_v_rnd                  Create random velocities                      C
C  bo_v_remove_tra           Remove global translations from velocity set  C
C  bo_v_remove_rot           Remove global rotations from velocity set     C
C  bo_term_scal              Perform thermal scaling                       C
C  bo_Kene                   Compute kinetic energy                        C
C  bo_Tist                   Compute instantaneous temperature             C
C  bo_outpr                  Print initial statistics            .         C
C  RANDOM_SEED               Initialize FORTRAN random number generator    C
C                            using nran2 or nran3                          C
C  nran2                     Random number generator                       C
C  nran3                     Random number generator                       C
C  bo_vel_scal               Perform velocity scaling                      C
C  bo_outpr2                 Prepare and print statistics                  C
C  bo_write_res              Write restart file                            C
C                                                                          C
C--------------------------------------------------------------------------C
C==========================================================================C

      USE LIMIT, ONLY: LM1, LMGRD, LM1M, LMV

      IMPLICIT NONE

C     INPUT VARIABLES
      INTEGER :: LM5
      REAL*8, DIMENSION(LM5) :: ARRAY
      INTEGER :: ICALL

C     COMMON
      REAL*8 :: AMS
      REAL*8 :: COORD
      INTEGER :: NUMAT
      INTEGER :: IN2
      INTEGER :: NAT
      CHARACTER(2) :: ELEMNT
      REAL*8 :: ENERGY
      REAL*8 :: GNORM 
      REAL*8 :: CNORM 
      REAL*8 :: CG
      REAL*8 :: G

      COMMON
     ./AMASS / AMS(LM1)
     ./ATOMC / COORD(3,LM1)
     ./ATOMS / NUMAT,NAT(LMV)
     ./CGRAD / CG(3,LM1+LM1M)
     ./ERG   / ENERGY,G(LMV),GNORM,CNORM
     ./INOPT2/ IN2(300)
     ./ELEMTS/ ELEMNT(107)

C     LOCAL VARIABLES
C     REAL*8, DIMENSION(NUMAT) :: x,y,z
      INTEGER :: i
      INTEGER :: io_disk
      REAL*8, DIMENSION(NUMAT) :: vx,vy,vz
      INTEGER :: nf
C     REAL*8 :: Px,Py,Pz
C     REAL*8 :: Lx,Ly,Lz
      REAL*8 :: K
      REAL*8 :: T_ist
      REAL*8 :: ENERGX
      REAL*8 :: E_tot
      REAL*8 :: E_old
      INTEGER :: mdstep
      INTEGER :: istat
      REAL*8 :: delta
      INTEGER :: ist
      REAL*8 :: E_av
      REAL*8 :: K_av
      REAL*8 :: V_av
      REAL*8 :: T_av
      REAL*8 :: P2_av
      REAL*8 :: Px_av
      REAL*8 :: Py_av
      REAL*8 :: Pz_av
      REAL*8 :: L2_av
      REAL*8 :: Lx_av
      REAL*8 :: Ly_av
      REAL*8 :: Lz_av
      INTEGER, DIMENSION(IN2(159)) :: sw_CC
      INTEGER, DIMENSION(IN2(159)) :: inde
      INTEGER :: istatt
      INTEGER, ALLOCATABLE :: rnd_seed_array(:)
      INTEGER :: rsa_size
      INTEGER :: ic2
      REAL*8 :: rdummy

C     NAMELIST VARIABLES
      INTEGER :: iout
      INTEGER :: nstep
      REAL*8 :: dt
      REAL*8 :: temp0
      LOGICAL :: norot
      LOGICAL :: notra
      INTEGER :: init_stat
      LOGICAL :: write_traj
      INTEGER :: xunit
      CHARACTER(20) :: xfile
      LOGICAL :: write_vel
      INTEGER :: vunit
      CHARACTER(20) :: vfile
      REAL*8 :: ene_tol
      INTEGER :: fsav
      LOGICAL :: write_stats
      INTEGER :: sunit
      CHARACTER(20) :: sfile
      INTEGER :: fstat
      LOGICAL :: restart
      LOGICAL :: write_rest
      CHARACTER(20) :: rfile
      LOGICAL :: avstat
      LOGICAL :: vs
      REAL*8 :: Tfix
      INTEGER :: fvs
      REAL*8 :: vs_Emax
      CHARACTER(8) :: rnd_gen
      INTEGER :: rnd_seed
      INTEGER :: rnd_count
      REAL*8 :: g0

C     EXTERNAL ROUTINES
      EXTERNAL SCFCAL

C     PARAMETERS
      REAL*8, PARAMETER :: sca = 418.4 ! from kcal/(mol*A*AMU) to A/ps^2

C *** Initialization
      mdstep = 0
      E_tot = 0.D0
      E_old = 0.D0
      T_ist = 0.D0
      vx = 0.d0
      vy = 0.d0
      vz = 0.d0
      E_av = 0.D0
      K_av = 0.D0
      V_av = 0.D0
      T_av = 0.D0
      P2_av = 0.D0
      Px_av = 0.D0
      Py_av = 0.D0
      Pz_av = 0.D0
      L2_av = 0.D0
      Lx_av = 0.D0
      Ly_av = 0.D0
      Lz_av = 0.D0
      rnd_count = 0

C *** Namelist initialization
      CALL bo_nmlst(iout,nstep,dt,temp0,norot,notra,init_stat,
     &           write_stats,sunit,sfile,write_traj,xunit,
     &           xfile,write_vel,vunit,vfile,ene_tol,fstat,
     &           avstat,fsav,restart,write_rest,rfile,vs,
     &           Tfix,fvs,vs_Emax,
     &           rnd_gen,rnd_seed,g0)

C *** Read restart file if requested
      IF (restart) THEN
         CALL bo_read_rest(iout,rfile,NUMAT,COORD(1,:),COORD(2,:),
     &                  COORD(3,:),vx,vy,vz)
C        Assign number of degrees of freedom (nf).
         IF (NUMAT .EQ. 1) THEN
            nf = 3
         ELSE
            IF (norot .AND. notra) THEN
               IF (NUMAT .EQ. 2) THEN
                  nf = 3*NUMAT -5
               ELSE
                  nf = 3*NUMAT - 6
               END IF
            ELSE IF (notra .AND. .NOT.norot) THEN
               nf = 3*NUMAT - 3
            ELSE IF (norot .AND. .NOT. notra) THEN
               IF (NUMAT .EQ. 2) THEN
                  nf = 3*NUMAT - 2
               ELSE
                  nf = 3*NUMAT - 3
               END IF
            ELSE IF (.NOT.norot .AND. .NOT.notra) THEN
               nf = 3*NUMAT
            END IF
         END IF
      END IF
C     print *, "Initialization finished"

C *** Initialize random number generator.

CTWK  Initialise with the user-specified seed if provided,
CTWK  otherwise use a random seed as before.
CTWK  This section moved before velocity assignment so we can use the same 
CTWK  seeding throughout to ensure reproducibility for testing purposes.

      IF (rnd_gen .EQ. "standard") THEN
         CALL RANDOM_SEED(SIZE=rsa_size)
         ALLOCATE(rnd_seed_array(rsa_size))
         IF (rnd_seed .EQ. -1) THEN
            CALL RANDOM_SEED
            CALL RANDOM_SEED(GET=rnd_seed_array(1:rsa_size))
         ELSE
            rnd_seed_array = rnd_seed
            CALL RANDOM_SEED(PUT=rnd_seed_array(1:rsa_size))
         ENDIF
         IF (iout .GE. 1) THEN
            WRITE(*,*)
            WRITE(*,*) 'Random number seeds: ', rnd_seed_array
            WRITE(*,*)
         ENDIF
         DEALLOCATE(rnd_seed_array)
      ELSE IF (rnd_gen .EQ. "PM_BD" .OR. rnd_gen .EQ. "knuth") THEN
         IF (rnd_seed .EQ. -1) THEN
         ELSE
            ic2 = rnd_seed
         ENDIF
         IF (iout .GE. 1) THEN
            WRITE(*,*)
            WRITE(*,*) 'Random number seed: ', ic2
            WRITE(*,*)
         ENDIF
         IF (rnd_gen .EQ. "PM_BD") THEN
            CALL nran2(rdummy,ic2,.TRUE.)
         ELSE
            CALL nran3(rdummy,ic2,.TRUE.)
         ENDIF
      ELSE
         WRITE(*,*)
         WRITE(*,'("Unknown random numbers generator ",A8)')rnd_gen
         WRITE(*,*)
         STOP 'Abnormal termination in sub. BO_DYNAM'
      END IF

C *** Assignment of starting velocity.

C     If temp0 < 0 stop
      IF (.NOT. restart) THEN
         IF (temp0 .LT. 0.D0) THEN
            WRITE(*,*)
            WRITE(*,*)"ERROR!!"
            WRITE(*,*)"Initial temperature set to a negative value"
            WRITE(*,*)
            STOP 'Abnormal termination in sub. BO_DYNAM'
         END IF
      END IF

C     When starting from restart file, nothing needs to be done here.
CTWK  Test on temp0=0.d0 removed, so nf is set correctly and
CTWK  floating point strangeness is prevented in the test.

      IF (.NOT. RESTART) THEN
         IF (NUMAT .EQ. 1) THEN
            WRITE(*,*)
            WRITE(*,*)"Single atom velocity assignment"
            WRITE(*,*)
            CALL bo_v_rnd(iout,NUMAT,AMS,rnd_gen,rnd_count,vx,vy,vz)
            nf = 3
         ELSE
            IF (norot .AND. notra) THEN
               CALL bo_v_rnd(iout,NUMAT,AMS,rnd_gen,rnd_count,vx,vy,vz)
               CALL bo_v_remove_tra(iout,NUMAT,AMS,vx,vy,vz)
               CALL bo_v_remove_rot(iout,NUMAT,AMS,COORD(1,:),
     &                           COORD(2,:),COORD(3,:),vx,vy,vz)
               IF (NUMAT .EQ. 2) THEN
                  nf = 3*NUMAT - 5
               ELSE
                  nf = 3*NUMAT - 6
               END IF
            ELSE IF (notra .AND. .NOT.norot) THEN
               CALL bo_v_rnd(iout,NUMAT,AMS,rnd_gen,rnd_count,vx,vy,vz)
               CALL bo_v_remove_tra(iout,NUMAT,AMS,vx,vy,vz)
               nf = 3*NUMAT - 3
            ELSE IF (norot .AND. .NOT. notra) THEN
               CALL bo_v_rnd(iout,NUMAT,AMS,rnd_gen,rnd_count,vx,vy,vz)
               CALL bo_v_remove_rot(iout,NUMAT,AMS,COORD(1,:),
     &                           COORD(2,:),COORD(3,:),vx,vy,vz)
               IF (NUMAT .EQ. 2) THEN
                  nf = 3*NUMAT - 2
               ELSE
                  nf = 3*NUMAT - 3
               END IF
            ELSE IF (.NOT.norot .AND. .NOT.notra) THEN
               CALL bo_v_rnd(iout,NUMAT,AMS,rnd_gen,rnd_count,vx,vy,vz)
               nf = 3*NUMAT
            END IF
         END IF
      
C *** Perform initial thermal scaling.

         CALL bo_term_scal(iout,NUMAT,AMS,vx,vy,vz,temp0,nf)

      END IF

C     Printing section.
      IF (iout .GE. 2) THEN
         WRITE(*,*)
         WRITE(*,'("+",(47("-")),"+")')
         WRITE(*,'("|",9X,"Initial velocities assignment",9X,"|")')
         WRITE(*,'("+",(47("-")),"+")')
         IF (.NOT. restart) THEN
            WRITE(*,'("| Initial temperature: ",F10.4," K",13X,"|")')
     &                temp0
            WRITE(*,'("| Degrees of fredom: ",I3,24X,"|")')nf
         ELSE
           WRITE(*,'("| Data from restart file ",A)')rfile
         END IF 
         WRITE(*,'("+",(47("-")),"+")')
         WRITE(*,'("|",15X,"Velocities [A/ps]",15X,"|")')
         WRITE(*,'("| Atom",8X,"vx",12X,"vy",12X,"vz",4X,"|")')
         DO i = 1, NUMAT
            WRITE(*,'("|",1X,I3,2X,F12.5,2X,F12.5,2X,F12.5," |")')i,
     &                 vx(i),vy(i),vz(i)
         END DO
         WRITE(*,'("+",(47("-")),"+")')
      END IF

C *** Initial computation of energy and gradient.

      CALL SCF(ARRAY,LM5,ICALL,SCFCAL)
      ENERGX = ENERGY
         
C     Check for convergency problems
      IF (ICALL .EQ. -1) THEN
         WRITE(*,*)
         WRITE(*,*)"CONVERGENCY PROBLEMS!!!"
         WRITE(*,*)"The MD simulation will end here."
         WRITE(*,*)
         STOP 'Abnormal termination in sub. BO_DYNAM'
      END IF
      
C *** Computation of total energy.

      CALL bo_Kene(iout,NUMAT,AMS,vx,vy,vz,K)
      CALL bo_Tist(iout,K,nf,T_ist)
      E_tot = ENERGX + K
      E_old = E_tot
c     print *, "E_tot", E_tot
c     print *, "K", K
c     print *, "V", ENERGX

C *** Printing section.
      IF (iout .GE. 1) CALL bo_outpr(mdstep,NUMAT,nf,AMS,vx,vy,vz,
     &                            E_tot,K,ENERGX)

C *** Initialization of output files.

C     Open file for output of statistics if requested.
      IF (write_stats) THEN
         OPEN(UNIT=sunit,NAME=sfile,STATUS="NEW",ACTION="WRITE",
     &        IOSTAT=io_disk)
         IF (io_disk .NE. 0) THEN
            WRITE(*,*)
            WRITE(*,'("File ",A," already exist.")')sfile
            WRITE(*,'("Please change the name of output file")')
            WRITE(*,*)
            STOP 'Abnormal termination in sub. BO_DYNAM'
         END IF
         WRITE(sunit,'(" #mdstep",3X,"total energy",2X,"kinetic energy",
     &             2X,"potent. energy",2X,"temperature",6X,"p**2",12X,
     &             "Px",13X,"Py",13X,"Pz",12X,"L**2",12X,"Lx",13X,
     &             "Ly",13X,"Lz")')
      END IF

C     Open file for output of trajectory if requested.
      IF (write_traj) THEN
         OPEN(UNIT=xunit,NAME=xfile,STATUS="NEW",ACTION="WRITE",
     &        IOSTAT=io_disk)
         IF (io_disk .NE. 0) THEN
            WRITE(*,*)
            WRITE(*,'("File ",A," already exist.")')xfile
            WRITE(*,'("Please change the name of output file")')
            WRITE(*,*)
            STOP 'Abnormal termination in sub. DYNAM'
         END IF
         WRITE(xunit,'(a)')"[Molden Format]"
         WRITE(xunit,'(a)')"[Atoms] Angs"
         DO i = 1, NUMAT
            WRITE(xunit,'(1X,A2,2X,I3,2X,I3,2X,F10.5,2X,F10.5,2X,
     &         F10.5)')ELEMNT(NAT(i)),i,NAT(i),COORD(1,i),
     &         COORD(2,i),COORD(3,i)
         END DO
         WRITE(xunit,'(a)')"[GEOMETRIES] XYZ"
      END IF

C     Open file for output of velocity if requested.
      IF (write_vel) THEN
         OPEN(UNIT=vunit,NAME=vfile,STATUS="NEW",ACTION="WRITE",
     &        IOSTAT=io_disk)
         IF (io_disk .NE. 0) THEN
            WRITE(*,*)
            WRITE(*,'("File ",A," already exist.")')vfile
            WRITE(*,'("Please change the name of output file")')
            WRITE(*,*)
            STOP 'Abnormal termination in sub. DYNAM'
         END IF
      END IF

C *** Initialization for MD loop and initial printing.
      istat = 1
      IF (iout .GE. 1) THEN
         WRITE(*,*)
         WRITE(*,*)
         WRITE(*,*)"***** STARTING MD loop ****"
         WRITE(*,'("Initial state for dynamics: ",I1)')istat
         WRITE(*,*)
         WRITE(*,*)
      END IF
      IF (iout .EQ. 1 .OR. iout. EQ. 2) THEN
         WRITE(*,*)
         WRITE(*,'(" #mdstep",3X,"total energy",2X,"kinetic energy",2X,
     &          "potent. energy",2X,"temperature",2X,"gradient norm")')
         WRITE(*,'("        ",3X,"  (kcal/mol)",2X,"   (kcal/mol) ",2X,
     &          "  (kcal/mol)  ",2X,"    (K)    ",2X,"(kcal/(mol*A))")')
         WRITE(*,*)
         WRITE(*,'(I8,5(1X,F14.7))')mdstep,E_tot,K,ENERGX,T_ist,CNORM
      END IF
      istatt = istat
C     *
C *** Start of the MD loop.
C     *
      DO ist = 1, nstep
C     Print current MD step.
         IF (iout .EQ. 0 .OR. iout .EQ. 3) THEN
            WRITE(*,'("MD step: ",I5)')ist
         END IF

C *** SAVE TRAJECTORY TO FILES
         
C     Coordinates
         IF (write_traj .AND. MOD(ist,fsav).EQ.0) THEN
            WRITE(xunit,*)NUMAT
            WRITE(xunit,*)
            DO i = 1, NUMAT
               WRITE(xunit,'(A2,3X,F13.8,3X,F13.8,3X,F13.8)')
     &       ELEMNT(NAT(i)), COORD(1,i), COORD(2,i), COORD(3,i)
            END DO
         END IF
        
C     Velocity
         IF (write_vel .AND. MOD(ist,fsav).EQ.0) THEN 
            DO i = 1, NUMAT
               WRITE(vunit,'(F13.8,3X,F13.8,3X,F13.8)')vx(i),vy(i),vz(i)
            END DO
            WRITE(vunit,*)
         END IF

C     LANGEVIN
         IF (g0.gt.0 .and. ist.eq.1) THEN
            call langevin(AMS,vx,vy,vz,g0,temp0,CG,NUMAT,dt,ist,1)
         ENDIF

C *** COMPUTE NEW VELOCITIES AND COORDINATES.
 
         DO i = 1, NUMAT
            delta = sca*0.5D0*dt/AMS(i)
            vx(i) = vx(i) - CG(1,i)*delta
            vy(i) = vy(i) - CG(2,i)*delta
            vz(i) = vz(i) - CG(3,i)*delta   
            COORD(1,i) = COORD(1,i) + vx(i)*dt
            COORD(2,i) = COORD(2,i) + vy(i)*dt
            COORD(3,i) = COORD(3,i) + vz(i)*dt
         END DO

C     Debug output of velocities and coordinates
         IF (iout .GE. 3) THEN
            WRITE(*,*)
            WRITE(*,'("+",(47("-")),"+")')
            WRITE(*,'("|",3X,"MD step: ",I4," - First update of
     & velocity",4X,"|")')ist
            WRITE(*,'("|",47X,"|")')
            WRITE(*,'("| Atom",8X,"vx",12X,"vy",12X,"vz",4X,"|")')
            DO i = 1, NUMAT
               WRITE(*,'("|",1X,I3,2X,F12.5,2X,F12.5,2X,F12.5," |")')i,
     &                vx(i),vy(i),vz(i)
            END DO
            WRITE(*,'("+",(47("-")),"+")')
            WRITE(*,'("|",5X,"MD step: ",I4," - Update of
     & coordinates",5X,"|")')ist
            WRITE(*,'("|",47X,"|")')
            WRITE(*,'("| Atom",9X,"x",13X,"y",13X,"z",4X,"|")')
            DO i = 1, NUMAT
               WRITE(*,'("|",1X,I3,2X,F12.5,2X,F12.5,2X,F12.5," |")')i,
     &                COORD(1,i),COORD(2,i),COORD(3,i)
            END DO
            WRITE(*,'("+",(47("-")),"+")')
         END IF

C *** COMPUTE ENERGY AND GRADIENT.

         CALL SCF(ARRAY,LM5,ICALL,SCFCAL)
         ENERGX = ENERGY

C *** Langevin
         IF (g0.gt.0) THEN
            call langevin(AMS,vx,vy,vz,g0,temp0,CG,NUMAT,dt,ist,1)
         ENDIF

C     Check for convergency problems
         IF (ICALL .EQ. -1) THEN
            WRITE(*,*)
            WRITE(*,*)"CONVERGENCY PROBELMS!!!"
            WRITE(*,*)"The MD simulation will end here."
            WRITE(*,*)
            STOP 'Abnormal termination in sub. BO_DYNAM'
         END IF

C     Debug output of gradient
         IF (iout .GE. 3) THEN
            WRITE(*,*)
            WRITE(*,'("+",(47("-")),"+")')
            WRITE(*,'("|",11X,"MD step: ",I4," - Gradient",12X,"|")')ist
            WRITE(*,'("|",47X,"|")')
            WRITE(*,'("| Atom",8X,"Gx",12X,"Gy",12X,"Gz",4X,"|")')
            DO i = 1, NUMAT
               WRITE(*,'("|",1X,I3,2X,F12.5,2X,F12.5,2X,F12.5," |")')
     &                i,CG(1,i),CG(2,i),CG(3,i)
            END DO
            WRITE(*,'("+",(47("-")),"+")')
         END IF

C *** Update velocity to half step forward
         DO i = 1, NUMAT
            delta = sca*0.5D0*dt/AMS(i)
            vx(i) = vx(i) - CG(1,i)*delta
            vy(i) = vy(i) - CG(2,i)*delta
            vz(i) = vz(i) - CG(3,i)*delta   
         END DO

C     Debug output of velocities
         IF (iout .GE. 3) THEN
            WRITE(*,*)
            WRITE(*,'("+",(47("-")),"+")')
            WRITE(*,'("|",3X,"MD step: ",I4," - Second update of
     & velocity",3X,"|")')ist
            WRITE(*,'("|",47X,"|")')
            WRITE(*,'("| Atom",8X,"vx",12X,"vy",12X,"vz",4X,"|")')
            DO i = 1, NUMAT
               WRITE(*,'("|",1X,I3,2X,F12.5,2X,F12.5,2X,F12.5," |")')
     &                i,vx(i),vy(i),vz(i)
            END DO
            WRITE(*,'("+",(47("-")),"+")')
         END IF

C *** Update mdstep
         mdstep = mdstep + 1

C *** Velocity scaling
         IF (vs) THEN
            IF (mod(ist,fvs) .EQ. 0) THEN
               IF (.NOT. write_rest) THEN
                  WRITE(*,*)
                  WRITE(*,*)"WARNING!!"
                  WRITE(*,*)"A velocity scaling run is attempted"
                  WRITE(*,*)"with no final saving for restart."
                  WRITE(*,*)"Velocity scaling is highly reccomended"
                  WRITE(*,*)"to be used only for equilibration."
                  WRITE(*,*)"Thus, writing a restart file would be"
                  WRITE(*,*)"a good idea."
                  WRITE(*,*)
               END IF
               CALL bo_vel_scal(iout,NUMAT,AMS,vx,vy,vz,Tfix,vs_Emax,nf)
               IF (notra) THEN
                  CALL bo_v_remove_tra(iout,NUMAT,AMS,vx,vy,vz)
               END IF
               IF (norot) THEN
                  CALL bo_v_remove_rot(iout,NUMAT,AMS,COORD(1,:),
     &                              COORD(2,:),COORD(3,:),vx,vy,vz)
               END IF
            END IF
         END IF

C *** OUTPUT CURRENT RESULTS
         IF (iout .EQ. 1 .OR. iout .EQ. 2) THEN
            CALL bo_Kene(iout,NUMAT,AMS,vx,vy,vz,K)
            CALL bo_Tist(iout,K,nf,T_ist)
            E_tot = K+ENERGX
            WRITE(*,'(I8,5(1X,F14.7))')mdstep,E_tot,K,ENERGX,T_ist,CNORM
         END IF

C *** OUTPUT STATISTICS
         IF (write_stats) THEN
            IF (avstat .OR. MOD(ist,fstat).EQ.0) THEN
               CALL bo_outpr2(iout,sunit,mdstep,NUMAT,nf,AMS,vx,vy,vz,
     &                     IN2(159),istatt,ENERGX,avstat,
     &                     ist,fstat,E_av,K_av,V_av,T_av,P2_av,
     &                     Px_av,Py_av,Pz_av,L2_av,Lx_av,Ly_av,
     &                     Lz_av)
            END IF
         END IF

C     End of MD loop

      END DO
         
C *** CLOSE OUTPUT FILES IF NECESSARY

      IF (write_stats) THEN
         CLOSE (UNIT=sunit)
      END IF

      IF (write_traj) THEN
         CLOSE(UNIT=xunit)
      END IF

      IF (write_vel) THEN
         CLOSE(UNIT=vunit)
      END IF

C *** Write restart file if requested
      
      IF (write_rest) THEN
         CALL bo_write_res(iout,rfile,NUMAT,COORD(1,:),COORD(2,:)
     &                  ,COORD(3,:),vx,vy,vz)
      END IF
      
      END SUBROUTINE

C=============================================================================C

      SUBROUTINE bo_nmlst(iout,nstep,dt,temp0,norot,notra,init_stat,
     &                 write_stats,sunit,sfile,write_traj,xunit,
     &                 xfile,write_vel,vunit,vfile,ene_tol,fstat,
     &                 avstat,fsav,restart,write_rest,rfile,vs,
     &                 Tfix,fvs,vs_Emax,
     &                 rnd_gen,rnd_seed,g0)

C     This subroutine manages the name list options.

C  VARIABLES  (in namelist order)
C
C nstep         Max number of MD steps 
C dt            Time step [in picoseconds]
C temp0         Initial temperature   
C norot         Flag to select initial velocities with zero angular momentum
C notra         Flag to select initial velocities with zero linear momentum
C init_stat     Initial state 
C write_stats   Flag to allow writing of statistics 
C sunit         Fortran unit for statistics file 
C sfile         Statistics file name 
C write_traj    Flag to allow writing trajectory file
C xunit         Fortran unit for trajectory file 
C xfile         Trajectory file name 
C write_vel     Flag to allow writing of velocities 
C vunit         Fortran unit for velocity file
C vfile         Velocity file name
C ene_tol       Threshold for relative variation of total energy
C fstat         Frequency for saving in statistics file                    
C                 = 1  every step                                          
C                 = n  every n steps
C avstat        Flag to turn on statistics averaging                       
C               If fstat = n > 1 the average value over n steps will be saved
C fsav          Frequency for saving in trajectory and velocity file       
C                 = 1  every step                                          
C                 = n  every n steps
C restart       Flag to allow restarting form file 
C write rest    Flag to allow writing the restart file   
C rfile         Restart file name
C rnd_gen       Algorithm for the generation of random numbers:
C                 standard  -> standard FORTRAN algorithm [RANDOM_NUMBER]
C                 PM_BD -> Park and Miller algorithm with Bays-Durham shuffle
C                 knuth -> Knuth subtractive algorithm        
C rnd_seed      Integer to seed random number generator.
C               If -1 (default), a seed is generated randomly, e.g. with system clock
C vs            Flag to enable velocity scaling 
C Tfix          Temperature to be reached with velocity scaling
C fvs           Frequency for performing velocity scaling                
C                 = 1  every step                                          
C                 = n  every n steps
C vs_Emax       Maximum kinetic energy correction allowed in velocity scaling

      IMPLICIT NONE

C     NAMELIST VARIABLES
      INTEGER :: iout
      INTEGER :: nstep
      REAL*8 :: dt
      REAL*8 :: temp0
      LOGICAL :: norot
      LOGICAL :: notra
      INTEGER :: init_stat
      LOGICAL :: write_stats
      INTEGER :: sunit
      CHARACTER(20) :: sfile
      LOGICAL :: write_traj
      INTEGER :: xunit
      CHARACTER(20) :: xfile
      LOGICAL :: write_vel
      INTEGER :: vunit
      CHARACTER(20) :: vfile
      REAL*8 :: ene_tol
      INTEGER :: fstat
      LOGICAL :: avstat
      INTEGER :: fsav
      LOGICAL :: restart
      LOGICAL :: write_rest
      CHARACTER(20) :: rfile
      CHARACTER(8) :: rnd_gen
      INTEGER :: rnd_seed
      LOGICAL :: vs
      REAL*8 :: Tfix
      INTEGER :: fvs
      REAL*8 :: vs_Emax
      REAL*8 :: g0

      NAMELIST / dynvar / iout, nstep, dt, temp0, norot, notra,
     &                    init_stat, write_stats, sunit, sfile,
     &                    write_traj, xunit, xfile, write_vel, 
     &                    vunit, vfile,ene_tol, fstat, avstat, 
     &                    fsav, restart, write_rest, rfile, 
     &                    rnd_gen, rnd_seed, 
     &                    vs, Tfix, fvs, vs_Emax, g0

C     LOCAL VARIABLES
      INTEGER :: file_exist
      INTEGER :: io_disk

C     COMMON
      INTEGER :: IN2
      COMMON
     ./INOPT2/ IN2(300)

C *** Initialization of variables
      iout = 0
      nstep = 10
      dt = 5.d-5
      temp0 = 300.d0
      norot = .TRUE.
      notra = .TRUE.
      init_stat = 1
      write_stats = .TRUE.
      sunit = 30
      sfile = "stat.out"
      write_traj = .TRUE.
      xunit = 31
      xfile = "traj.out"
      write_vel = .FALSE.
      vunit = 32
      vfile = "vel.out"
      ene_tol = 1.D-2
      fstat = 1
      IF (fstat .EQ. 1) THEN
         avstat = .FALSE.
      ELSE
         avstat = .TRUE.
      END IF
      fsav = 1
      restart = .FALSE.
      write_rest = .TRUE.
      rfile = "dynam.restart"
      rnd_gen = "standard"
      rnd_seed = -1
      vs = .FALSE.
      Tfix = temp0
      fvs = 1
      vs_Emax = -1.d0    ! negative values mean no limit
      g0 = 0.0d0


C *** Check if a namelist file is already there. 
C     If not, write namelist file with default values.
C     If yes, read namelist file.

      INQUIRE(FILE="dynvar.in", EXIST=file_exist)

      IF(.NOT. file_exist) THEN
         OPEN(UNIT=31,NAME="dynvar.in",STATUS="NEW",ACTION="WRITE",
     &     IOSTAT=io_disk)
         IF (io_disk .EQ. 0) THEN
            WRITE(31,NML=dynvar)
         ELSE
            WRITE(*,*)
            WRITE(*,*)"Unknown disk error"
            WRITE(*,*)
            STOP 'Abnormal temination in sub. DYNAM'
         END IF
      ELSE
         OPEN(UNIT=31,NAME="dynvar.in",STATUS="UNKNOWN",
     &         ACTION="READ",IOSTAT=io_disk)
         IF (io_disk .EQ. 0) THEN
            READ(31,NML=dynvar)
         ELSE
            WRITE(*,*)
            WRITE(*,*)"Unknown disk error"
            WRITE(*,*)
            STOP 'Abnormal temination in sub. DYNAM'
         END IF
      END IF

      CLOSE(UNIT=31)

C     Print namelist variables.
      IF (iout .GE. 1) THEN
         WRITE(*,*)
         WRITE(*,*)"       Namelist variables"
         WRITE(*,*)
         WRITE(*,'("+---------------+---------------------+")')
         WRITE(*,'("| iout ",9X,"|",19X,I1," |")')iout
         WRITE(*,'("| nstep ",8X,"|",15X,I5," |")')nstep
         WRITE(*,'("| dt ",11X,"|",11X,F9.6," |")')dt
         WRITE(*,'("| temp0 ",8X,"|",9X,F11.5," |")')temp0
         WRITE(*,'("| norot ",8X,"|",19X,L1," |")')norot
         WRITE(*,'("| notra ",8X,"|",19X,L1," |")')notra
         WRITE(*,'("| init_stat ",4X,"|",19X,I1," |")')init_stat
         WRITE(*,'("| write_stats ",2X,"|",19X,L1," |")')write_stats
         WRITE(*,'("|   sunit ",6X,"|",17X,I3," |")')sunit
         WRITE(*,'("|   sfile ",6X,"|",A20," |")')sfile
         WRITE(*,'("| write_traj ",3X,"|",19X,L1," |")')write_traj
         WRITE(*,'("|   xunit ",6X,"|",17X,I3," |")')xunit
         WRITE(*,'("|   xfile ",6X,"|",A20," |")')xfile
         WRITE(*,'("| write_vel ",4X,"|",19X,L1," |")')write_vel
         WRITE(*,'("|   vunit ",6X,"|",17X,I3," |")')vunit
         WRITE(*,'("|   vfile ",6X,"|",A20," |")')vfile
         WRITE(*,'("| ene_tol ",6X,"|",14X,F6.4," |")')ene_tol
         WRITE(*,'("| fstat ",8X,"|",17X,I3," |")')fstat
         WRITE(*,'("|   avstat ",5X,"|",19X,L1," |")')avstat
         WRITE(*,'("| fsav ",9X,"|",17X,I3," |")')fsav
         WRITE(*,'("| restart ",6X,"|",19X,L1," |")')restart
         WRITE(*,'("| write_rest ",3X,"|",19X,L1," |")')write_rest
         WRITE(*,'("|   rfile ",6X,"|",A20," |")')rfile
         WRITE(*,'("|   rnd_gen ",4X,"|",12X,A8," |")')rnd_gen
         WRITE(*,'("|   rnd_seed ",3X,"|",9X,I11," |")') rnd_seed
         WRITE(*,'("| vs ",11X,"|",19X,L1," |")')vs
         WRITE(*,'("|   Tfix ",7X,"|",9X,F11.5," |")')Tfix
         WRITE(*,'("|   fvs ",8X,"|",16X,I4," |")')fvs
         WRITE(*,'("|   vs_Emax ",4X,"|",8X,F12.6," |")')vs_Emax
         WRITE(*,'("|   g0      ",4X,"|",8X,F12.6," |")')g0
         WRITE(*,'("+---------------+---------------------+")')
      END IF

      END SUBROUTINE

C=============================================================================C

      SUBROUTINE bo_v_rnd(iout,NUMAT,AMS,rnd_gen,rnd_count,vx,vy,vz)

C     This subroutine creates random velocities.
C     Starting velocities are assigned as follows:
C     (1) a random number 0=<q<1 is chosen
C     (2) v = (q/(1-q)))/mass

      IMPLICIT NONE

C     INPUT VARIABLES
      INTEGER :: iout
      INTEGER :: NUMAT
      REAL*8, DIMENSION(NUMAT) :: AMS
      CHARACTER(8) :: rnd_gen

C     INPUT/OUTPUT VARIABLES
      INTEGER :: rnd_count

C     OUTPUT VARIABLES
      REAL*8, DIMENSION(NUMAT) :: vx, vy, vz

C     LOCAL VARIABLES
      INTEGER :: i, j
      REAL*8, DIMENSION(3) :: q

C     Debug output
      IF (iout .GE. 3) THEN
         WRITE(*,*)
         WRITE(*,*)">>>v_rnd"
         WRITE(*,*)
         WRITE(*,*)"Random velocities assignement"
         WRITE(*,*)
         WRITE(*,*)"Random numbers:"
      END IF

CTWK  Seeded in DYNAM
C     CALL RANDOM_SEED

C *** ASSIGN RANDOM VELOCITIES.

      DO i = 1, NUMAT

CTWK     Choose generator consistently  
         IF (rnd_gen .EQ. "standard") THEN
            CALL RANDOM_NUMBER(q)
         ELSE IF (rnd_gen .EQ. "PM_BD") THEN
            DO j = 1, 3
               CALL nran2(q(j),1,.FALSE.)
            END DO
         ELSE IF (rnd_gen .EQ. "knuth") THEN
            DO j = 1, 3
               CALL nran3(q(j),1,.FALSE.)
            END DO
         END IF

         rnd_count = rnd_count + 3

         IF (iout .GE. 3) THEN
            WRITE(*,'(16X,F8.6,2X,F8.6,2X,F8.6)')q(1),q(2),q(3)
         ENDIF

         vx(i) = (q(1)/(1-q(1)))/AMS(i)
         vy(i) = (q(2)/(1-q(2)))/AMS(i)
         vz(i) = (q(3)/(1-q(3)))/AMS(i)
         
      END DO

C     Debug output
      IF (iout .GE. 3) THEN
         WRITE(*,*)        
         WRITE(*,*)"Velocities [A/ps]"
         WRITE(*,'("Atom",8X,"vx",12X,"vy",12X,"vz")')
         DO i = 1, NUMAT
           WRITE(*,'(I3,2X,F12.5,2X,F12.5,2X,F12.5)')i,vx(i),vy(i),vz(i)
         END DO
         WRITE(*,*)
         WRITE(*,*)"v_rnd<<<"
         WRITE(*,*)
      END IF

      END SUBROUTINE

C=============================================================================C

      SUBROUTINE bo_v_remove_tra(iout,NUMAT,AMS,vx,vy,vz)

C     This routine removes any overall translational motion
C     from the molecular system in three steps:
C     (1) total momentum p=sum(m_i*v_i) is computed
C     (2) M = sum(m_i) 
C     (3) v = v - (p/M)
C     In this way we have zero total linear momentum.

      IMPLICIT NONE

C     INPUT VARIABLES
      INTEGER :: iout
      INTEGER :: NUMAT
      REAL*8, DIMENSION(NUMAT) :: AMS

C     INPUT/OUTPUT VARIABLES
      REAL*8, DIMENSION(NUMAT) :: vx, vy, vz

C     LOCAL VARIABLES
      INTEGER :: i
      REAL*8 :: px,py,pz
      REAL*8 :: M
      REAL*8 :: facx,facy,facz

C     Debug output.
      IF (iout .GE. 3) THEN
         WRITE(*,*)
         WRITE(*,*)">>>v_remove_tra"
      END IF

C     Steps (1) and (2)
      px = 0.D0
      py = 0.D0
      pz = 0.D0

      DO i = 1, NUMAT
         px = px + AMS(i)*vx(i)
         py = py + AMS(i)*vy(i)
         pz = pz + AMS(i)*vz(i)
         M = M + AMS(i)
      END DO

      facx = px/M
      facy = py/M
      facz = pz/M

C     Step (3)
      DO i = 1, NUMAT
         vx(i) = vx(i) - facx
         vy(i) = vy(i) - facy
         vz(i) = vz(i) - facz
      END DO

C     Debug output.
      IF (iout .GE. 3) THEN
         WRITE(*,*)
         WRITE(*,*)"Linear momentum [AMU*A/ps]"
         WRITE(*,'(5X,"px",12X,"py",12X,"pz")')
         WRITE(*,'(F12.5,2X,F12.5,2X,F12.5)')px,py,pz
         WRITE(*,*)
         WRITE(*,'("Total mass = ",F10.5)')M
         WRITE(*,*)
         WRITE(*,*)"Translation corrections"
         WRITE(*,'("facx = ", F11.5)')facx
         WRITE(*,'("facy = ", F11.5)')facy
         WRITE(*,'("facz = ", F11.5)')facz
         WRITE(*,*)
         WRITE(*,*)"New velocities [A/ps]"
         WRITE(*,'("Atom",8X,"vx",12X,"vy",12X,"vz")')
         DO i = 1, NUMAT
           WRITE(*,'(I3,2X,F12.5,2X,F12.5,2X,F12.5)')i,vx(i),vy(i),vz(i)
         END DO
         WRITE(*,*)
         WRITE(*,*)"v_remove_tra<<<"
         WRITE(*,*)
      END IF

      END SUBROUTINE

C=============================================================================C

      SUBROUTINE bo_v_remove_rot(iout,NUMAT,AMS,x,y,z,vx,vy,vz)

C     This subroutine removes any overall rotation from the 
C     molecular system in four steps:
C     (1) Calculate total angular momentum vector L
C     (2) Calculate moment of inertia tensor I
C     (3) Find the angular velocity vector w by
C         by solving the linear equation L=Iw
C     (4) Apply the reverse angular velocity to each atom in turn,
C         cancelling out the overall rotation of the system
C
C     AUTHOR: T. Keal
C     DATE: November 2006  

      IMPLICIT NONE

C     INPUT VARIABLES
      INTEGER :: iout
      INTEGER :: NUMAT
      REAL*8, DIMENSION(NUMAT) :: AMS
      REAL*8, DIMENSION(NUMAT) :: x,y,z

C     INPUT/OUTPUT VARIABLES
      REAL*8, DIMENSION(NUMAT) :: vx, vy, vz

C     LOCAL VARIABLES
      INTEGER :: i, la_return
      REAL*8, DIMENSION(3) :: L, dum1
      REAL*8, DIMENSION(3,3) :: MoI
      REAL*8, DIMENSION(100) :: dum2
      REAL*8, DIMENSION(NUMAT) :: xx, yy, zz

C     Debug output.
      IF (iout .GE. 3) THEN
         WRITE(*,*)
         WRITE(*,*)">>>v_remove_rot"
      END IF

C *** Step (1) Calculate total angular momentum vector L(1:3)

      CALL bo_ang_mom(iout,NUMAT,AMS,x,y,z,vx,vy,vz,L(1),L(2),L(3))

C *** Step (2) Calculate moment of inertia tensor I (MoI)
C     with respect to centre of mass

      CALL bo_pos_wrt_com(iout,NUMAT,AMS,x,y,z,xx,yy,zz)

      MoI = 0.D0

      DO i = 1, NUMAT
         MoI(1,1) = MoI(1,1) + (AMS(i) * (yy(i)*yy(i) + zz(i)*zz(i)))
         MoI(2,2) = MoI(2,2) + (AMS(i) * (xx(i)*xx(i) + zz(i)*zz(i)))
         MoI(3,3) = MoI(3,3) + (AMS(i) * (xx(i)*xx(i) + yy(i)*yy(i)))
         MoI(1,2) = MoI(1,2) - (AMS(i) * xx(i) * yy(i))
         MoI(1,3) = MoI(1,3) - (AMS(i) * xx(i) * zz(i))
         MoI(2,3) = MoI(2,3) - (AMS(i) * yy(i) * zz(i))
      END DO

C     The moment of inertia tensor is symmetrical
      MoI(2,1) = MoI(1,2)
      MoI(3,1) = MoI(1,3)
      MoI(3,2) = MoI(2,3)

C     Debug output.
      IF (iout .GE. 3) THEN
         WRITE(*,*)
         WRITE(*,*)"Moment of inertia"
         WRITE(*,'(9X,"1",11X,"2",11X,"3")')
         WRITE(*,'("1",4X,F10.4,2X,F10.4,2X,F10.4)')MoI(1,1),
     &            MoI(1,2),MoI(1,3)
         WRITE(*,'("2",16X,F10.4,2X,F10.4)')MoI(2,2),MoI(2,3)
         WRITE(*,'("3",28X,F10.4)')MoI(3,3)
      END IF

C *** Step (3) Calculate the angular velocity vector w
C     The LAPACK routine overwrites the input array L with this quantity
C     so from this point on L is actually the angular velocity vector
C     MoI is also overwritten
C     See http://www.netlib.org/lapack/double/dsysv.f for more details

      CALL DSYSV('U', 3, 1, MoI, 3, dum1, L, 3, dum2, 100, la_return)

      IF (la_return .NE. 0) THEN
         STOP 'Angular velocities could not be found in v_remove_rot!'
      ENDIF

C *** Step (4) Apply the angular velocities in reverse
C     thus cancelling out the overall angular momentum.
C     The velocities are corrected according to
C     v -> v - w x r
C     where r are atomic positions relative to the centre of mass
      DO i = 1, NUMAT
         vx(i) = vx(i) - (L(2)*zz(i) - L(3)*yy(i))
         vy(i) = vy(i) - (L(3)*xx(i) - L(1)*zz(i))
         vz(i) = vz(i) - (L(1)*yy(i) - L(2)*xx(i))
      END DO

C     Debug output.
      IF (iout .GE. 3) THEN
         WRITE(*,*)
         WRITE(*,*)"Angular velocity vector"
         WRITE(*,'(4X,"wx",10X,"wy",10X,"wz")')
         WRITE(*,'(F10.4,2X,F10.4,2X,F10.4)')L(1),L(2),L(3)
         WRITE(*,*)
         WRITE(*,*)"New velocities [A/ps]"
         WRITE(*,'("Atom",8X,"vx",12X,"vy",12X,"vz")')
         DO i = 1, NUMAT
           WRITE(*,'(I3,2X,F12.5,2X,F12.5,2X,F12.5)')i,vx(i),vy(i),vz(i)
         END DO
         WRITE(*,*)
         WRITE(*,*)"v_remove_rot<<<"
         WRITE(*,*)
      END IF

      END SUBROUTINE bo_v_remove_rot


C======================================================================C

      SUBROUTINE bo_term_scal(iout,NUMAT,AMS,vx,vy,vz,temp0,N)

C     This subroutine performs thermal scaling.
C     Velocities are scaled as follows: Compute
C     (1) the "instantaneous" velocity T=(1/2)*sum(m_i*v_i^2)/(k*N);
C         Boltzmann constant k; N is the number of degrees of freedom
C     (2) scaling factor a = SQRT(T_0/T) for desired temperature T_0,
C         T_0 = temp0 (input via parameter list)
C     (3) v = a*v; in this way we have T=T_0

      IMPLICIT NONE

C     INPUT VARIABLES
      INTEGER :: iout
      INTEGER :: NUMAT
      REAL*8, DIMENSION(NUMAT) :: AMS
      REAL*8 :: temp0
      INTEGER :: N

C     INPUT/OUTPUT VARIABLES
      REAL*8, DIMENSION(NUMAT) :: vx, vy, vz

C     LOCAL VARIABLES
      REAL*8 :: K
      REAL*8 :: T_ist
      REAL*8 :: conv
      INTEGER :: i

C     Debug output.
      IF (iout .GE. 3) THEN
         WRITE(*,*)
         WRITE(*,*)">>>term_scal"
      END IF

C     Step (1)
      CALL bo_Kene(iout,NUMAT,AMS,vx,vy,vz,K)
      CALL bo_Tist(iout,K,N,T_ist)

C     Step (2)
      conv = DSQRT(temp0/T_ist)

C     Step (3)
      vx = conv*vx
      vy = conv*vy
      vz = conv*vz

C     Debug output.
      IF (iout .GE. 3) THEN
         WRITE(*,*)
         WRITE(*,'("Conversion factor = ",F10.4)')conv
         WRITE(*,*)
         WRITE(*,*)"New velocities [A/ps]"
         WRITE(*,'("Atom",8X,"vx",12X,"vy",12X,"vz")')
         DO i = 1, NUMAT
           WRITE(*,'(I3,2X,F12.5,2X,F12.5,2X,F12.5)')i,vx(i),vy(i),vz(i)
         END DO
         WRITE(*,*)
         WRITE(*,*)"term_scal<<<"
         WRITE(*,*)
      END IF

      END SUBROUTINE

C======================================================================C

      SUBROUTINE bo_lin_mom(iout,NUMAT,AMS,vx,vy,vz,Px,Py,Pz)

C     This subroutine computes total linear momentum.

      IMPLICIT NONE

C     INPUT VARIABLES
      INTEGER :: iout
      iNTEGER :: NUMAT
      REAL*8, DIMENSION(NUMAT) :: AMS
      REAL*8, DIMENSION(NUMAT) :: vx,vy,vz
      
C     OUTPUT VARIABLES
      REAL*8 :: Px,Py,Pz

C     LOCAL VARIABLES
      INTEGER :: i

C     Debug output.
      IF (iout .GE. 3) THEN
         WRITE(*,*)
         WRITE(*,*)">>>lin_mom"
      END IF

C     COMPUTE LINEAR MOMENTUM.
      Px = 0.D0
      Py = 0.D0
      Pz = 0.D0
      DO i = 1, NUMAT
         Px = Px + AMS(i)*vx(i)
         Py = Py + AMS(i)*vy(i)
         Pz = Pz + AMS(i)*vz(i)
      END DO

C     Debug output.
      IF (iout .GE. 3) THEN
         WRITE(*,*)
         WRITE(*,*)"Linear momentum [AMU*A/ps]"
         WRITE(*,'(5X,"px",12X,"py",12X,"pz")')
         WRITE(*,'(F12.5,2X,F12.5,2X,F12.5)')px,py,pz
         WRITE(*,*)
         WRITE(*,*)"lin_mom<<<"
         WRITE(*,*)
      END IF

      END SUBROUTINE

C======================================================================C

      SUBROUTINE bo_ang_mom(iout,NUMAT,AMS,x,y,z,vx,vy,vz,Lx,Ly,Lz)

C     This subroutine computes total angular momentum with respect
C     to the center of mass.

      IMPLICIT NONE

C     INPUT VARIABLES
      INTEGER :: iout
      INTEGER :: NUMAT
      REAL*8, DIMENSION(NUMAT) :: AMS
      REAL*8, DIMENSION(NUMAT) :: x,y,z
      REAL*8, DIMENSION(NUMAT) :: vx,vy,vz

C     OUTPUT VARIABLES
      REAL*8 :: Lx,Ly,Lz

C     LOCAL VARIABLES
      INTEGER :: i
      REAL*8, DIMENSION(NUMAT) :: xx,yy,zz

C     Debug output.
      IF (iout .GE. 3) THEN
         WRITE(*,*)
         WRITE(*,*)">>>ang_mom"
      END IF

C     Get atomic positions with respect to centre of mass.

      CALL bo_pos_wrt_com(iout,NUMAT,AMS,x,y,z,xx,yy,zz)

C     Compute angular momentum.
      Lx = 0.D0
      Ly = 0.D0
      Lz = 0.D0
      DO i = 1, NUMAT
         Lx = Lx + AMS(i)*(yy(i)*vz(i) - zz(i)*vy(i))
         Ly = Ly + AMS(i)*(zz(i)*vx(i) - xx(i)*vz(i))
         Lz = Lz + AMS(i)*(xx(i)*vy(i) - yy(i)*vx(i))
      END DO

C     Debug output.
      IF (iout .GE. 3) THEN
         WRITE(*,*)
         WRITE(*,*)"Angular momentum [AMU*A^2/ps]"
         WRITE(*,'(5X,"Lx",12X,"Ly",12X,"Lz")')
         WRITE(*,'(F12.5,2X,F12.5,2X,F12.5)')Lx,Ly,Lz
         WRITE(*,*)
         WRITE(*,*)"ang_mom<<<"
         WRITE(*,*)
      END IF


      END SUBROUTINE

C======================================================================C

      SUBROUTINE bo_pos_wrt_com(iout,NUMAT,AMS,x,y,z,xx,yy,zz)

C     Calculates atom positions with respect to centre of mass.

      IMPLICIT NONE

C     INPUT VARIABLES
      INTEGER :: iout
      INTEGER :: NUMAT
      REAL*8, DIMENSION(NUMAT) :: AMS
      REAL*8, DIMENSION(NUMAT) :: x,y,z

C     OUTPUT VARIABLES
      REAL*8, DIMENSION(NUMAT) :: xx,yy,zz

C     LOCAL VARIABLES
      INTEGER :: i
      REAL*8 :: xcm,ycm,zcm
      REAL*8 :: M

C     Debug output.
      IF (iout .GE. 3) THEN
         WRITE(*,*)
         WRITE(*,*)">>>pos_wrt_com"
      END IF

C     Find center of mass.
      xcm = 0.D0
      ycm = 0.D0
      zcm = 0.D0
      M = 0.D0

      DO i = 1, NUMAT
         xcm = xcm + x(i)*AMS(i)
         ycm = ycm + y(i)*AMS(i)
         zcm = zcm + z(i)*AMS(i)
         M = M + AMS(i)
      END DO

      xcm = xcm/M
      ycm = ycm/M
      zcm = zcm/M

C     Translate origin of coordinates to the center of mass.
      DO i = 1, NUMAT
         xx(i) = x(i) - xcm
         yy(i) = y(i) - ycm
         zz(i) = z(i) - zcm
      END DO

C     Debug output.
      IF (iout .GE. 3) THEN
         WRITE(*,*)
         WRITE(*,*)"Coordinates of center of mass [A]"
         WRITE(*,'("X = ",F10.5,3X,"Y = ",F10.5,3X,"Z = ",F10.5)')
     &              xcm,ycm,zcm
         WRITE(*,*)
         WRITE(*,*)"Coordinates in center of mass reference system [A]"
         WRITE(*,'("Atom",9X,"x",13X,"y",13X,"z")')
         DO i = 1, NUMAT
           WRITE(*,'(I3,2X,F12.5,2X,F12.5,2X,F12.5)')i,xx(i),yy(i),zz(i)
         END DO
         WRITE(*,*)
         WRITE(*,*)"pos_wrt_com<<<"
         WRITE(*,*)
      END IF

      END SUBROUTINE bo_pos_wrt_com

C======================================================================C

      SUBROUTINE bo_Kene(iout,NUMAT,AMS,vx,vy,vz,K)

C     This subroutine computes the total kinetic energy.

      IMPLICIT NONE

C     INPUT VARIABLES
      INTEGER :: iout
      INTEGER :: NUMAT
      REAL*8, DIMENSION(NUMAT) :: AMS
      REAL*8, DIMENSION(NUMAT) :: vx,vy,vz

C     OUTPUT VARIABLES
      REAL*8 :: K

C     LOCAL VARIABLES
      REAL*8 :: v2
      INTEGER :: i

C     PARAMETERS
      REAL*8 :: conv = 2.390057D-3  ! AMU*A^2/ps^2 -> kcal/mol

C     Debug output.
      IF (iout .GE. 3) THEN
         WRITE(*,*)
         WRITE(*,*)">>>Kene"
      END IF

C     Compute kinetic energy.
      v2 = 0.D0
      K = 0.D0
      DO i = 1, NUMAT
         v2 = vx(i)*vx(i) + vy(i)*vy(i) + vz(i)*vz(i)
         K = K + AMS(i)*v2
      END DO
      K = conv*0.5D0*K

C     Debug output.
      IF (iout .GE. 3) THEN
         WRITE(*,*)
         WRITE(*,'("v^2 = ",F10.5," A^2/ps^2")')v2
         WRITE(*,*)
         WRITE(*,'("Kinetic energy = ",F10.5," AMU*A^2/ps^2")')K
         WRITE(*,*)
         WRITE(*,*)"Kene<<<"
         WRITE(*,*)
      END IF

      END SUBROUTINE

C======================================================================C

      SUBROUTINE bo_Tist(iout,K,N,T)

C      This subroutine computes the instantaneous temperature.
C      T = (2*K)/(B*N)
C      K = kinetic energy
C      B = Boltzmann constant
C      N = number of degrees of freedom

      IMPLICIT NONE

C     INPUT VARIABLES
      INTEGER :: iout
      REAL*8 :: K
      INTEGER :: N

C     OUTPUT VARIABLES
      REAL*8 :: T

C     PARAMETERS
      REAL*8, PARAMETER :: boltz=1.987168981D-3 ! Boltzmann constant 
                                                ! [kcal/(mol*K)]
C     Debug output.
      IF (iout .GE. 3) THEN
         WRITE(*,*)
         WRITE(*,*)">>>Tist"
         WRITE(*,*)
      END IF

C     Instantaneous temperature.
      T = 2.d0*K/(boltz*REAL(N))

C     Debug output.
      IF (iout .GE. 3) THEN
         WRITE(*,*)
         WRITE(*,'("Instantaneous temperature = ",F10.5," K")')T
         WRITE(*,*)
         WRITE(*,*)"Tist<<<"
         WRITE(*,*)
      END IF

      END SUBROUTINE

C======================================================================C

      SUBROUTINE bo_outpr(mdstep,NUMAT,nf,AMS,vx,vy,vz,E_tot,K,V)

C     This subroutine prints initial statistics.

      USE LIMIT, ONLY: LM1

      IMPLICIT NONE

C     INPUT VARIABLES
      INTEGER :: mdstep
      INTEGER :: NUMAT
      INTEGER :: nf
      REAL*8, DIMENSION(NUMAT) :: AMS
      REAL*8, DIMENSION(NUMAT) :: vx,vy,vz
      REAL*8 :: E_tot
      REAL*8 :: K
      REAL*8 :: V
      REAL*8 :: COORD
      COMMON
     ./ATOMC / COORD(3,LM1)

C     LOCAL VARIABLES
      REAL*8 :: T_ist
      REAL*8 :: Px,Py,Pz
      REAL*8 :: Lx,Ly,Lz
      REAL*8, DIMENSION(NUMAT) :: x,y,z
      INTEGER :: i

C     Previous debug output.
C     print *, "E_tot", E_tot 
C     print *, "K", K
C     print *, "V", V

C     Copy coordinates.
      do i = 1, NUMAT
         x(i) = COORD(1,i)
         y(i) = COORD(2,i)
         z(i) = COORD(3,i)
      end do

C     Printing section.
      WRITE(*,*)
      WRITE(*,'(70("-"))')
      WRITE(*,*)
      WRITE(*,*)"                       INITIAL STATISTICS"

      CALL Tist(0,K,nf,T_ist)

      WRITE(*,*)
      WRITE(*,'("  mdstep",3X,"total energy",3X,"kinet energy",
     &    3X,"poten energy",4X,"temperature")')
      WRITE(*,'(I8,3x,F12.6,3X,F12.6,3X,F12.6,3X,F12.6)')mdstep,
     &    E_tot,K,V,T_ist

      WRITE(*,'("        ",(62(".")))')

      CALL bo_lin_mom(0,NUMAT,AMS,vx,vy,vz,Px,Py,Pz)

      WRITE(*,'(12X,"Px",11X,"Py",11X,"Pz")')
      WRITE(*,'(8X,F10.5,3X,F10.5,3X,F10.5)')Px,Py,Pz

      CALL bo_ang_mom(0,NUMAT,AMS,x,y,z,vx,vy,vz,Lx,Ly,Lz)
      
      WRITE(*,'(12X,"Lx",11X,"Ly",11X,"Lz")')
      WRITE(*,'(8X,F10.5,3X,F10.5,3X,F10.5)')Lx,Ly,Lz

      WRITE(*,'(70("-"))')
     
      END SUBROUTINE

C======================================================================C

      SUBROUTINE bo_outpr2(iout,sunit,mdstep,NUMAT,nf,AMS,vx,vy,vz,
     &                  nexstat,istat,EX,avstat,ist,fstat,E_av,K_av,
     &                  V_av,T_av,P2_av,Px_av,Py_av,Pz_av,L2_av,
     &                  Lx_av,Ly_av,Lz_av)

C     This subroutine processes averages and prints statistics.

      USE LIMIT, ONLY: LM1

      IMPLICIT NONE

C     INPUT VARIABLES
      INTEGER :: iout
      INTEGER :: sunit
      INTEGER :: mdstep
      INTEGER :: NUMAT
      INTEGER :: nf
      REAL*8, DIMENSION(NUMAT) :: AMS
      REAL*8, DIMENSION(NUMAT) :: vx,vy,vz
      INTEGER :: nexstat
      INTEGER :: istat
      REAL*8 :: EX
      LOGICAL :: avstat
      INTEGER :: ist
      INTEGER :: fstat
 
C     INPUT/OUTPUT VARIABLES
      REAL*8 :: E_av
      REAL*8 :: K_av
      REAL*8 :: V_av
      REAL*8 :: T_av
      REAL*8 :: P2_av
      REAL*8 :: Px_av
      REAL*8 :: Py_av
      REAL*8 :: Pz_av
      REAL*8 :: L2_av
      REAL*8 :: Lx_av
      REAL*8 :: Ly_av
      REAL*8 :: Lz_av


C     COMMON
      REAL*8 :: COORD
      COMMON
     ./ATOMC / COORD(3,LM1)

C     LOCAL VARIABLES
      REAL*8 :: T_ist
      REAL*8 :: Px,Py,Pz
      REAL*8 :: Lx,Ly,Lz
      REAL*8, DIMENSION(NUMAT) :: x,y,z
      REAL*8 :: P2
      REAL*8 :: L2
      INTEGER :: i      
      REAL*8 :: E_tot
      REAL*8 :: K
      REAL*8 :: V

C     Debug output.
      IF (iout .GE. 3) THEN
         WRITE(*,*)
         WRITE(*,*)">>>outpr2"
      END IF

C     Copy coordinates.
      do i = 1, NUMAT
         x(i) = COORD(1,i)
         y(i) = COORD(2,i)
         z(i) = COORD(3,i)
      end do

C     Compute relevant quantities.

      CALL bo_Kene(iout,NUMAT,AMS,vx,vy,vz,K)
      CALL bo_Tist(iout,K,nf,T_ist)

      E_tot = 0.D0
      V = 0.D0
      V = EX
      E_tot = K+V

      CALL bo_lin_mom(iout,NUMAT,AMS,vx,vy,vz,Px,Py,Pz)
      CALL bo_ang_mom(iout,NUMAT,AMS,x,y,z,vx,vy,vz,Lx,Ly,Lz)

      P2 = (Px*Px)+(Py*Py)+(Pz*Pz)
      L2 = (Lx*Lx)+(Ly*Ly)+(Lz*Lz)

      IF (avstat) THEN
         E_av = E_av + E_tot
         K_av = K_av + K
         V_av = V_av + V
         T_av = T_av + T_ist
         P2_av = P2_av + P2
         Px_av = Px_av + Px
         Py_av = Py_av + Py
         Pz_av = Pz_av + Pz
         L2_av = L2_av + L2
         Lx_av = Lx_av + Lx
         Ly_av = Ly_av + Ly
         Lz_av = Lz_av + Lz
      END IF
      
      IF (avstat .AND. MOD(ist,fstat).EQ. 0) THEN
         E_av = E_av/REAL(fstat)
         K_av = K_av/REAL(fstat)
         V_av = V_av/REAL(fstat)
         T_av = T_av/REAL(fstat)
         P2_av = P2_av/REAL(fstat)
         Px_av = Px_av/REAL(fstat)
         Py_av = Py_av/REAL(fstat)
         Pz_av = Pz_av/REAL(fstat)
         L2_av = L2_av/REAL(fstat)
         Lx_av = Lx_av/REAL(fstat)
         Ly_av = Ly_av/REAL(fstat)
         Lz_av = Lz_av/REAL(fstat)
      END IF

C     Printing section.

      IF (MOD(ist,fstat) .EQ. 0) THEN

         IF (avstat) THEN 
            WRITE(sunit,'(I8,1X,F14.7,1X,F14.7,1X,F14.7,1X,F14.7,1X,
     &            F14.7,1X,F14.7,1X,F14.7,1X,F14.7,1X,F14.7,1X,F14.7,1X,
     &            F14.7,1X,F14.7)')mdstep,E_av,K_av,V_av,T_av,P2_av,
     &        Px_av,Py_av,Pz_av,L2_av,Lx_av,Ly_av,Lz_av

            E_av = 0.D0
            K_av = 0.D0
            V_av = 0.D0
            T_av = 0.D0
            P2_av = 0.D0
            Px_av = 0.D0
            Py_av = 0.D0
            Pz_av = 0.D0
            L2_av = 0.D0
            Lx_av = 0.D0
            Ly_av = 0.D0
            Lz_av = 0.D0

         ELSE
            WRITE(sunit,'(I8,1X,F14.7,1X,F14.7,1X,F14.7,1X,F14.7,1X,
     &            F14.7,1X,F14.7,1X,F14.7,1X,F14.7,1X,F14.7,1X,F14.7,1X,
     &            F14.7,1X,F14.7)')mdstep,E_tot,K,V,T_ist,P2,Px,Py,
     &            Pz,L2,Lx,Ly,Lz
         END IF
         
      END IF

C     Debug output.
      IF (iout .GE. 3) THEN
         WRITE(*,*)
         WRITE(*,*)"outpr2<<<"
      END IF

      END SUBROUTINE

C======================================================================C

      SUBROUTINE bo_read_rest(iout,rfile,N,x,y,z,vx,vy,vz)

C     This subroutine reads the restart file.

      IMPLICIT NONE

C     INPUT VARIABLES
      INTEGER :: iout
      CHARACTER(20) :: rfile
      INTEGER :: N
      
C     OUTPUT VARIABLES
      REAL*8, DIMENSION(N) :: vx,vy,vz
      REAL*8, DIMENSION(N) :: x,y,z

C     LOCAL VARIABLES
      INTEGER :: i,j,k
      INTEGER :: disk_error
      LOGICAL :: file_exist
      CHARACTER(13) :: dummyc
      CHARACTER(7) :: restype
      INTEGER :: natom
      REAL*8 :: c1,c2
      REAL*8 :: dummyr

C     Debug output.
      IF (iout .GE. 3) THEN
         WRITE(*,*)
         WRITE(*,*)">>>read_rest"
      END IF

C     Check if restart file exists
      
      INQUIRE(FILE=rfile, EXIST=file_exist)
      
      IF (.NOT. file_exist) THEN
         WRITE(*,*)
         WRITE(*,*)"Restart file not found"
         WRITE(*,*)
         STOP 'Abnormal termination in sub. bo_read_rest'
      END IF

      OPEN(UNIT=29,NAME=rfile,STATUS="OLD", ACTION="READ",
     &     IOSTAT=disk_error)
      IF (disk_error .NE. 0) THEN
         WRITE(*,*)
         WRITE(*,*)"Unkown disk error"
         WRITE(*,*)
         STOP 'Abnormal termination in sub. bo_read_rest'
      END IF

C     Read header
      READ(29,*)dummyc,restype
      IF (restype .NE. "MD_only") THEN
         WRITE(*,*)
         WRITE(*,'("Restart file is inconsistent!")')
         WRITE(*,'(A, "is an unknown command")')restype
         WRITE(*,*)
         STOP 'Abnormal termination in bo_read_rest'
      END IF

C     Read number of atoms
      READ(29,*)dummyc,natom
      IF (dummyc .NE. "#N_atoms") THEN
         WRITE(*,*)
         WRITE(*,*)"Restart file is inconsistent!"
         WRITE(*,'(A, "is wrong")')dummyc
         WRITE(*,*)
         STOP 'Abnormal termination in bo_read_rest'
      END IF
      IF (natom .NE. N) THEN
         WRITE(*,*)
         WRITE(*,*)"number of atoms inconsistent in restart file"
         WRITE(*,*)
         STOP 'Abnormal termination in sub. bo_read_rest'
      END IF

C     Read coordinates
      READ(29,*)dummyc
      IF (dummyc .NE. "#coordinates") THEN
         WRITE(*,*)
         WRITE(*,*)"Restart file is inconsistent!"
         WRITE(*,'(A, "is wrong")')dummyc
         WRITE(*,*)
         STOP 'Abnormal termination in bo_read_rest'
      END IF
      DO i = 1, N
         READ(29,*)x(i),y(i),z(i)
      END DO

C     Read velocities
      READ(29,*)dummyc
      IF (dummyc .NE. "#velocity") THEN
         WRITE(*,*)
         WRITE(*,*)"Restart file is inconsistent!"
         WRITE(*,'(A, "is wrong")')dummyc
         WRITE(*,*)
         STOP 'Abnormal termination in bo_read_rest'
      END IF
      DO i = 1, N
         READ(29,*)vx(i),vy(i),vz(i)
      END DO

      CLOSE(UNIT=29)

C     Debug output
      IF (iout .GE. 3) THEN
         WRITE(*,*)
         WRITE(*,*)"Restart type: MD"
         WRITE(*,*)
         WRITE(*,'(" Number of restart atoms: ",I5)')natom

         WRITE(*,*)
         WRITE(*,*)"Restart coordinates [A]"
         WRITE(*,'("Atom",9X,"x",13X,"y",13X,"z")')
         DO i = 1, N
            WRITE(*,'(I3,2X,F12.5,2X,F12.5,2X,F12.5)')i,x(i),y(i),z(i)
         END DO

         WRITE(*,*)
         WRITE(*,*)"Restart velocities [A/ps]"
         WRITE(*,'("Atom",8X,"vx",12X,"vy",12X,"vz")')
         DO i = 1, N
           WRITE(*,'(I3,2X,F12.5,2X,F12.5,2X,F12.5)')i,vx(i),vy(i),vz(i)
         END DO

         WRITE(*,*)
         WRITE(*,*)"read_rest<<<"
         WRITE(*,*)
      END IF

      END SUBROUTINE
C======================================================================C

      SUBROUTINE bo_write_res(iout,rfile,N,x,y,z,vx,vy,vz)

C     This subroutine writes the restart file.

CTWK  Use format F20.10 to ensure better reproducibility.

      IMPLICIT NONE

C     INPUT VARIABLES
      INTEGER :: iout
      CHARACTER(20) :: rfile
      INTEGER :: N
      REAL*8, DIMENSION(N) :: vx,vy,vz
      REAL*8, DIMENSION(N) :: x,y,z

C     LOCAL VARIABLES
      INTEGER :: i,j,k
      INTEGER :: disk_error

C     Debug output.
      IF (iout .GE. 3) THEN
         WRITE(*,*)
         WRITE(*,*)">>>write_res"
      END IF

C     Open restart file.
      OPEN(UNIT=29,NAME=rfile,STATUS="REPLACE", ACTION="WRITE",
     &     IOSTAT=disk_error)
      IF (disk_error .NE. 0) THEN
         WRITE(*,*)
         WRITE(*,*)"Unknown disk error"
         WRITE(*,*)
         STOP 'Abnormal termination in sub. bo_write_res'
      END IF
      
C     Header. 
C     MD_only indicates that only coordinates and velocities are written.
      WRITE(29,'("#restart   MD_only")')

C     Number of atoms
      WRITE(29,'("#N_atoms ",I5)')N

C     Coordinates
      WRITE(29,'("#coordinates")')
      DO i = 1, N
         WRITE(29,'(3F20.10)')x(i),y(i),z(i)
      END DO

C     Velocities
      WRITE(29,'("#velocity")')
      DO i = 1, N
         WRITE(29,'(3F20.10)')vx(i),vy(i),vz(i)
      END DO

      CLOSE(UNIT=29)

C     Debug output.
      IF (iout .GE. 3) THEN
         WRITE(*,*)
         WRITE(*,*)"Restart type: MD"
         WRITE(*,*)
         WRITE(*,'(" Number of restart atoms: ",I5)')N

         WRITE(*,*)
         WRITE(*,*)"Restart coordinates [A]"
         WRITE(*,'("Atom",9X,"x",13X,"y",13X,"z")')
         DO i = 1, N
            WRITE(*,'(I3,2X,F12.5,2X,F12.5,2X,F12.5)')i,x(i),y(i),z(i)
         END DO
         WRITE(*,*)
         WRITE(*,*)"Restart velocities [A/ps]"
         WRITE(*,'("Atom",8X,"vx",12X,"vy",12X,"vz")')
         DO i = 1, N
           WRITE(*,'(I3,2X,F12.5,2X,F12.5,2X,F12.5)')i,vx(i),vy(i),vz(i)
         END DO
         WRITE(*,*)
         WRITE(*,*)"write_res<<<"
         WRITE(*,*)
       END IF

      END SUBROUTINE

C======================================================================C

      SUBROUTINE bo_vel_scal(iout,NUMAT,AMS,vx,vy,vz,Tfix,vs_Emax,nf)

C     This subroutine performs velocity scaling.
C     Velocities are scaled as follows:
C     (1) Compute kinetic energy corresponding to desired temperature Tfix
C     (2) Compute actual kinetic energy
C     (3) If requested an energy difference limit is requested:
C         (3.1) check if required energy correction is too large, if yes:
C         (3.1.1) change target temperature so that new kinetic energy will
C                 will differ from old one by the maximum ammount possible
C     (4) Get scaling factor conv = SQRT(Tfix/T) for desired temperature
C     (5) Comput new velocity v = conv*v

      IMPLICIT NONE

C     INPUT VARIABLES
      INTEGER :: iout
      INTEGER :: NUMAT
      REAL*8, DIMENSION(NUMAT) :: AMS
      REAL*8 :: Tfix
      REAL*8 :: vs_Emax
      INTEGER :: nf

C     INPUT/OUTPUT VARIABLES
      REAL*8, DIMENSION(NUMAT) :: vx,vy,vz

C     LOCAL VARIABLES
      REAL*8 :: KK
      REAL*8 :: K
      REAL*8 :: T_ist
      REAL*8 :: Tfix_old
      REAL*8 :: conv
      INTEGER :: i

C     PARAMETERS
      REAL*8, PARAMETER :: boltz=1.987168981D-3 ! Boltzmann constant 
                                                ! [kcal/(mol*K)]
C     Debug output.
      IF (iout .GE. 3) THEN
         WRITE(*,*)
         WRITE(*,*)">>>vel_scal"
      END IF
   
C     Step (1)
      KK = 0.5D0*Tfix*REAL(nf)*boltz

C     Step (2)
      CALL bo_Kene(iout,NUMAT,AMS,vx,vy,vz,K)
      CALL bo_Tist(iout,K,nf,T_ist)
     
C     Step (3)
      IF (vs_Emax .GE. 0.D0) THEN
C        Step (3.1)
         IF ((K-KK) .GT. vs_Emax) THEN
            Tfix_old = Tfix
            Tfix = (2.D0*(K-vs_Emax))/(nf*boltz)
            IF (iout .GE. 3) THEN
               WRITE(*,*)
               WRITE(*,*)"Change in energy required by velocity"
               WRITE(*,*)"scaling is larger than maximum allowed"
               WRITE(*,'("Temperature will be scaled to ",F10.5," K")')
     &                     Tfix
            END IF

         ELSE IF((KK-k) .GT. vs_Emax) THEN

            Tfix_old = Tfix
            Tfix = (2.D0*(K+vs_Emax))/(nf*boltz)
            IF (iout .GE. 3) THEN
               WRITE(*,*)
               WRITE(*,*)"Change in energy required by velocity"
               WRITE(*,*)"scaling is larger than maximum allowed"
               WRITE(*,'("Temperature will be scaled to ",F10.5," K")')
     &                     Tfix
            END IF
         END IF
      END IF

C     Step (4)
      conv = SQRT(Tfix/T_ist)

C     Step (5)
      vx = conv*vx
      vy = conv*vy
      vz = conv*vz

C     Debug output.
      IF (iout .GE. 3) THEN
         WRITE(*,*)
         WRITE(*,'("Fixed temperature = ",F10.5," K")')Tfix
         WRITE(*,'("Actual temperature = ",F10.5," K")')T_ist
         WRITE(*,'("Conversion factor = ",F10.5)')conv
         WRITE(*,*)"Scaled velocities [A/ps]"
         WRITE(*,'("Atom",8X,"vx",12X,"vy",12X,"vz")')
         DO i = 1, NUMAT
           WRITE(*,'(I3,2X,F12.5,2X,F12.5,2X,F12.5)')i,vx(i),vy(i),vz(i)
         END DO
         WRITE(*,*)
         WRITE(*,*)"vel_scal<<<"
         WRITE(*,*)
      END IF

C     Restore fixed temperature value.
      IF (vs_Emax .GE. 0.D0) THEN
         IF (ABS(K-KK) .GT. vs_Emax) THEN
            Tfix = Tfix_old
         END IF
      END IF

      END SUBROUTINE
