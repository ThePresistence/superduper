      SUBROUTINE BORDS1 (DS,PS,PNS,IDS,IPS,IPNS,JDS,JPS,JPNS,PL,N,
     +                   NITER,KEXT)
C     *
C     UPDATE OF DENSITY MATRIX.
C     OPTIONALLY COMBINED WITH EXTRAPOLATION OR DAMPING.
C     SPARSE ARRAYS IN CSR FORMAT, NO FILE HANDLING.
C     THE COLUMN INDICES OF THE SPARSE ARRAYS ARE IN ASCENDING ORDER.
C     *
C     NOTATION. I=INPUT, O=OUTPUT, S=SCRATCH.
C     DS(*)     DIFFERENCE DENSITY MATRIX (I,O).
C     PS(*)     DENSITY MATRIX: OLD (I), NEW (O).
C     PNS(*)    NEW DENSITY MATRIX (I).
C     IX(N+1)   POINTERS FOR SPARSE MATRICES IN CSR FORMAT (I).
C               X=DS,PS,PNS.
C     JX(*)     COLUMN INDICES FOR SPARSE MATRICES IN CSR FORMAT (I).
C               X=DS,PS,PNS.
C     PL        MAXIMUM CHANGE IN DIAGONAL ELEMENTS (O).
C     N         NUMBER OF BASIS FUNCTIONS (I).
C     NITER     NUMBER OF SCF ITERATION (I).
C     KEXT      TYPE OF SCF ITERATION (I,O).
C               =-1 CONVERGED DENSITY, NO MODIFICATION ALLOWED (I).
C               = 0 STANDARD CASE, NO EXTRAPOLATION OR DAMPING (O).
C               = 1 EXTRAPOLATION FOR DENSITY DONE (O).
C               = 2 DAMPING FOR DENSITY DONE (O).
C     *
C     COMMENTS ON OTHER AVAILABLE INPUT OPTIONS.
C     NSTEP .GT.0  -  ATTEMPT EXTRAPOLATION, IF CURRENTLY POSSIBLE.
C     NSTEP .LT.0  -  ATTEMPT DAMPING, IF CURRENTLY POSSIBLE.
C     NSTART.LT.0  -  NO EXTRAPOLATION OR DAMPING, PL STILL EVALUATED.
C     *
      USE module3
C     IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      IMPLICIT NONE
C
      INTERFACE
      SUBROUTINE MATDEVS (A,JA,IA,B,JB,IB,N,MODE,DEVMAX,DEVRMS)
      USE module3
      IMPLICIT NONE
      INTEGER :: N,MODE
      DOUBLE PRECISION :: DEVMAX,DEVRMS
      DOUBLE PRECISION, DIMENSION (:), POINTER :: B,A
      INTEGER, DIMENSION (:), POINTER :: JB,IB,JA,IA
      END SUBROUTINE MATDEVS
C
      DOUBLE PRECISION FUNCTION DDOTS2 (A,B,IIA,IIB,JJA,JJB,N,
     +                                  MODE1,MODE2)
      IMPLICIT NONE
      INTEGER :: N,MODE1,MODE2
      DOUBLE PRECISION, DIMENSION (:), POINTER :: A,B
      INTEGER, DIMENSION (:), POINTER :: IIA,JJA,IIB,JJB
      END FUNCTION DDOTS2
      END INTERFACE
C
      COMMON
     ./CONSTN/ ZERO,ONE,TWO,THREE,FOUR,PT5,PT25
     ./INOPT2/ IN2(300)
     ./NBFILE/ NBF(20)
      INTEGER          :: N,N4,NB6,II,NITER,NSTART,NSTEP,ie,NPRINT,
     +                    IN2,KEXT,NBF,N2,I
      DOUBLE PRECISION :: FAC,ONE,TWO,THREE,FOUR,PT5,PT25,DEN1,DEN2,
     +                    YLAMB,ZERO,YL,YCRIT,DEVRMS,PL,DDOTS1
      DOUBLE PRECISION, DIMENSION (:), POINTER :: PS,DS,PNS
      INTEGER,          DIMENSION (:), POINTER :: IPS,JPS,IDS,JDS,
     +                                 IPNS,JPNS
      INTEGER,          ALLOCATABLE :: IW(:)
C
      PARAMETER (YCRIT=0.06D0)
C
      SAVE YL
C *** INPUT OPTIONS.
      NPRINT = IN2(72)
      NSTART = IN2(78)
      NSTEP  = IN2(79)
C *** CALCULATE MAXIMUM CHANGE IN DIAGONAL MATRIX ELEMENTS.
C
      CALL MATDEVS (PNS,JPNS,IPNS,PS,JPS,IPS,N,1,PL,DEVRMS)
C     *
C *** SIMPLEST CASE: NO EXTRAPOLATION OR DAMPING.
C     *
C     COPY DENSITY MATRIX AND RETURN.
      IF(NSTART.LT.0 .OR. KEXT.LT.0) THEN
C
         N4=IPNS(N+1)-1
         IF (IPS(N+1)-1.LT.N4) THEN
            DEALLOCATE (PS,JPS,STAT=ie)
               IF (ie.NE.0) CALL XERALL (ie,'BORDS1','PS',N4,1)
            NULLIFY (PS,JPS)
            ALLOCATE (PS(N4),JPS(N4),STAT=ie)
               IF(ie.NE.0) CALL XERALL (ie,'BORDS1','DS',N4,0)
         ENDIF
C
         CALL copmatp (N,PNS,JPNS,IPNS,PS,JPS,IPS,1)
C
         RETURN
      ENDIF
C     *
C *** SECTION FOR EXTRAPOLATION OR DAMPING.
C     *
C *** INITIALIZATION.
      IF(NITER.EQ.1 .AND. NSTEP.GT.0) THEN
         YL     = ZERO
         YLAMB  = ZERO
         DEN1   = ZERO
         DEN2   = ZERO
      ENDIF
C     COMPUTE DOT PRODUCTS INVOLVING OLD DIFFERENCE DENSITY MATRIX.
      IF(NITER.GT.1 .AND. NSTEP.GT.0) THEN
C
         DEN1   = DDOTS1 (DS,IDS,JDS,N,1)
         YLAMB  = DDOTS2 (DS,PNS,IDS,IPNS,JDS,JPNS,N,1,1) - 
     +            DDOTS2 (DS,PS,IDS,IPS,JDS,JPS,N,1,1)
C
         DEALLOCATE (DS,JDS,IDS,STAT=ie)
            IF (ie.NE.0) CALL XERALL (ie,'BORDS1','DS',N4,0)
         NULLIFY (DS,JDS,IDS)
      ENDIF
C *** COMPUTE NEW DIFFERENCE DENSITY MATRIX D(LM2,LM3).
C
      ALLOCATE (IW(N),STAT=ie)
         IF(ie.NE.0) CALL XERALL (ie,'BORDS1','IW',N,0)
C
      CALL aplbdgp (N,JPS,IPS,JPNS,IPNS,N4,IW)
C
      ALLOCATE (DS(N4),JDS(N4),IDS(N+1),STAT=ie)
         IF(ie.NE.0) CALL XERALL (ie,'BORDS1','DS',N4,0)
C
      N2=IPS(N+1)-1
      DO 14 I=1,N2
      PS(I) = -PS(I)
 14   CONTINUE
      CALL aplbp (N,PNS,JPNS,IPNS,PS,JPS,IPS,DS,JDS,IDS,N4,IW,ie)
         IF(IE.NE.0) CALL XERSPA (IE,'aplb','BORDS1',1)
C
      DEALLOCATE (IW,STAT=ie)
         IF(ie.NE.0) CALL XERALL (ie,'BORDS1','IW',N,1)
C
C     DEBUG PRINT.
      IF(NPRINT.GE.9) THEN
         NB6 = NBF(6)
         WRITE(NB6,500) NITER
         PS(1:N2) = -PS(1:N2)
         CALL SPAPRT (PS,IPS,JPS,N)
         WRITE(NB6,510) NITER
         CALL SPAPRT (PNS,IPNS,JPNS,N)
         IF(NITER.GT.1) THEN
            WRITE(NB6,520) NITER
            CALL SPAPRT (DS,IDS,JDS,N)
         ENDIF
      ENDIF
C *** EXTRAPOLATION.
      KEXT   = 0
      IF(NSTEP.GT.0) THEN
         FAC    = ONE
         DEN2   = DDOTS1 (DS,IDS,JDS,N,1)
         IF(NITER.GE.NSTART) THEN
            II  = NITER-NSTART
            II  = II-(II/NSTEP)*NSTEP
            IF(II.EQ.0) KEXT=1
         ENDIF
         IF(NITER.LT.2 .OR. DEN1.EQ.ZERO .OR .DEN2.EQ.ZERO) THEN
            KEXT = 0
         ELSE
            YLAMB = YLAMB/DEN1
            IF(ABS(YLAMB).GE.ONE) YLAMB=YLAMB*DEN1/DEN2
            IF(ABS(YLAMB-YL).GT.YCRIT) KEXT=0
            IF(YLAMB.EQ.ONE) KEXT=0
            YL = YLAMB
         ENDIF
         IF(KEXT.EQ.1) FAC = ONE/(ONE-YLAMB)-ONE
C *** DAMPING.
      ELSE IF(NSTEP.LT.0) THEN
         IF(NITER.GE.NSTART .AND. NITER.GT.1) THEN
            KEXT = 2
            FAC  = DBLE(MIN(-NSTEP,9))/10.0D0
         ENDIF
      ENDIF
C *** UPDATE OF DENSITY MATRIX.
      IF (KEXT.GT.0) THEN
C
         ALLOCATE (IW(N),STAT=ie)
            IF(ie.NE.0) CALL XERALL (ie,'BORDS1','IW',N,0)
C
         CALL aplbdgp (N,JDS,IDS,JPNS,IPNS,N4,IW)
C
         IF (IPS(N+1)-1.LT.N4) THEN
            DEALLOCATE (PS,JPS,STAT=ie)
               IF (ie.NE.0) CALL XERALL (ie,'BORDS1','PS',N4,1)
            NULLIFY (PS,JPS)
            ALLOCATE (PS(N4),JPS(N4),STAT=ie)
               IF(ie.NE.0) CALL XERALL (ie,'BORDS1','PS',N4,0)
         ENDIF
C
         N2=IDS(N+1)-1
         DO 16 I=1,N2
         DS(I) = FAC*DS(I)
 16      CONTINUE
         CALL aplbp (N,PNS,JPNS,IPNS,DS,JDS,IDS,PS,JPS,IPS,N4,IW,ie)
            IF(IE.NE.0) CALL XERSPA (IE,'aplb','BORDS1',1)
         DO 26 I=1,N2
         DS(I) = DS(I)/FAC
 26      CONTINUE
C
         DEALLOCATE (IW,STAT=ie)
            IF(ie.NE.0) CALL XERALL (ie,'BORDS1','IW',N,1)
      ELSE
         N4=IPNS(N+1)-1
         IF (IPS(N+1)-1.LT.N4) THEN
            DEALLOCATE (PS,JPS,STAT=ie)
               IF (ie.NE.0) CALL XERALL (ie,'BORDS1','PS',N4,1)
            NULLIFY (PS,JPS)
            ALLOCATE (PS(N4),JPS(N4),STAT=ie)
               IF(ie.NE.0) CALL XERALL (ie,'BORDS1','PS',N4,0)
         ENDIF
         CALL copmatp (N,PNS,JPNS,IPNS,PS,JPS,IPS,1)
      ENDIF
C *** DEBUG PRINT.
      IF(NPRINT.GE.5) THEN
         NB6 = NBF(6)
         WRITE(NB6,530)
         WRITE(NB6,540) NITER,KEXT,YL,YLAMB,DEN1,DEN2,FAC
         IF(NPRINT.GE.9 .AND. KEXT.GT.0) THEN
            WRITE(NB6,550) NITER,FAC
C           CALL SPAPRT (PS,IPS,JPS,N)
         ENDIF
      ENDIF
C
      IF (ALLOCATED(IW)) THEN
         DEALLOCATE (IW,STAT=ie)
            IF (ie.NE.0) CALL XERALL (ie,'BORDS1','IW',N,1)
      ENDIF
C
      RETURN
  500 FORMAT(// 1X,'BORDS1: OLD DENSITY MATRIX, NITER =',I3/)
  510 FORMAT(// 1X,'BORDS1: NEW DENSITY MATRIX, NITER =',I3/)
  520 FORMAT(// 1X,'BORDS1: DIFFERENCE DENSITY MATRIX, NITER =',I3/)
  530 FORMAT(// 1X,'BORDS1: NITER,KEXT,YL,YLAMB,DEN1,DEN2,FAC')
  540 FORMAT(   1X,'BORDS1: ',I5,I3,5G15.5)
  550 FORMAT(// 1X,'BORDS1: MODIFIED DENSITY MATRIX, NITER =',I3,
     1          5X,'FAC =',F10.5/)
      END
