MODULE NACCSF

PRIVATE

INTEGER :: NUMAT, NUMALL
INTEGER :: NORBS
INTEGER :: NB6
INTEGER :: MPRINT
INTEGER :: IAPP

REAL*8  :: DSTEP, FACTOR
REAL*8, ALLOCATABLE :: COORD0(:,:)

LOGICAL :: DEBUG, NOTOMI

PUBLIC  :: NAC_OVLP

CONTAINS
 
!
!**********************
!
SUBROUTINE NACCSF_INIT
  USE LIMIT, ONLY: LM1, LMX, LM1M, LMACT
  IMPLICIT REAL*8 (A-H,O-Z)
  COMMON /ATOMC / COORD(3,LM1)
  COMMON /ATOMS / NATOMS,NAT(LM1),NFIRST(LM1),NLAST(LM1)
  COMMON /CIMOS / IMOCI(LMX)
  COMMON /GUGA1 / NCIO,NCIGAM
  COMMON /HALFE / IODD,JODD
  COMMON /INOPT2/ IN2(300)
  COMMON /NBFILE/ NBF(20)
  COMMON /ORBITS/ NUMB,NORB,NMOS,NALPHA,NBETA
  COMMON /PSDOPT/ DSTORE,DDSTEP,RPSOPT(3:10),IPSOPT(28)
  COMMON /QMMM1 / COORDM(3,LM1M),CHARGM(LM1M)
  COMMON /QMMM6 / ISELCT(LM1+LM1M)

  NB6    = NBF(6)
  
  NUMAT  = NATOMS
  NUMATM = IN2(120)
  NUMALL = NUMAT + NUMATM
  
  DSTEP  = DDSTEP
  IF(DSTEP.EQ.0.D0)  DSTEP = 2.D-4

  ALLOCATE(COORD0(3,NUMAT))
  COORD0(1:3,1:NUMAT) = COORD(1:3,1:NUMAT)

  NORBS  = NORB

  DEBUG  = .FALSE.

  MPRINT = IN2( 41)

  FACTOR = 0.5D0 / DSTEP

  IAPP   = IN2(145)

  IOP    = IN2(2)
  NOTOMI = IOP.NE.-5 .AND. IOP.NE.-6 .AND. IOP.NE.-8 .AND. IOP.NE.-9 .AND. IOP.NE.-22 .AND. IOP.NE.-23

  RETURN
END SUBROUTINE NACCSF_INIT

!
!**********************
!
SUBROUTINE NACCSF_EXIT

  DEALLOCATE(COORD0)

END SUBROUTINE NACCSF_EXIT

!
!**********************
!
SUBROUTINE NAC_OVLP(ONEDEN,CG,CC,DELTAE,LDA,NATOMS)
  IMPLICIT NONE
  INTEGER  :: LDA, NATOMS
  REAL*8   :: DELTAE
  REAL*8   :: ONEDEN(LDA,LDA), CG(3,NATOMS), CC(3,NATOMS)
  
  CALL NACCSF_INIT

  IF(IAPP.NE.0) THEN
     CALL NACCSF_FD(ONEDEN,CG,CC,DELTAE,LDA)
  ELSE
     CALL NACCSF_APPROX(ONEDEN,CG,CC,DELTAE,LDA)
  ENDIF

  CALL NACCSF_EXIT

  RETURN
END SUBROUTINE NAC_OVLP
  
!
!Explicit finite-difference method
!
SUBROUTINE NACCSF_FD(ONEDEN,CG,CC,DELTAE,LM3)
  !(PARTIALLY) ANALYTICAL EVALUATION OF THE SECOND TERM (MO COEFFICIENT
  !AND AO DERIVATIVES) FOR NON-ADIABATIC COUPLING ELEMENTS.
  !ARGUMENTS:
  !  ONEDEN: ONE-PARTICLE TRANSITION DENSITY MATRIX (I).
  !  ARRAY:  UNNAMED COMMON (I,O,S).
  !  CG:     FIRST TERM OF THE COUPLING WITHOUT ENERGY DENOMINATOR,
  !          KCAL/(MOL*ANG) (I).
  !  CC:     FULL NON-ADIABATIC COUPLING VECTOR, 1/ANG (O).
  !  DELTAE: ENERGY DIFFERENCE OF STATES INVOLVED, KCAL/MOL (I).
  IMPLICIT NONE
  INTEGER  :: IA, IC, I, J, LM3
  REAL*8   :: DELTAE, tmp, Q0
  REAL*8   :: ONEDEN(LM3,LM3)
  REAL*8   :: CG(3,NUMAT)
  REAL*8   :: CC(3,NUMAT)
  REAL*8, ALLOCATABLE :: SMIPT5(:,:), SPLPT5(:,:), SMI1(:,:), SMI2(:,:)
  REAL*8, ALLOCATABLE :: CORSAV(:,:), TEMP(:,:)
  REAL*8, ALLOCATABLE :: DSMI(:,:), SIGMA(:,:)
  REAL*8, ALLOCATABLE :: TERM1(:,:), TERM2B(:,:), SUM12A(:,:)
  
  ALLOCATE(CORSAV(3,NUMAT))
  ALLOCATE(SMIPT5(NORBS,NORBS))
  ALLOCATE(SPLPT5(NORBS,NORBS))
  ALLOCATE(SMI1(NORBS,NORBS))
  ALLOCATE(SMI2(NORBS,NORBS))
  ALLOCATE(DSMI(NORBS,NORBS))
  ALLOCATE(SIGMA(NORBS,NORBS))
  ALLOCATE(TEMP(NORBS,NORBS))
  ALLOCATE(TERM1(3,NUMALL))
  ALLOCATE(SUM12A(3,NUMALL))
  ALLOCATE(TERM2B(3,NUMALL))
  CORSAV(1:3,1:NUMAT) = COORD0(1:3,1:NUMAT)
  
  !DEBUG PRINT.
  IF(DEBUG) THEN
     WRITE(NB6,'(///1X,"CARTESIAN COORDINATES (ORIGINAL VALUES)."/)')
     CALL PRTCOR(CORSAV(:,1:NUMAT))
   WRITE(NB6,'(///1X,"ONE-PARTICLE TRANSITION DENSITY MATRIX.")')
   CALL PRTMAT(ONEDEN(1:LM3,1:LM3))
  ENDIF
  
  !POWERS OF OVERLAP MATRIX.
  !FORM S**(-1/2) MATRIX.
  CALL SMICAL(SMIPT5,SIGMA,CORSAV,NORBS,DEBUG,0)
  !FORM S**(+1/2) MATRIX.
  CALL SPLCAL(SPLPT5,SIGMA,CORSAV,NORBS,DEBUG,0)
  
  !CONTRIBUTIONS FROM THE VARIATION OF THE POSITIONS OF THE QM ATOMS.
  
  DO IA=1,NUMAT
     DO IC=1,3
        IF(DEBUG) THEN
           WRITE(NB6,'(///1X,"ATOM",I4,", DIRECTION",I2,".")') IA,IC
        ENDIF
        Q0            = COORD0(IC,IA)
        COORD0(IC,IA) = Q0 + DSTEP
        IF(DEBUG) THEN
          WRITE(NB6,'(///1X,"CARTESIAN COORDINATES (POSITIVE SHIFT)."/)')
          CALL PRTCOR(COORD0(:,1:NUMAT))
        ENDIF
        CALL SMICAL(SMI1,SIGMA,COORD0,NORBS,DEBUG,0)
        COORD0(IC,IA) = Q0 - DSTEP
        IF(DEBUG) THEN
           WRITE(NB6,'(///1X,"CARTESIAN COORDINATES (NEGATIVE SHIFT)."/)')
           CALL PRTCOR(COORD0(:,1:NUMAT))
        ENDIF
        CALL SMICAL(SMI2,SIGMA,COORD0,NORBS,DEBUG,0)
        COORD0(IC,IA) = Q0

        DSMI(:,:) = FACTOR * (SMI1(:,:) - SMI2(:,:))
        IF(DEBUG) THEN
           WRITE(NB6,'(///1X,"S**(-1/2) MATRIX DERIVATIVE.")')
           CALL PRTMAT(DSMI)
        ENDIF
  
        !DIVIDE BY ENERGY DIFFERENCE.
        TERM1(IC,IA)  = CG(IC,IA) / DELTAE
        SUM12A(IC,IA) = TERM1(IC,IA) 
  
        !FORM SIGMA MATRIX IN NON-ORTHOGONAL AO BASIS.
        CALL SIGNUM(CORSAV,COORD0,SIGMA,IA,IC)
        IF(DEBUG) THEN
           WRITE(NB6,'(///1X,"AO BASIS SIGMA MATRIX.")')
           CALL PRTMAT(SIGMA)
        ENDIF
        !TRANSFORM SIGMA MATRIX INTO ORTHOGONAL AO BASIS.
        !TEMP = SMIPT5 * SIGMA.
        CALL DGEMM('N','N',NORBS,NORBS,NORBS,1.D0,SMIPT5(1,1),NORBS,SIGMA(1,1),NORBS,0.D0,TEMP(1,1),NORBS)
        !SIGMA = TEMP * SMIPT5.
        CALL DGEMM('N','N',NORBS,NORBS,NORBS,1.D0,TEMP(1,1), NORBS,SMIPT5(1,1),NORBS,0.D0,SIGMA(1,1),NORBS)
        IF(DEBUG) THEN
           WRITE(NB6,'(///1X,"ORTHOGONAL AO BASIS SIGMA MATRIX.")')
           CALL PRTMAT(SIGMA)
        ENDIF
        !FORM SIGMA = SIGMA + SPLPT5 * DSMI.
        CALL DGEMM('N','N',NORBS,NORBS,NORBS,1.D0,SPLPT5(1,1),NORBS,DSMI(1,1),NORBS,1.D0,SIGMA(1,1),NORBS)
        IF(DEBUG) THEN
           WRITE(NB6,'(///1X,"ANTISYMMETRIC AO BASIS SIGMA MATRIX.")')
           CALL PRTMAT(SIGMA)
        ENDIF
     
        TMP = 0.D0
        DO I=1,LM3
           DO J=1,LM3
              TMP = TMP + ONEDEN(I,J) * 0.5D0 * (SIGMA(I,J) - SIGMA(J,I))
         END DO
        END DO
        TERM2B(IC,IA) = TMP
        CC    (IC,IA) = SUM12A(IC,IA) + TMP
     END DO
  END DO
  
  IF(MPRINT.GT.0) THEN
     WRITE(NB6,'(///1X,"NON-ADIABATIC COUPLING MATRIX ELEMENTS.")')
     WRITE(NB6,'(/1X,"FIRST TERM."/)')
     CALL PRTCOR(TERM1 (:,1:NUMALL))
     WRITE(NB6,'(/1X,"SECOND TERM, SECOND PART."/)')
     CALL PRTCOR(TERM2B(:,1:NUMALL))
     WRITE(NB6,'(/1X,"COMPLETE EXPRESSION."/)')
     CALL PRTCOR(CC(:,1:NUMALL))
     WRITE(NB6,'(//)')
  END IF
  !DEALLOCATE TEMPORARY STORAGE.
  DEALLOCATE (TERM2B)
  DEALLOCATE (SUM12A)
  DEALLOCATE (TERM1)
  DEALLOCATE (TEMP)
  DEALLOCATE (SIGMA)
  DEALLOCATE (DSMI)
  DEALLOCATE (SPLPT5)
  DEALLOCATE (SMIPT5)
  DEALLOCATE (SMI1)
  DEALLOCATE (SMI2)
  DEALLOCATE (CORSAV)
  RETURN
END SUBROUTINE NACCSF_FD
  
!
! Approximate finite-difference method
!  
SUBROUTINE NACCSF_APPROX(ONEDEN,CG,CC,DELTAE,LM3)
  !(PARTIALLY) ANALYTICAL EVALUATION OF THE SECOND TERM (MO COEFFICIENT
  !AND AO DERIVATIVES) FOR NON-ADIABATIC COUPLING ELEMENTS.
  !ARGUMENTS:
  !ONEDEN: ONE-PARTICLE TRANSITION DENSITY MATRIX (I).
  !ARRAY:  UNNAMED COMMON (I,O,S).
  !CG:     FIRST TERM OF THE COUPLING WITHOUT ENERGY DENOMINATOR,
  !        KCAL/(MOL*ANG) (I).
  !CC:     FULL NON-ADIABATIC COUPLING VECTOR, 1/ANG (O).
  !DELTAE: ENERGY DIFFERENCE OF STATES INVOLVED, KCAL/MOL (I).
  IMPLICIT NONE
  INTEGER  :: IA, IC, I, J, LM3
  REAL*8   :: DELTAE, tmp
  REAL*8   :: ONEDEN(LM3,LM3)
  REAL*8   :: CG(3,NUMAT)
  REAL*8   :: CC(3,NUMAT)
  REAL*8, ALLOCATABLE :: SMIPT5(:,:), SPLPT5(:,:), SMIPT25(:,:), SPLPT25(:,:)
  REAL*8, ALLOCATABLE :: CORSAV(:,:), TEMP(:,:)
  REAL*8, ALLOCATABLE :: DSMI(:,:), SIGMA(:,:)
  REAL*8, ALLOCATABLE :: TERM1(:,:), TERM2B(:,:), SUM12A(:,:)
  
  !MEMORY ALLOCATION
  ALLOCATE(CORSAV(3,NUMAT))
  ALLOCATE(SMIPT5(NORBS,NORBS))
  ALLOCATE(SPLPT5(NORBS,NORBS))
  ALLOCATE(SMIPT25(NORBS,NORBS))
  ALLOCATE(SPLPT25(NORBS,NORBS))
  ALLOCATE(DSMI(NORBS,NORBS))
  ALLOCATE(SIGMA(NORBS,NORBS))
  ALLOCATE(TEMP(NORBS,NORBS))
  ALLOCATE(TERM1(3,NUMALL))
  ALLOCATE(TERM2B(3,NUMALL))
  
  CORSAV(1:3,1:NUMAT) = COORD0(1:3,1:NUMAT)
  !FORM S**(-1/2) AND S**(-1/4) MATRIX.
  CALL SMICAL(SMIPT5,SMIPT25,CORSAV,NORBS,DEBUG,1)
  !FORM S**(+1/2) AND S**(+1/4) MATRIX.
  CALL SPLCAL(SPLPT5,SPLPT25,CORSAV,NORBS,DEBUG,1)
  
  !CONTRIBUTIONS FROM THE VARIATION OF THE POSITIONS OF THE QM ATOMS.
  
  DO IA=1,NUMAT
     DO IC=1,3
        IF(DEBUG) THEN
           WRITE(NB6,'(///1X,"ATOM",I4,", DIRECTION",I2,".")') IA,IC
        ENDIF
        !DIVIDE BY ENERGY DIFFERENCE.
        TERM1(IC,IA) = CG(IC,IA) / DELTAE
  
        !<\mu|\nu^x>
        CALL SIGNUM(CORSAV,COORD0,SIGMA,IA,IC)
        !-1/2*<\mu|\nu>^x
        DO I=1,LM3
           DO J=1,LM3
              DSMI(I,J) = -0.5d0*(SIGMA(I,J)+SIGMA(J,I))
           ENDDO
        ENDDO
        !\sigma = -1/2*S^(1/4)*<\mu|\nu>^x*S^(-1/4) + <\mu|\nu^x>
        CALL DGEMM('N','N',NORBS,NORBS,NORBS,1.D0,SPLPT25(1,1),NORBS,DSMI(1,1),NORBS,0.D0,TEMP(1,1),NORBS)
        CALL DGEMM('N','N',NORBS,NORBS,NORBS,1.D0,TEMP(1,1),NORBS,SMIPT25(1,1),NORBS,1.D0,SIGMA(1,1),NORBS)
        !S^(-1/2) * \sigma * S^(-1/2)
        CALL DGEMM('N','N',NORBS,NORBS,NORBS,1.D0,SMIPT5(1,1),NORBS,SIGMA(1,1),NORBS,0.D0,TEMP(1,1),NORBS)
        CALL DGEMM('N','N',NORBS,NORBS,NORBS,1.D0,TEMP(1,1),NORBS,SMIPT5(1,1),NORBS,0.D0,SIGMA(1,1),NORBS)

        TMP = 0.D0
        DO I=1,LM3
           DO J=1,LM3
              TMP = TMP + ONEDEN(I,J) * SIGMA(I,J) 
           END DO
        END DO
        TERM2B(IC,IA) = TMP
        CC    (IC,IA) = TERM1(IC,IA) + TMP
     END DO
  END DO
  
  IF(MPRINT.GT.0) THEN
     WRITE(NB6,'(///1X,"NON-ADIABATIC COUPLING MATRIX ELEMENTS.")')
     WRITE(NB6,'(/1X,"FIRST TERM."/)')
     CALL PRTCOR(TERM1 (:,1:NUMALL))
     WRITE(NB6,'(/1X,"SECOND TERM."/)')
     CALL PRTCOR(TERM2B(:,1:NUMALL))
     WRITE(NB6,'(/1X,"COMPLETE EXPRESSION."/)')
     CALL PRTCOR(CC(:,1:NUMALL))
     WRITE(NB6,'(//)')
  END IF
  !DEALLOCATE TEMPORARY STORAGE.
  DEALLOCATE (TERM2B)
  DEALLOCATE (TERM1)
  DEALLOCATE (TEMP)
  DEALLOCATE (SIGMA)
  DEALLOCATE (DSMI)
  DEALLOCATE (SPLPT5)
  DEALLOCATE (SMIPT5)
  DEALLOCATE (SPLPT25)
  DEALLOCATE (SMIPT25)
  DEALLOCATE (CORSAV)
  RETURN
END SUBROUTINE NACCSF_APPROX
  
!
! S^(-1/2) and S^(-1/4)
!  
SUBROUTINE SMICAL(SMIPT5,SMIPT25,COORD,NORBS,DEBUG,I14)
  USE LIMIT, ONLY: LM1
  IMPLICIT NONE
  REAL*8, DIMENSION(:,:) :: SMIPT5, SMIPT25, COORD
  INTEGER                :: NORBS, I14
  LOGICAL                :: DEBUG
  REAL*8, ALLOCATABLE    :: OVER(:,:)
  REAL*8, ALLOCATABLE    :: SEIGEN(:), SEIGEN2(:)
  REAL*8                 :: SUM0
  REAL*8, ALLOCATABLE    :: WORK(:)
  INTEGER                :: LWORK, INFO, I, J, K

  ALLOCATE(OVER(NORBS,NORBS))
  ALLOCATE(SEIGEN(NORBS))

  !FORM OVERLAP MATRIX.
  CALL OVRMAT(OVER,COORD)
  IF(DEBUG) THEN
     WRITE(NB6,'(///1X,"OVERLAP MATRIX.")')
     CALL PRTMAT(OVER)
  ENDIF
  !DIAGONALIZE OVERLAP MATRIX.
  LWORK = 3 * NORBS - 1
  ALLOCATE(WORK(LWORK))
  CALL DSYEV('V','U',NORBS,OVER(1,1),NORBS,SEIGEN(1),WORK(1),LWORK,INFO)
  IF(INFO.NE.0) THEN
     WRITE(NB6,'(1X,"DIAGONALIZATION FAILED WITH INFO=",I4)') INFO
     STOP 'SMICAL'
  END IF
  DEALLOCATE(WORK)

  !FORM SEIGEN**(-1/2).
  SEIGEN(:) = 1.0D0 / SQRT(SEIGEN(:))
  !FORM S**(-1/2).
  DO I=1,NORBS
     DO J=1,NORBS
        SUM0 = 0.D0
        DO K=1,NORBS
           SUM0  = SUM0  + OVER(I,K) * OVER(J,K) * SEIGEN(K)
        END DO
        SMIPT5(I,J)  = SUM0
     END DO
  END DO

  IF(I14.EQ.1) THEN
     ALLOCATE(SEIGEN2(NORBS))
     SEIGEN2(:) = SQRT(SEIGEN(:))
     !FORM S**(-1/4).
     DO I=1,NORBS
        DO J=1,NORBS
           SUM0 = 0.D0
           DO K=1,NORBS
              SUM0  = SUM0  + OVER(I,K) * OVER(J,K) * SEIGEN2(K)
           END DO
           SMIPT25(I,J) = SUM0
        END DO
     END DO
     DEALLOCATE(SEIGEN2)
  ENDIF

  IF(DEBUG) THEN
     WRITE(NB6,'(///1X,"S**(-1/2) MATRIX.")')
     CALL PRTMAT(SMIPT5)
  ENDIF
 
  DEALLOCATE(OVER)
  DEALLOCATE(SEIGEN)
END SUBROUTINE SMICAL
  
!
! S^(1/2) and S^(1/4)
!  
SUBROUTINE SPLCAL(SPLPT5,SPLPT25,COORD,NORBS,DEBUG,I14)
  USE LIMIT, ONLY: LM1
  IMPLICIT NONE
  REAL*8, DIMENSION(:,:) :: SPLPT5, SPLPT25, COORD
  INTEGER                :: NORBS, I14
  LOGICAL                :: DEBUG
  REAL*8, ALLOCATABLE    :: OVER(:,:)
  REAL*8, ALLOCATABLE    :: SEIGEN(:), SEIGEN2(:)
  REAL*8                 :: SUM0
  REAL*8, ALLOCATABLE    :: WORK(:)
  INTEGER                :: LWORK, INFO, I, J, K

  ALLOCATE(OVER(NORBS,NORBS))
  ALLOCATE(SEIGEN(NORBS))

  !FORM OVERLAP MATRIX.
  CALL OVRMAT(OVER,COORD)
  IF(DEBUG) THEN
     WRITE(NB6,'(///1X,"OVERLAP MATRIX.")')
     CALL PRTMAT(OVER)
  ENDIF
  !DIAGONALIZE OVERLAP MATRIX.
  LWORK = 3 * NORBS - 1
  ALLOCATE(WORK(LWORK))
  CALL DSYEV('V','U',NORBS,OVER(1,1),NORBS,SEIGEN(1),WORK(1),LWORK,INFO)
  IF(INFO.NE.0) THEN
     WRITE(NB6,'(1X,"DIAGONALIZATION FAILED WITH INFO=",I4)') INFO
     STOP 'SPLCAL'
  END IF
  DEALLOCATE(WORK)

  !FORM SEIGEN**(+1/2).
  SEIGEN(:)  = SQRT(SEIGEN(:))
  !FORM S**(+1/2).
  DO I=1,NORBS
     DO J=1,NORBS
        SUM0  = 0.D0
        DO K=1,NORBS
           SUM0  = SUM0  + OVER(I,K) * OVER(J,K) * SEIGEN(K)
        END DO
        SPLPT5(I,J)  = SUM0
     END DO
  END DO

  IF(I14.EQ.1) THEN
     ALLOCATE(SEIGEN2(NORBS))
     SEIGEN2(:) = SQRT(SEIGEN(:))
     !FORM S**(+1/4).
     DO I=1,NORBS
        DO J=1,NORBS
           SUM0  = 0.D0
           DO K=1,NORBS
              SUM0 = SUM0 + OVER(I,K) * OVER(J,K) * SEIGEN2(K)
           END DO
           SPLPT25(I,J) = SUM0
        END DO
     END DO
     DEALLOCATE(SEIGEN2)
  ENDIF

  IF(DEBUG) THEN
     WRITE(NB6,'(///1X,"S**(+1/2) MATRIX.")')
     CALL PRTMAT(SPLPT5)
  ENDIF

  DEALLOCATE(OVER)
  DEALLOCATE(SEIGEN)
END SUBROUTINE SPLCAL
  
!
! < mu | \nu^x >
!
SUBROUTINE SIGNUM(CORSAV,COORD,SIGAO,IB,IXYZ)
  USE LIMIT, ONLY: LM1
  IMPLICIT NONE
  COMMON /ATOMS / NATOMS,NAT(LM1),NFIRST(LM1),NLAST(LM1)
  REAL*8, DIMENSION(:,:) :: CORSAV, COORD, SIGAO
  INTEGER                :: IB, IXYZ
  REAL*8, DIMENSION(9,9) :: OVER1, OVER2
  REAL*8                 :: Q0, FAC
  INTEGER                :: NATOMS, NAT, NFIRST, NLAST
  INTEGER                :: NORBSA, NORBSB, IA

  SIGAO(:,:) = 0.0D0
  NORBSB     = NLAST(IB) - NFIRST(IB) + 1
  FAC        = 0.5D0 / DSTEP
  Q0         = COORD(IXYZ,IB)
  DO IA=1,NATOMS
     NORBSA = NLAST(IA) - NFIRST(IA) + 1
     COORD(IXYZ,IB) = Q0 + DSTEP
     CALL OVRBLK(OVER1, CORSAV(:,IA), COORD(:,IB), IA, IB)
     COORD(IXYZ,IB) = Q0 - DSTEP
     CALL OVRBLK(OVER2, CORSAV(:,IA), COORD(:,IB), IA, IB)
     SIGAO(NFIRST(IA):NLAST(IA), NFIRST(IB):NLAST(IB)) = (OVER1(1:NORBSA, 1:NORBSB)-OVER2(1:NORBSA, 1:NORBSB)) * FAC
  END DO
  COORD(IXYZ,IB) = Q0
END SUBROUTINE SIGNUM
  
!
! overlap matrix
!  
SUBROUTINE OVRMAT(OVER,COORD)
  USE LIMIT, ONLY: LM1
  IMPLICIT NONE
  COMMON /ATOMS / NATOMS,NAT(LM1),NFIRST(LM1),NLAST(LM1)
  REAL*8, DIMENSION(:,:) :: OVER, COORD
  INTEGER                :: NATOMS, NAT, NFIRST, NLAST
  INTEGER                :: IA, IB
  DO IA=1,NATOMS
   DO IB=1,NATOMS
      CALL OVRBLK(OVER(NFIRST(IA):NLAST(IA),NFIRST(IB):NLAST(IB)),COORD(:,IA),COORD(:,IB),IA,IB)
   END DO
  END DO
END SUBROUTINE OVRMAT
  
  
SUBROUTINE OVRBLK(OVER,CORA,CORB,IA,IB)
  REAL*8, DIMENSION(1:,1:) :: OVER
  REAL*8, DIMENSION(3)     :: CORA, CORB
  INTEGER                  :: IA, IB
  
  IF(.FALSE.) THEN
    CALL OVRBLK2(OVER,CORA,CORB,IA,IB)
  ELSE
    CALL OVRBLK3(OVER,CORA,CORB,IA,IB)
  ENDIF
END SUBROUTINE OVRBLK
  

SUBROUTINE OVRBLK2(OVER,CORA,CORB,IA,IB)
  USE CONST, ONLY: OLDCF, A0
  USE LIMIT, ONLY: LM1, LMGS, LMGP
  IMPLICIT NONE
  COMMON /ATOMS / NATOMS,NAT(LM1),NFIRST(LM1),NLAST(LM1)
  COMMON /GAUSS1/ KSTART(LMGS),KNG(LMGS),KTYPE(LMGS),NSHELL,NPRIM
  COMMON /GAUSSP/ EXX(LMGP),DS(LMGP),DP(LMGP),DD(LMGP)
  !COMMON BLOCK GAUSS1: INFORMATION ABOUT GAUSSIAN SHELLS.
  !KSTART(I)  INDEX OF FIRST GAUSSIAN PRIMITIVE OF SHELL I.
  !KNG(I)     NUMBER OF GAUSSIAN PRIMITIVES IN SHELL I.
  !KTYPE(I)   TYPE OF SHELL I.
  !NSHELL     TOTAL NUMBER OF GAUSSIAN SHELLS.
  !NPRIM      TOTAL NUMBER OF PRIMITIVES.
  !COMMON BLOCK GAUSSP: INFORMATION ABOUT GAUSSIAN PRIMITIVES.
  !SHARED EXPONENTS AND S, P, D CONTRACTION COEFFICIENTS.
  REAL*8, DIMENSION(1:,1:) :: OVER
  REAL*8, DIMENSION(3)     :: CORA, CORB
  INTEGER                  :: IA, IB
  INTEGER                  :: NATOMS, NAT, NFIRST, NLAST
  INTEGER                  :: KSTART, KNG, KTYPE
  INTEGER                  :: NSHELL, NPRIM
  REAL*8                   :: EXX, DS, DP, DD
  REAL*8, DIMENSION(4,4)   :: PRIM
  REAL*8, DIMENSION(3)     :: DIST
  INTEGER                  :: NORBSA, NORBSB
  INTEGER                  :: I, J, K, L, KA, KB
  REAL*8                   :: AL, AL05, AL15
  REAL*8                   :: BE, BE05, BE15
  REAL*8                   :: REZI, REZI05, REZI15
  REAL*8                   :: REZI20, REZI25
  REAL*8                   :: DISTSQ, FEXP, DPROD
  
  !DESCRIPTION OF THE PARAMETERS:
  !  OVER    BLOCK OF OVERLAP INTEGRALS BETWEEN
  !          BASIS FUNCTIONS ON ATOM A AND ATOM B.
  !  CORA    CARTESIAN COORDINATES OF ATOM A.
  !  CORB    CARTESIAN COORDINATES OF ATOM B.
  !  IA      INDEX OF ATOM A IN THE LIST OF ATOMS.
  !  IB      INDEX OF ATOM B IN THE LIST OF ATOMS.
  
  !LOCAL VARIABLES:
  !  PRIM    OVERLAP OF GAUSSIAN PRIMITIVES.
  !  DIST    INTERATOMIC DISTANCE VECTOR CORA MINUS CORB.
  !  NORBSA  NUMBER OF ATOMIC ORBITALS ON ATOM A.
  !  NORBSB  NUMBER OF ATOMIC ORBITALS ON ATOM B.
  
  !THIS SUBROUTINE ASSUMES THE FOLLOWING ORGANIZATION OF THE
  !GAUSSIAN BASIS SET. THERE IS ONE S SHELL FOR PER HYDROGEN
  !ATOM AND ONE SP SHELL PER FIRST-ROW ATOM. THE NUMBERING
  !OF THE SHELLS CORRESPONDS TO THE NUMBERING OF THE ATOMS.
  !THE NUMBER OF GAUSSIAN PRIMITIVES OF SHELL I (ATOM I) IS
  !KNG(I), THE INDEX OF THE FIRST PRIMITIVE IS KSTART(I).
  !EXPONENTS AND CONTRACTION COEFFICIENTS OF EACH PRIMITIVE
  !ARE STORED IN EXX, DS, AND DP, RESPECTIVELY.
  
  !INITIALIZE.
  CALL OLDCF
  OVER(:,:) = 0.0D0
  NORBSA    = NLAST(IA) - NFIRST(IA) + 1
  NORBSB    = NLAST(IB) - NFIRST(IB) + 1
  !DOUBLE LOOP OVER ALL PRIMITIVES.
  KA = KSTART(IA)
  DO K=1, KNG(IA)
     AL   = EXX(KA)
     AL05 = SQRT(AL)
     AL15 = AL * AL05
     KB = KSTART(IB)
     DO L=1, KNG(IB)
        BE        = EXX(KB)
        BE05      = SQRT(BE)
        BE15      = BE * BE05
        REZI      = 2.0D0 / (AL + BE)
        REZI05    = SQRT(REZI)
        REZI15    = REZI   * REZI05
        REZI20    = REZI   * REZI
        REZI25    = REZI20 * REZI05
        DIST(:)   = (CORA(:) - CORB(:)) / A0
        DISTSQ    = SUM(DIST(:) * DIST(:))
        FEXP      = EXP(-0.5D0*REZI*AL*BE*DISTSQ)
        PRIM(1,1) = (AL*BE)**0.75D0 * REZI15 * FEXP
        OVER(1,1) = OVER(1,1) + DS(KA) * DS(KB) * PRIM(1,1)
        IF(NORBSA.GT.1) THEN
           DPROD  = DP(KA) * DS(KB)
           DO I=2,4
              PRIM(I,1) = -AL05*BE*REZI*PRIM(1,1)*DIST(I-1)
              OVER(I,1) = OVER(I,1) + DPROD * PRIM(I,1)
           END DO
        END IF
        IF(NORBSB.GT.1) THEN
           DPROD  = DS(KA) * DP(KB)
           DO I=2,4
              PRIM(1,I) = AL*BE05*REZI*PRIM(1,1)*DIST(I-1)
              OVER(1,I) = OVER(1,I) + DPROD * PRIM(1,I)
           END DO
        END IF
        IF(NORBSA.GT.1.AND.NORBSB.GT.1) THEN
           DPROD  = DP(KA) * DP(KB)
           DO I=2,4
              DO J=2,4
                 PRIM(I,J) = -AL15*BE15*REZI20*PRIM(1,1)*DIST(I-1)*DIST(J-1)
              END DO
              PRIM(I,I)    = PRIM(I,I) + (AL*BE)**1.25D0 * REZI25 * FEXP
              DO J=2,4
                 OVER(I,J) = OVER(I,J) + DPROD * PRIM(I,J)
              END DO
           END DO
        END IF
        KB = KB + 1
     END DO
     KA = KA + 1
  END DO
END SUBROUTINE OVRBLK2
  
  
SUBROUTINE PRTCOR(COR)
  IMPLICIT NONE
  REAL*8, DIMENSION(:,:) :: COR
  INTEGER                :: I
  DO I=1, UBOUND(COR,2)
     WRITE(NB6,'(1X,I4,3F12.6)') I, COR(:,I)
  END DO
END SUBROUTINE PRTCOR
  
  
SUBROUTINE PRTMAT(A)
  IMPLICIT NONE
  REAL*8, DIMENSION(:,:) :: A
  INTEGER                :: NCOLS, I, JSTART, JEND
  NCOLS = UBOUND(A,2)
  DO JSTART=1, NCOLS, 10
     JEND = MIN(JSTART+9, NCOLS)
     WRITE(NB6,'(/1X,10I12)') (I,I=JSTART,JEND)
     DO I=1, UBOUND(A,1)
        WRITE(NB6,'(1X,I4,10F12.8)') I, A(I,JSTART:JEND)
     END DO
  END DO
END SUBROUTINE PRTMAT
  
!
! For all MNDO-type methods and OMx methods  
! 
SUBROUTINE OVRBLK3(OVER,CORA,CORB,IA,IB)
  !COMPUTE OVERLAP INTEGRAL 
  !*
  !NOTATION. I=INPUT, O=OUTPUT.
  !OVER(LM4) OVERLAP INTEGRALS (I,O).
  !CORA()   CURRENT ATOMIC COORDINATES (IA, IB).
  !*
  USE LIMIT, ONLY: LM1
  IMPLICIT REAL*8 (A-H,O-Z)
  COMMON /ATOMS / NATOMS,NAT(LM1),NFIRST(LM1),NLAST(LM1)
  COMMON /NBFILE/ NBF(20)
  DIMENSION CORA(3),CORB(3),OVER(:,:)
  DIMENSION SIJ(14),YY(675)

  !COMPUTE OVERLAP AND RESONANCE INTEGRALS.
  NI     = NAT(IA)
  IORBS  = NLAST(IA)-NFIRST(IA)+1
  NJ     = NAT(IB)
  JORBS  = NLAST(IB)-NFIRST(IB)+1
  OVER(:,:) = 0.0D0
  CALL ROTMAT2 (IB,IA,JORBS,IORBS,NATOMS,CORA,CORB,R,YY)
  IF(NOTOMI) THEN
     IF(R.LT.1.0D-6) THEN
        DO I=1,IORBS
           OVER(I,I)=1.0D0
        ENDDO
     ELSE
        CALL OVERLP (NI,NJ,R,SIJ,0,0)
        CALL ROTBET2 (IORBS,JORBS,SIJ,YY,OVER)
     ENDIF
  ELSE
     CALL SPOVER (IA,IB,R,SIJ)
     CALL ROTBET2 (IORBS,JORBS,SIJ,YY,OVER)
  ENDIF
END SUBROUTINE OVRBLK3
  
  
  
SUBROUTINE ROTMAT2 (J,I,JORBS,IORBS,NATOMS,CORA,CORB,R,YY)
  !*
  !ROTATION MATRIX FOR A GIVEN ATOM PAIR I-J (I.GT.J).
  !*
  !NOTATION. I=INPUT, O=OUTPUT.
  !J,I       NUMBERS OF ATOMS IN PAIR I-J (I).
  !JORBS     NUMBER OF BASIS FUNCTIONS AT ATOM J (I).
  !IORBS     NUMBER OF BASIS FUNCTIONS AT ATOM I (I).
  !NATOMS    NUMBER OF ATOMS IN ARRAY COORD (I).
  !COORD()   CARTESIAN COORDINATES, IN ANGSTROM (I).
  !R         INTERATOMIC DISTANCE, IN ATOMIC UNITS (O).
  !YY()      PRECOMBINED ELEMENTS OF THE ROTATION MATRIX (O).
  !*
  !SPECIAL CONVENTION JORBS=0: ATOM J IS AN EXTERNAL POINT
  !CHARGE WITH NO BASIS FUNCTIONS, AND THEREFORE ONLY SOME
  !OF THE PRECOMBINED ELEMENTS YY() ARE NEEDED IN ROTCOH.
  !*
  IMPLICIT REAL*8 (A-H,O-Z)
  PARAMETER (SMALL=1.0D-07)
  PARAMETER (PT5SQ3=0.866025403784438647D0)
  COMMON /CONSTF/ A0,AFACT,EV,EVCAL,PI,W1,W2,BIGEXP
  COMMON /CONSTN/ ZERO,ONE,TWO,THREE,FOUR,PT5,PT25
  DIMENSION CORA(3),CORB(3),YY(15,45)
  DIMENSION P(3,3),D(5,5)
  DIMENSION INDX(9)
  DATA INDX /0,1,3,6,10,15,21,28,36/

  !CALCULATE GEOMETRIC DATA AND INTERATOMIC DISTANCE.
  !CA  = COS(PHI)    , SA  = SIN(PHI)
  !CB  = COS(THETA)  , SB  = SIN(THETA)
  !C2A = COS(2*PHI)  , S2A = SIN(2*PHI)
  !C2B = COS(2*THETA), S2B = SIN(2*PHI)
  X11    = CORB(1)-CORA(1)
  X22    = CORB(2)-CORA(2)
  X33    = CORB(3)-CORA(3)
  B      = X11*X11+X22*X22
  R      = SQRT(B+X33*X33)
  SQB    = SQRT(B)
  SB     = SQB/R
  !CHECK FOR SPECIAL CASE (BOTH ATOMS ON Z AXIS).
  IF(SB.GT.SMALL) THEN
     CA  = X11/SQB
     SA  = X22/SQB
     CB  = X33/R
  ELSE
     SA  = ZERO
     SB  = ZERO
     IF(X33.LT.ZERO) THEN
        CA  =-ONE
        CB  =-ONE
     ELSE IF(X33.GT.ZERO) THEN
        CA  = ONE
        CB  = ONE
     ELSE
        CA  = ZERO
        CB  = ZERO
     ENDIF
  ENDIF
  !CONVERT DISTANCE TO ATOMIC UNITS.
  R      = R/A0
  !CALCULATE ROTATION MATRIX ELEMENTS.
  P(1,1) = CA*SB
  P(2,1) = CA*CB
  P(3,1) =-SA
  P(1,2) = SA*SB
  P(2,2) = SA*CB
  P(3,2) = CA
  P(1,3) = CB
  P(2,3) =-SB
  P(3,3) = ZERO
  IF(IORBS.GE.9 .OR. JORBS.GE.9) THEN
     C2A    = TWO*CA*CA-ONE  
     C2B    = TWO*CB*CB-ONE  
     S2A    = TWO*SA*CA
     S2B    = TWO*SB*CB
     D(1,1) = PT5SQ3*C2A*SB*SB
     D(2,1) = PT5*C2A*S2B
     D(3,1) =-S2A*SB
     D(4,1) = C2A*(CB*CB+PT5*SB*SB)
     D(5,1) =-S2A*CB
     D(1,2) = PT5SQ3*CA*S2B
     D(2,2) = CA*C2B
     D(3,2) =-SA*CB
     D(4,2) =-PT5*CA*S2B
     D(5,2) = SA*SB
     D(1,3) = CB*CB-PT5*SB*SB
     D(2,3) =-PT5SQ3*S2B
     D(3,3) = ZERO
     D(4,3) = PT5SQ3*SB*SB
     D(5,3) = ZERO
     D(1,4) = PT5SQ3*SA*S2B
     D(2,4) = SA*C2B
     D(3,4) = CA*CB
     D(4,4) =-PT5*SA*S2B
     D(5,4) =-CA*SB
     D(1,5) = PT5SQ3*S2A*SB*SB
     D(2,5) = PT5*S2A*S2B
     D(3,5) = C2A*SB
     D(4,5) = S2A*(CB*CB+PT5*SB*SB)
     D(5,5) = C2A*CB
  ENDIF
  !*
  !PRECOMBINE ROTATION MATRIX ELEMENTS.
  !*
  !THE FIRST INDEX OF YY(IJ,KL) IS CONSECUTIVE. AS MANY ELEMENTS
  !AS NEEDED ARE DEFINED (1 FOR KL=SS, 3 FOR KL=PS, 6 FOR KL=PP,
  !5 FOR KL=DS, 15 FOR KL=DP, AND 15 FOR KL=DD).
  !THE SECOND INDEX OF YY(IJ,KL) IS A STANDARD PAIR INDEX.
  !KL=(K*(K-1)/2+L , ORDER OF K AND L AS IN INTEGRAL EVALUATION.
  !*
  !S-S
  YY(1,1)   = ONE
  !P-S
  DO K=1,3
  KL        = INDX(K+1)+1
  YY(1,KL)  = P(K,1)
  YY(2,KL)  = P(K,2)
  YY(3,KL)  = P(K,3)
  ENDDO
  !P-P
  DO K=1,3
  KL        = INDX(K+1)+K+1
  YY(1,KL)  = P(K,1)*P(K,1)
  YY(2,KL)  = P(K,1)*P(K,2)
  YY(3,KL)  = P(K,2)*P(K,2)
  YY(4,KL)  = P(K,1)*P(K,3)
  YY(5,KL)  = P(K,2)*P(K,3)
  YY(6,KL)  = P(K,3)*P(K,3)
  ENDDO
  IF(IORBS.LE.4 .AND. JORBS.EQ.0) RETURN
  DO K=2,3
  DO L=1,K-1
  KL        = INDX(K+1)+L+1
  YY(1,KL)  = P(K,1)*P(L,1)*TWO
  YY(2,KL)  = P(K,1)*P(L,2)+P(K,2)*P(L,1)
  YY(3,KL)  = P(K,2)*P(L,2)*TWO
  YY(4,KL)  = P(K,1)*P(L,3)+P(K,3)*P(L,1)
  YY(5,KL)  = P(K,2)*P(L,3)+P(K,3)*P(L,2)
  YY(6,KL)  = P(K,3)*P(L,3)*TWO
  ENDDO
  ENDDO
  IF(IORBS.LE.4 .AND. JORBS.LE.4) RETURN
  !D-S
  DO K=1,5
  KL        = INDX(K+4)+1
  YY(1,KL)  = D(K,1)
  YY(2,KL)  = D(K,2)
  YY(3,KL)  = D(K,3)
  YY(4,KL)  = D(K,4)
  YY(5,KL)  = D(K,5)
  ENDDO
  !D-P
  DO K=1,5
  DO L=1,3
  KL        = INDX(K+4)+L+1
  YY(1,KL)  = D(K,1)*P(L,1)
  YY(2,KL)  = D(K,1)*P(L,2)
  YY(3,KL)  = D(K,1)*P(L,3)
  YY(4,KL)  = D(K,2)*P(L,1)
  YY(5,KL)  = D(K,2)*P(L,2)
  YY(6,KL)  = D(K,2)*P(L,3)
  YY(7,KL)  = D(K,3)*P(L,1)
  YY(8,KL)  = D(K,3)*P(L,2)
  YY(9,KL)  = D(K,3)*P(L,3)
  YY(10,KL) = D(K,4)*P(L,1)
  YY(11,KL) = D(K,4)*P(L,2)
  YY(12,KL) = D(K,4)*P(L,3)
  YY(13,KL) = D(K,5)*P(L,1)
  YY(14,KL) = D(K,5)*P(L,2)
  YY(15,KL) = D(K,5)*P(L,3)
  ENDDO
  ENDDO
  !D-D
  DO K=1,5
  KL        = INDX(K+4)+K+4
  YY(1,KL)  = D(K,1)*D(K,1)
  YY(2,KL)  = D(K,1)*D(K,2)
  YY(3,KL)  = D(K,2)*D(K,2)
  YY(4,KL)  = D(K,1)*D(K,3)
  YY(5,KL)  = D(K,2)*D(K,3)
  YY(6,KL)  = D(K,3)*D(K,3)
  YY(7,KL)  = D(K,1)*D(K,4)
  YY(8,KL)  = D(K,2)*D(K,4)
  YY(9,KL)  = D(K,3)*D(K,4)
  YY(10,KL) = D(K,4)*D(K,4)
  YY(11,KL) = D(K,1)*D(K,5)
  YY(12,KL) = D(K,2)*D(K,5)
  YY(13,KL) = D(K,3)*D(K,5)
  YY(14,KL) = D(K,4)*D(K,5)
  YY(15,KL) = D(K,5)*D(K,5)
  ENDDO
  IF(IORBS.LE.9 .AND. JORBS.EQ.0) RETURN
  DO K=2,5
  DO L=1,K-1
  KL        = INDX(K+4)+L+4
  YY(1,KL)  = D(K,1)*D(L,1)*TWO
  YY(2,KL)  = D(K,1)*D(L,2)+D(K,2)*D(L,1)
  YY(3,KL)  = D(K,2)*D(L,2)*TWO
  YY(4,KL)  = D(K,1)*D(L,3)+D(K,3)*D(L,1)
  YY(5,KL)  = D(K,2)*D(L,3)+D(K,3)*D(L,2)
  YY(6,KL)  = D(K,3)*D(L,3)*TWO
  YY(7,KL)  = D(K,1)*D(L,4)+D(K,4)*D(L,1)
  YY(8,KL)  = D(K,2)*D(L,4)+D(K,4)*D(L,2)
  YY(9,KL)  = D(K,3)*D(L,4)+D(K,4)*D(L,3)
  YY(10,KL) = D(K,4)*D(L,4)*TWO
  YY(11,KL) = D(K,1)*D(L,5)+D(K,5)*D(L,1)
  YY(12,KL) = D(K,2)*D(L,5)+D(K,5)*D(L,2)
  YY(13,KL) = D(K,3)*D(L,5)+D(K,5)*D(L,3)
  YY(14,KL) = D(K,4)*D(L,5)+D(K,5)*D(L,4)
  YY(15,KL) = D(K,5)*D(L,5)*TWO
  ENDDO
  ENDDO
  RETURN
END SUBROUTINE ROTMAT2
  
  
SUBROUTINE ROTBET2 (IORBS,JORBS,T,YY,H)
  !*
  !THIS ROUTINE TRANSFORMS TWO-CENTER ONE-ELECTRON INTEGRALS FROM
  !LOCAL TO MOLECULAR COORDINATES, AND INCLUDES THEM IN H(LM4).
  !USEFUL FOR RESONANCE INTEGRALS AND FOR OVERLAP INTEGRALS.
  !*
  !NOTATION. I=INPUT, O=OUTPUT.
  !IORBS     NUMBER OF ORBITALS AT ATOM I (I).
  !JORBS     NUMBER OF ORBITALS AT ATOM J (I).
  !T(14)     LOCAL TWO-CENTER ONE-ELECTRON INTEGRALS (I).
  !YY()      PRECOMPUTED COMBINATION OF ROTATION MATRIX ELEMENTS (I).
  !H(LM4)    ONE-ELECTRON MATRIX IN MOLECULAR COORDINATES (O).
  !*
  USE LIMIT, ONLY: LMX
  IMPLICIT REAL*8 (A-H,O-Z)
  COMMON /INDEX / INDX(LMX)
  DIMENSION H(:,:)
  DIMENSION T(14),YY(15,45)
  DIMENSION HDD(15)

  !SECTION FOR AN SP-BASIS.
  !S(I)-S(J)
  H(1,1)  = T(1)
  IF(IORBS.EQ.1 .AND. JORBS.EQ.1) RETURN
  !S(I)-P(J)
  IF(JORBS.GE.4) THEN
     H(1,2) = T(2)*YY(1,2)
     H(1,3) = T(2)*YY(2,2)
     H(1,4) = T(2)*YY(3,2)
  ENDIF
  !P(I)-S(J)
  IF(IORBS.GE.4) THEN
     H(2,1)   = T(3)*YY(1,2)
     H(3,1)   = T(3)*YY(2,2)
     H(4,1)   = T(3)*YY(3,2)
  !P(I)-P(J).
     IF(JORBS.GE.4) THEN
        T45     = T(4)-T(5)
        H(2,2) = YY(1,3)*T45+T(5)
        H(2,3) = YY(2,3)*T45
        H(2,4) = YY(4,3)*T45
        H(3,2) = H(2,3)
        H(3,3) = YY(3,3)*T45+T(5)
        H(3,4) = YY(5,3)*T45
        H(4,2) = H(2,4)
        H(4,3) = H(3,4)
        H(4,4) = YY(6,3)*T45+T(5)
     ENDIF
  ENDIF
  !SECTION INVOLVING D ORBITALS.
  !D(I)-S(J)
  IF(IORBS.GE.9) THEN
     DO I=1,5
     H(I+4,1)   = T(6)*YY(I,11)
     ENDDO
  !D(I)-P(J)
     IF(JORBS.GE.4) THEN
        IJ     = 0
        DO I=1,5
        DO J=1,3
        IJ     = IJ+1
        H(I+4,J+1) = T(8)*YY(IJ,12) + T(10)*(YY(IJ,18)+YY(IJ,25)) + T(10)*(YY(IJ,18)+YY(IJ,25))
        ENDDO
        ENDDO
     ENDIF
  ENDIF
  !S(I)-D(J)
  IF(JORBS.GE.9) THEN
     DO I=1,5
     H(1,I+4) = T(7)*YY(I,11)
     ENDDO
     IF(IORBS.GE.4) THEN
  !P(I)-D(J)
        DO I=1,3
        DO J=1,5
        IJ     = 3*(J-1)+I
        H(I+1,J+4) = T(9)*YY(IJ,12) + T(11)*(YY(IJ,18)+YY(IJ,25))
        ENDDO
        ENDDO
  !D(I)-D(J)
        IF(IORBS.GE.9) THEN
           DO I=1,15
           HDD(I) = T(12)*YY(I,15) + T(13)*(YY(I,21)+YY(I,28)) + T(14)*(YY(I,36)+YY(I,45))
           ENDDO
           DO I=1,5
           DO J=1,5
           IF(I.GE.J) THEN
              IJ  = INDX(I)+J
           ELSE
              IJ  = INDX(J)+I
           ENDIF
           H(I+4,J+4) = HDD(IJ)
           ENDDO
           ENDDO
        ENDIF
     ENDIF
  ENDIF
  RETURN
END SUBROUTINE ROTBET2

END MODULE NACCSF
