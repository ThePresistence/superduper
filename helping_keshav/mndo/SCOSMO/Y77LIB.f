!!!****h* Y77L/EIGSYS
!!!
!!! NAME
!!!     EIGSYS.src77 - eigenvalue and eigenvector routines
!!! COPYRIGHT
!!!     Prof. York's Group
!!!     Department of Chemistry
!!!     University of Minnesota
!!! AUTHOR
!!!     Timothy J. Giese
!!! CREATION DATE
!!!     2004
!!! DESCRIPTION
!!!     calculates eigensystems
!!!     primarily acting as a front-end to lapack
!!! USES
!!!     LAPACK/DSPEVD
!!!     LAPACK/DGESDD
!!!     INIT/CPYM
!!!***

      SUBROUTINE SYMEIG(A,N,EVEC,EVAL)
!!!****f* EIGSYS/SYMEIG
!!!
!!! NAME
!!!   SYMEIG -- DIVIDE AND CONQUER ALGORITHM
!!! USAGE
!!!    CALL SYMEIG(A,N,EVEC,EVAL)
!!! DESCRIPTION
!!!   CALCULATES THE EIGENVALUES AND EIGENVECTORS
!!!   OF A SYMMETRIC MATRIX USING DIVIDE AND CONQUER
!!! INPUTS
!!!     DOUBLE PRECISION A(N,N)
!!!     INTEGER N
!!!
!!! OUTPUT
!!!     DOUBLE PRECISION EVEC(N,N),EVAL(N)
!!! USES
!!!     LAPACK/DSPEVD
!!!***
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INTEGER N,I,J,K,LWORK,LIWORK,INFO,IWORK
      DIMENSION A(N,N),EVEC(N),EVAL(N,N)
      DIMENSION PV((N*N-1)/2+N)
      DIMENSION WORK(1+6*N*N*N)
      DIMENSION IWORK(3+5*N)
C     SIZE OF IWORK (USED FOR DIVIDE AND CONQUER)
      LIWORK=3+5*N
C     SIZE OF WORK (USED FOR DIVIDE AND CONQUER)
      LWORK=1+6*N*N*N
      K=0
      DO 1 I=1,N
         DO 2 J=I,N
            K=K+1
            PV(K)=A(I,J)
 2       CONTINUE
C         WRITE(6,'(20F12.5)')(A(I,J),J=1,N)
 1    CONTINUE
      INFO=0
      CALL DSPEVD('V','L',N,PV,EVAL,EVEC,N,WORK,LWORK,
     $     IWORK, LIWORK, INFO )
      IF(INFO.NE.0) THEN
         CALL I1ERR("EIGSYS.src77","SYMEIG",
     1        "IF(INFO.NE.0) THEN","LAPACK DIVIDE AND CONQUR FAILED",
     1        .TRUE.,.TRUE.,"INFO",INFO)
      END IF
      END SUBROUTINE


      SUBROUTINE SVDKMP(M,A,N,U,W,VT)
!!!****f* EIGSYS/SVDKMP
!!!
!!! NAME
!!!   SVDKMP -- SINGULAR VALUE DECOMPOSITION
!!! USAGE
!!!    CALL SVDKMP(M,A,N,U,W,VT)
!!! DESCRIPTION
!!!   CALCULATES THE SINGULAR VALUE DECOMPOSITION
!!!   OF AN M BY N MATRIX
!!!
!!!   NOTE THAT THE THE RIGHT SINGULAR VECTORS ARE THE
!!!   ROWS OF VT (V TRANSPOSE).
!!! INPUTS
!!!     DOUBLE PRECISION A(M,N)
!!!     INTEGER N
!!!
!!! OUTPUT
!!!     DOUBLE PRECISION U(M,N),W(N),V(N,N)
!!! USES
!!!     LAPACK/DGESDD
!!!     INIT/CPYM
!!! NOTES
!!!     THIS RETURNS V TRANSPOSE WHEREAS YORKLIB'S
!!!     svdcmp RETURNS V
!!!     THE NULL SPACE SINGULAR VECTORS RETURNED
!!!     BY THIS ROUTINE MAY BE DIFFERENT FROM THE
!!!     NULL SPACE SINGULAR VECTORS RETURNED FROM
!!!     YORKLIB, BUT ARE VALID... MEANING
!!!     VT.V = 1 AND UT.U = 1
!!!     AND U.W.VT = A
!!!***
      INTEGER M,N
      DOUBLE PRECISION A,U,W,VT
      DOUBLE PRECISION WT
      DIMENSION A(M,N),U(M,N),W(N),VT(N,N)
      DIMENSION WT(M)
      INTEGER LWORK,INFO,LIWORK
      INTEGER IWORK
      DIMENSION IWORK(1)
      DOUBLE PRECISION WORK
      DIMENSION WORK(1)
      INTEGER LA,LB

C      WRITE(6,*)"ENTERED SVDKMP",M,N
      LWORK = -1
      IF ( M .EQ. N ) THEN
C     CALL THE SQUARE MATRIX ROUTINE
         CALL SQRSVD(A,N,U,W,VT)
      ELSE IF ( M .GT. N ) THEN
C     CALL THE M > N ROUTINE
c         CALL DGESDD("A",M,N,A,M,W,U,M,VT,N,WORK,LWORK,IWORK,INFO)
c         LWORK = WORK(1)
         LIWORK = 8*N
         LA = M
         LB = 4*N*N+4*N
         IF ( LA .GT. LB ) THEN
            LWORK = 3*N*N+LA
         ELSE
            LWORK = 3*N*N+LB
         END IF

         CALL MGNSVD(M,A,N,U,W,VT,LWORK,LIWORK)
      ELSE
C     CALL THE N > M ROUTINE
c         CALL DGESDD("A",M,N,A,M,WT,U,M,VT,N,WORK,LWORK,IWORK,INFO)
c         LWORK = WORK(1)
         LIWORK = 8*M
         LA = N
         LB = 4*M*M+4*M
         IF ( LA .GT. LB ) THEN
            LWORK = 3*M*M+LA
         ELSE
            LWORK = 3*M*M+LB
         END IF

         CALL NGMSVD(M,A,N,U,W,VT,LWORK,LIWORK)
      END IF
      END SUBROUTINE



      SUBROUTINE SQRSVD(A,N,U,W,VT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INTEGER N
      DIMENSION A(N,N),W(N),U(N,N),VT(N,N)
      DIMENSION TMPA(N,N)
      INTEGER LWORK,INFO,LIWORK
      INTEGER IWORK
      DIMENSION IWORK(1)
      DIMENSION WORK(1)

C      WRITE(6,*)"SQRSVD"
      CALL CPYM(N,A,N,TMPA)
      LWORK = -1
C     DUMMY CALL TO GET THE OPTIMAL VALUE OF LWORK
C      CALL PTM(N,TMPA,N,N,N,"SQRSVD:TMPA",6,.FALSE.)
      CALL DGESDD("A",N,N,TMPA,N,W,U,N,VT,N,WORK,LWORK,IWORK,INFO)
      LWORK = WORK(1)
      LIWORK = 8*N
      CALL SVDDRV(TMPA,N,U,W,VT,LWORK,LIWORK)
      END SUBROUTINE

      SUBROUTINE SVDDRV(TMPA,N,U,W,VT,LWORK,LIWORK)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INTEGER N,LWORK,LIWORK,INFO
      INTEGER IWORK
      DIMENSION IWORK(LIWORK)
      DIMENSION WORK(LWORK)
      DIMENSION TMPA(N,N),U(N,N),VT(N,N),W(N)
      INFO = 0
C      WRITE(6,*)"SVDDRV"
C      CALL PTM(N,TMPA,N,N,N,"SVDDRV:TMPA",6,.FALSE.)
C      WRITE(6,*)N,LWORK,LIWORK
      CALL DGESDD("A",N,N,TMPA,N,W,U,N,VT,N,WORK,LWORK,IWORK,INFO)
C      WRITE(6,*)"LEAVING"
      IF(INFO.NE.0) THEN
         CALL I1ERR("EIGSYS.src77","SVDDRV",
     1        "IF(INFO.NE.0) THEN","LAPACK SVD DECOMPOSITION FAILED",
     1        .TRUE.,.TRUE.,"INFO",INFO)
      END IF
      END SUBROUTINE




      SUBROUTINE MGNSVD(M,A,N,U,W,VT,LWORK,LIWORK)
      INTEGER M,N,LWORK,LIWORK,INFO
      INTEGER IWORK
      DIMENSION IWORK(LIWORK)
      DOUBLE PRECISION WORK
      DOUBLE PRECISION A,U,W,VT
      DOUBLE PRECISION UP,TMPA
      DIMENSION WORK(LWORK),A(M,N),U(M,N),W(N),VT(N,N)
      DIMENSION UP(M,M),TMPA(M,N)
      INTEGER I,J
C      WRITE(6,*)"MGN"
      CALL CPYM(M,A,N,TMPA)
      INFO = 0
      CALL DGESDD("A",M,N,TMPA,M,W,UP,M,VT,N,WORK,LWORK,IWORK,INFO)
      IF(INFO.NE.0) THEN
         CALL I1ERR("EIGSYS.src77","MGNSVD",
     1        "IF(INFO.NE.0) THEN","LAPACK SVD DECOMPOSITION FAILED",
     1        .TRUE.,.TRUE.,"INFO",INFO)
      END IF
C     WE ONLY NEED THE FIRST N COLUMNS OF UP IN U
      DO 1 I=1,N
         DO 2 J=1,M
            U(J,I) = UP(J,I)
 2       CONTINUE
 1    CONTINUE
      END SUBROUTINE




      SUBROUTINE NGMSVD(M,A,N,U,W,VT,LWORK,LIWORK)
      INTEGER M,N,LWORK,LIWORK,INFO
      INTEGER IWORK
      DIMENSION IWORK(LIWORK)
      DOUBLE PRECISION WORK
      DOUBLE PRECISION A,U,W,VT
      DOUBLE PRECISION TMPA,TMPU,TMPW
      DIMENSION WORK(LWORK),A(M,N),U(M,N),W(N),VT(N,N)
      DIMENSION TMPA(M,N),TMPU(M,M),TMPW(M)
      INTEGER I,J

C      WRITE(6,*)"ENTERED NBMSVD"

C      WRITE(6,*)"CPYM"
      CALL CPYM(M,A,N,TMPA)
C      WRITE(6,*)"RET"
      INFO = 0
      CALL DGESDD("A",M,N,TMPA,M,TMPW,TMPU,M,VT,N,WORK,LWORK,IWORK,INFO)

      IF(INFO.NE.0) THEN
         CALL I1ERR("EIGSYS.src77","NGMSVD",
     1        "IF(INFO.NE.0) THEN","LAPACK SVD DECOMPOSITION FAILED",
     1        .TRUE.,.TRUE.,"INFO",INFO)
      END IF
C     COPY THE FIRST M ELEMENTS OF TMPW INTO W
      DO 1 I=1,M
         W(I) = TMPW(I)
 1    CONTINUE
C     THE REST OF W IS SINGULAR VALUES
      DO 2 I=M+1,N
         W(I) = 0.0D0
 2    CONTINUE
C     COPY THE FIRST MxM ELEMENTS OF TMPU INTO U
      DO 4 I=1,M
         DO 5 J=1,M
            U(I,J) = TMPU(I,J)
 5       CONTINUE
 4    CONTINUE
C     THE REST OF U IS ZERO
      DO 6 I=1,M
         DO 7 J=M+1,N
            U(I,J) = 0.00000D0
 7       CONTINUE
 6    CONTINUE
      END SUBROUTINE
!!!****h* Y77L/ERROR
!!!
!!! NAME
!!!     ERROR - error handling routines
!!! COPYRIGHT
!!!     Prof. York's Group
!!!     Department of Chemistry
!!!     University of Minnesota
!!! AUTHOR
!!!     Timothy J. Giese
!!! CREATION DATE
!!!     2004
!!! DESCRIPTION
!!!     Stops program execution or provides warning
!!! USES
!!!     Nothing
!!!***

      SUBROUTINE GENERR(FILE,PROC,LINE,MSG,BOMB,VERBOS)
!!!****f* ERROR/GENERR
!!!
!!! NAME
!!!   GENERR -- GENERAL ERROR OR WARNING TRAP
!!! USAGE
!!!    CALL GENERR(FILE,PROC,LINE,MSG,BOMB,VERBOS)
!!! DESCRIPTION
!!!   STOPS PROGRAM EXECUTION IF BONB=.TRUE.
!!!   PRINTS DETAILED INFO IF VERBOS=.TRUE.
!!!   INITIATED FROM FILE=FILE
!!!   INITIATED FROM PROCEDURE (SUBROUTINE)=PROC
!!!   DUE TO SOURCE CODE COMMAND=LINE
!!!   ERROR MESSEGE = MSG
!!! INPUTS
!!!     CHARACTER(LEN=*)FILE,PROC,LINE,MSG
!!!     LOGICAL BOMB,VERBOSE
!!! OUTPUT
!!!     NONE
!!!***
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      CHARACTER(LEN=*) FILE,PROC,LINE,MSG
      LOGICAL BOMB,VERBOS

      IF ( VERBOS .OR. BOMB ) THEN
         WRITE(6,'(A)' )"***************************************"
         WRITE(6,'(A)' )" GENERR - A GENERAL ERROR HAS OCCURED"
         WRITE(6,'(2A)')" CALLED FROM FILE   = ",FILE
         WRITE(6,'(2A)')" WITHIN PROCEDURE   = ",PROC
         WRITE(6,'(2A)')" OFFENDING SRC LINE = ",LINE
         WRITE(6,'(2A)')" MESSEGE PROVIDED   = ",MSG
         WRITE(6,'(A)' )"***************************************"
      ELSE
         WRITE(6,'(2A)')"GENERR> ",MSG
      END IF
      IF ( BOMB ) THEN
         WRITE(6,'(A)')'ABNORMAL TERMINATION VIA GENERR'
         STOP
      END IF
      END SUBROUTINE




      SUBROUTINE I1ERR(FILE,PROC,LINE,MSG,BOMB,VERBOS,I,IVAL)
!!!****f* ERROR/I1ERR
!!!
!!! NAME
!!!   I1ERR -- AN INTEGER ERROR TRAP
!!! USAGE
!!!    CALL I1ERR(FILE,PROC,LINE,MSG,BOMB,VERBOS,I,IVAL)
!!! DESCRIPTION
!!!   STOPS PROGRAM EXECUTION IF BONB=.TRUE.
!!!   PRINTS DETAILED INFO IF VERBOS=.TRUE.
!!!   INITIATED FROM FILE=FILE
!!!   INITIATED FROM PROCEDURE (SUBROUTINE)=PROC
!!!   DUE TO SOURCE CODE COMMAND=LINE
!!!   ERROR MESSEGE = MSG
!!!   INTEGER ERROR WITH VARIABLE = I
!!!   VALUE OF VARIABLE = IVAL
!!! INPUTS
!!!     CHARACTER(LEN=*)FILE,PROC,LINE,MSG,I
!!!     LOGICAL BOMB,VERBOSE
!!!     INTEGER IVAL
!!! OUTPUT
!!!     NONE
!!!***
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      CHARACTER(LEN=*) FILE,PROC,LINE,MSG,I
      INTEGER IVAL
      LOGICAL BOMB,VERBOS

      IF ( VERBOS .OR. BOMB ) THEN
         WRITE(6,'(A)' )"***************************************"
         WRITE(6,'(A)' )" I1ERR - AN INTEGER ERROR HAS OCCURED"
         WRITE(6,'(2A)')" CALLED FROM FILE   = ",FILE
         WRITE(6,'(2A)')" WITHIN PROCEDURE   = ",PROC
         WRITE(6,'(2A)')" OFFENDING SRC LINE = ",LINE
         WRITE(6,'(2A)')" MESSEGE PROVIDED   = ",MSG
         WRITE(6,'(2A,I4)')" VARIABLE/VALUE     = ",I,IVAL
         WRITE(6,'(A)' )"***************************************"
      ELSE
         WRITE(6,'(2A,1X,A,I4)')"I1ERR> ",MSG,I,IVAL
      END IF
      IF ( BOMB ) THEN
         WRITE(6,'(A)')'ABNORMAL TERMINATION VIA I1ERR'
         STOP
      END IF
      END SUBROUTINE




      SUBROUTINE I2ERR(FILE,PROC,LINE,MSG,BOMB,VERBOS,I,IVAL,J,JVAL)
!!!****f* ERROR/I2ERR
!!!
!!! NAME
!!!   I2ERR -- A DOUBLE INTEGER ERROR TRAP
!!! USAGE
!!!    CALL I2ERR(FILE,PROC,LINE,MSG,BOMB,VERBOS,I,IVAL,J,JVAL)
!!! DESCRIPTION
!!!   STOPS PROGRAM EXECUTION IF BONB=.TRUE.
!!!   PRINTS DETAILED INFO IF VERBOS=.TRUE.
!!!   INITIATED FROM FILE=FILE
!!!   INITIATED FROM PROCEDURE (SUBROUTINE)=PROC
!!!   DUE TO SOURCE CODE COMMAND=LINE
!!!   ERROR MESSEGE = MSG
!!!   INTEGER ERROR WITH VARIABLE = I
!!!   VALUE OF VARIABLE = IVAL
!!!   INTEGER ERROR WITH VARIABLE = J
!!!   VALUE OF VARIABLE = JVAL
!!! INPUTS
!!!     CHARACTER(LEN=*)FILE,PROC,LINE,MSG,I,J
!!!     LOGICAL BOMB,VERBOSE
!!!     INTEGER IVAL,JVAL
!!! OUTPUT
!!!     NONE
!!!***
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      CHARACTER(LEN=*) FILE,PROC,LINE,MSG,I,J
      INTEGER IVAL,JVAL
      LOGICAL BOMB,VERBOS

      IF ( VERBOS .OR. BOMB ) THEN
         WRITE(6,'(A)' )"***************************************"
         WRITE(6,'(A)' )" I2ERR - AN INTEGER ERROR HAS OCCURED"
         WRITE(6,'(2A)')" CALLED FROM FILE   = ",FILE
         WRITE(6,'(2A)')" WITHIN PROCEDURE   = ",PROC
         WRITE(6,'(2A)')" OFFENDING SRC LINE = ",LINE
         WRITE(6,'(2A)')" MESSEGE PROVIDED   = ",MSG
         WRITE(6,'(2A,I4)')" VARIABLE/VALUE     = ",I,IVAL
         WRITE(6,'(2A,I4)')" VARIABLE/VALUE     = ",J,JVAL
         WRITE(6,'(A)' )"***************************************"
      ELSE
         WRITE(6,'(2A,1X,2(A,I4))')"I1ERR> ",MSG,I,IVAL,J,JVAL
      END IF
      IF ( BOMB ) THEN
         WRITE(6,'(A)')'ABNORMAL TERMINATION VIA I2ERR'
         STOP
      END IF
      END SUBROUTINE



      SUBROUTINE F1ERR(FILE,PROC,LINE,MSG,BOMB,VERBOS,F,FVAL)
!!!****f* ERROR/F1ERR
!!!
!!! NAME
!!!   F1ERR -- NUMBER ERROR TRAP
!!! USAGE
!!!    CALL F1ERR(FILE,PROC,LINE,MSG,BOMB,VERBOS,F,FVAL)
!!! DESCRIPTION
!!!   STOPS PROGRAM EXECUTION IF BONB=.TRUE.
!!!   PRINTS DETAILED INFO IF VERBOS=.TRUE.
!!!   INITIATED FROM FILE=FILE
!!!   INITIATED FROM PROCEDURE (SUBROUTINE)=PROC
!!!   DUE TO SOURCE CODE COMMAND=LINE
!!!   ERROR MESSEGE = MSG
!!!   NUMBER ERROR WITH VARIABLE = F
!!!   VALUE OF VARIABLE = FVAL
!!! INPUTS
!!!     CHARACTER(LEN=*)FILE,PROC,LINE,MSG,F
!!!     LOGICAL BOMB,VERBOSE
!!!     DOUBLE PRECISION FVAL
!!! OUTPUT
!!!     NONE
!!!***
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      CHARACTER(LEN=*) FILE,PROC,LINE,MSG,F
      DOUBLE PRECISION FVAL
      LOGICAL BOMB,VERBOS

      IF ( VERBOS .OR. BOMB ) THEN
         WRITE(6,'(A)' )"***************************************"
         WRITE(6,'(A)' )" F1ERR - A NUMBER ERROR HAS OCCURED"
         WRITE(6,'(2A)')" CALLED FROM FILE   = ",FILE
         WRITE(6,'(2A)')" WITHIN PROCEDURE   = ",PROC
         WRITE(6,'(2A)')" OFFENDING SRC LINE = ",LINE
         WRITE(6,'(2A)')" MESSEGE PROVIDED   = ",MSG
         WRITE(6,'(2A,E20.12)')" VARIABLE/VALUE     = ",F,FVAL
         WRITE(6,'(A)' )"***************************************"
      ELSE
         WRITE(6,'(2A,1X,A,E20.12)')"I1ERR> ",MSG,F,FVAL
      END IF
      IF ( BOMB ) THEN
         WRITE(6,'(A)')'ABNORMAL TERMINATION VIA F1ERR'
         STOP
      END IF
      END SUBROUTINE




      SUBROUTINE F2ERR(FILE,PROC,LINE,MSG,BOMB,VERBOS,F,FVAL,G,GVAL)
!!!****f* ERROR/F2ERR
!!!
!!! NAME
!!!   F1ERR -- DOUBLE NUMBER ERROR TRAP
!!! USAGE
!!!    CALL F1ERR(FILE,PROC,LINE,MSG,BOMB,VERBOS,F,FVAL,G,GVAL)
!!! DESCRIPTION
!!!   STOPS PROGRAM EXECUTION IF BONB=.TRUE.
!!!   PRINTS DETAILED INFO IF VERBOS=.TRUE.
!!!   INITIATED FROM FILE=FILE
!!!   INITIATED FROM PROCEDURE (SUBROUTINE)=PROC
!!!   DUE TO SOURCE CODE COMMAND=LINE
!!!   ERROR MESSEGE = MSG
!!!   NUMBER ERROR WITH VARIABLE = F
!!!   VALUE OF VARIABLE = FVAL
!!!   NUMBER ERROR WITH VARIABLE = G
!!!   VALUE OF VARIABLE = GVAL
!!! INPUTS
!!!     CHARACTER(LEN=*)FILE,PROC,LINE,MSG,F,G
!!!     LOGICAL BOMB,VERBOSE
!!!     DOUBLE PRECISION FVAL,GVAL
!!! OUTPUT
!!!     NONE
!!!***
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      CHARACTER(LEN=*) FILE,PROC,LINE,MSG,F,G
      DOUBLE PRECISION FVAL,GVAL
      LOGICAL BOMB,VERBOS

      IF ( VERBOS .OR. BOMB ) THEN
         WRITE(6,'(A)' )"***************************************"
         WRITE(6,'(A)' )" F2ERR - A NUMBER ERROR HAS OCCURED"
         WRITE(6,'(2A)')" CALLED FROM FILE   = ",FILE
         WRITE(6,'(2A)')" WITHIN PROCEDURE   = ",PROC
         WRITE(6,'(2A)')" OFFENDING SRC LINE = ",LINE
         WRITE(6,'(2A)')" MESSEGE PROVIDED   = ",MSG
         WRITE(6,'(2A,E20.12)')" VARIABLE/VALUE     = ",F,FVAL
         WRITE(6,'(2A,E20.12)')" VARIABLE/VALUE     = ",G,GVAL
         WRITE(6,'(A)' )"***************************************"
      ELSE
         WRITE(6,'(2A,1X,2(A,E20.12))')"I1ERR> ",MSG,F,FVAL,G,GVAL
      END IF
      IF ( BOMB ) THEN
         WRITE(6,'(A)')'ABNORMAL TERMINATION VIA F2ERR'
         STOP
      END IF
      END SUBROUTINE




      SUBROUTINE I1FERR(FILE,PROC,LINE,MSG,BOMB,VERBOS,I,IVAL,F,FVAL)
!!!****f* ERROR/I1FERR
!!!
!!! NAME
!!!   I1FERR -- VECTOR ELEMENT TRAP
!!! USAGE
!!!    CALL I1FERR(FILE,PROC,LINE,MSG,BOMB,VERBOS,I,IVAL,F,FVAL)
!!! DESCRIPTION
!!!   STOPS PROGRAM EXECUTION IF BOMB=.TRUE.
!!!   PRINTS DETAILED INFO IF VERBOS=.TRUE.
!!!   INITIATED FROM FILE=FILE
!!!   INITIATED FROM PROCEDURE (SUBROUTINE)=PROC
!!!   DUE TO SOURCE CODE COMMAND=LINE
!!!   ERROR MESSEGE = MSG
!!!   NUMBER ERROR WITH VARIABLE = F
!!!   VALUE OF VARIABLE = FVAL
!!!   INTEGER ERROR WITH VARIABLE = I
!!!   VALUE OF VARIABLE = IVAL
!!! INPUTS
!!!     CHARACTER(LEN=*)FILE,PROC,LINE,MSG,F,I
!!!     LOGICAL BOMB,VERBOSE
!!!     DOUBLE PRECISION FVAL,IVAL
!!! OUTPUT
!!!     NONE
!!!***
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      CHARACTER(LEN=*) FILE,PROC,LINE,MSG,F,I
      DOUBLE PRECISION FVAL
      INTEGER IVAL
      LOGICAL BOMB,VERBOS

      IF ( VERBOS .OR. BOMB ) THEN
         WRITE(6,'(A)' )"***************************************"
         WRITE(6,'(A)' )" I1FERR - A VECTOR ELEMENT ERROR HAS OCCURED"
         WRITE(6,'(2A)')" CALLED FROM FILE   = ",FILE
         WRITE(6,'(2A)')" WITHIN PROCEDURE   = ",PROC
         WRITE(6,'(2A)')" OFFENDING SRC LINE = ",LINE
         WRITE(6,'(2A)')" MESSEGE PROVIDED   = ",MSG
         WRITE(6,'(2A,I4)')" VARIABLE/VALUE     = ",I,IVAL
         WRITE(6,'(2A,E20.12)')" VARIABLE/VALUE     = ",F,FVAL
         WRITE(6,'(A)' )"***************************************"
      ELSE
         WRITE(6,'(2A,1X,A,I4,A,E20.12)')"I1FERR> ",MSG,I,IVAL,F,FVAL
      END IF
      IF ( BOMB ) THEN
         WRITE(6,'(A)')'ABNORMAL TERMINATION VIA I1FERR'
         STOP
      END IF
      END SUBROUTINE
!!!****h* Y77L/INIT
!!!
!!! NAME
!!!     INIT.src77 - initialization routines
!!! COPYRIGHT
!!!     Prof. York's Group
!!!     Department of Chemistry
!!!     University of Minnesota
!!! AUTHOR
!!!     Timothy J. Giese
!!! CREATION DATE
!!!     2004
!!! DESCRIPTION
!!!     initialization routines
!!! USES
!!!
!!!***


      SUBROUTINE INITV(V,N,VAL)
!!!****f* INIT/INITV
!!!
!!! NAME
!!!   SUBROUTINE INITV -- INITIALIZES A VECTOR
!!! USAGE
!!!   CALL INITV(V,N,VAL)
!!! DESCRIPTION
!!!   SETS ALL ELEMENTS OF V TO VAL
!!! INPUTS
!!!     DOUBLE PRECISION V(N)
!!!     INTEGER N
!!!     DOUBLE PRECISION VAL
!!! OUTPUT
!!!     DOUBLE PRECISION V(N)
!!!***
      INTEGER N,I
      DOUBLE PRECISION V,VAL
      DIMENSION V(N)
      DO 1 I=1,N
         V(I) = VAL
 1    CONTINUE
      END SUBROUTINE

      SUBROUTINE INITM(M,A,N,VAL)
!!!****f* INIT/INITM
!!!
!!! NAME
!!!   SUBROUTINE INITM -- INITIALIZES A MATRIX
!!! USAGE
!!!   CALL INITM(M,A,N,VAL)
!!! DESCRIPTION
!!!   SETS ALL ELEMENTS OF A TO VAL
!!! INPUTS
!!!     DOUBLE PRECISION A(M,N)
!!!     INTEGER N
!!!     DOUBLE PRECISION VAL
!!! OUTPUT
!!!     DOUBLE PRECISION A(M,N)
!!!***
      INTEGER M,N,I,J
      DOUBLE PRECISION A
      DOUBLE PRECISION VAL
      DIMENSION A(M,N)
      DO 1 I=1,N
         DO 2 J=1,M
            A(J,I) = VAL
 2       CONTINUE
 1    CONTINUE
      END SUBROUTINE




      SUBROUTINE CLRV(V,N)
!!!****f* INIT/CLRV
!!!
!!! NAME
!!!   SUBROUTINE CLRV -- ZERO'S OUT A VECTOR
!!! USAGE
!!!   CALL CLRV(V,N)
!!! DESCRIPTION
!!!   SETS ALL ELEMENTS OF V TO ZERO
!!! INPUTS
!!!     DOUBLE PRECISION V(N)
!!!     INTEGER N
!!! OUTPUT
!!!     DOUBLE PRECISION V(N)
!!!***
      INTEGER N
      DOUBLE PRECISION V
      DIMENSION V(N)
      CALL INITV(V,N,0.00000000000D0)
      END SUBROUTINE


      SUBROUTINE CLRM(M,A,N)
!!!****f* INIT/CLRM
!!!
!!! NAME
!!!   SUBROUTINE CLRM -- ZERO'S OUT A MATRIX
!!! USAGE
!!!   CALL CLRM(A,M,N)
!!! DESCRIPTION
!!!   SETS ALL ELEMENTS OF MATRIX A TO ZERO
!!! INPUTS
!!!     DOUBLE PRECISION A(M,N)
!!!     INTEGER M,N
!!! OUTPUT
!!!     DOUBLE PRECISION A(M,N)
!!!***
      INTEGER N,M
      DOUBLE PRECISION A
      DIMENSION A(M,N)
      CALL INITM(M,A,N,0.00000000000D0)
      END SUBROUTINE



      SUBROUTINE CLRSM(A,N)
!!!****f* INIT/CLRSM
!!!
!!! NAME
!!!   SUBROUTINE CLRSM -- ZERO'S OUT A SYMMETRIC MATRIX
!!! USAGE
!!!   CALL CLRSM(A,N)
!!! DESCRIPTION
!!!   SETS ALL ELEMENTS OF SYMMTRIC MATRIX A TO ZERO
!!! INPUTS
!!!     DOUBLE PRECISION A(N,N)
!!!     INTEGER N
!!! OUTPUT
!!!     DOUBLE PRECISION A(N,N)
!!!***
      INTEGER N
      DOUBLE PRECISION A
      DIMENSION A(N,N)
      CALL INITM(N,A,N,0.00000000000D0)
      END SUBROUTINE


      SUBROUTINE CPYM(M,A,N,B)
!!!****f* INIT/CPYM
!!!
!!! NAME
!!!   SUBROUTINE CPYM -- COPIES MATRIX A INTO B
!!! USAGE
!!!   CALL CPYM(M,A,N,B)
!!! DESCRIPTION
!!!   COPIES A INTO B, EACH WITH DIMENSIONS MxN
!!! INPUTS
!!!     DOUBLE PRECISION A(M,N)
!!!     INTEGER M,N
!!! OUTPUT
!!!     DOUBLE PRECISION B(M,N)
!!!***
      INTEGER N,M,I,J
      DOUBLE PRECISION A,B
      DIMENSION A(M,N),B(M,N)
      DO 1 I=1,M
         DO 2 J=1,N
            B(I,J) = A(I,J)
 2       CONTINUE
 1    CONTINUE
      END SUBROUTINE

      SUBROUTINE CPYV(A,N,B)
!!!****f* INIT/CPYV
!!!
!!! NAME
!!!   SUBROUTINE CPYV -- COPIES VECTOR A INTO B
!!! USAGE
!!!   CALL CPYV(A,N,B)
!!! DESCRIPTION
!!!   COPIES A INTO B, EACH WITH DIMENSIONS N
!!! INPUTS
!!!     DOUBLE PRECISION A(N)
!!!     INTEGER N
!!!
!!! OUTPUT
!!!     DOUBLE PRECISION B(N)
!!!***
      INTEGER N,I
      DOUBLE PRECISION A,B
      DIMENSION A(N),B(N)
      DO 1 I=1,N
         B(I) = A(I)
 1    CONTINUE
      END SUBROUTINE

!!!****h* Y77L/INVERT
!!!
!!! NAME
!!!     INVERT.src77 - matrix inversion routines
!!! COPYRIGHT
!!!     Prof. York's Group
!!!     Department of Chemistry
!!!     University of Minnesota
!!! AUTHOR
!!!     Timothy J. Giese
!!! CREATION DATE
!!!     2004
!!! DESCRIPTION
!!!     inverts a matrix
!!!     primarily acting as a front-end to lapack
!!! USES
!!!     LAPACK/DPOTRF
!!!     LAPACK/DPPTRI
!!!     EIGSYS/SVDKMP
!!!     MATMUL/YIA
!!!     MATMUL/YCD
!!!***



      SUBROUTINE SYMINV(A,N,B)
!!!****f* INVERT/SYMINV
!!!
!!! NAME
!!!   SYMINV -- CHOLESKY DECOMPOSITION MATRIX INVERSION
!!! USAGE
!!!    CALL SYMINV(A,N,B)
!!! DESCRIPTION
!!!    INVERTS A SYMMETRIC MATRIX KNOWN TO BE NONSINGULAR
!!! INPUTS
!!!     DOUBLE PRECISION A(N,N)
!!!     INTEGER N
!!!
!!! OUTPUT
!!!     DOUBLE PRECISION B(N,N)
!!! USES
!!!     LAPACK/DPOTRF
!!!     LAPACK/DPPTRI
!!!***
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INTEGER N,LPAK
      DIMENSION A(N,N),B(N,N)
      INTEGER INFO
      LPAK = N+N*(N-1)/2
      CALL SINVDR(A,B,N,LPAK,INFO)
      RETURN
      END SUBROUTINE

      SUBROUTINE SINVDR(A,B,N,LPAK,INFO)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INTEGER N,J,I,ICNT,LPAK
      DIMENSION A(N,N),B(N,N),CHLFAC(LPAK)
      INTEGER INFO
C     INFO WILL TELL US IF WE HAVE AN ERROR
C     IF ALL WENT WELL, THEN IT WILL HAVE A VALUE OF 0
      INFO = 0
      DO 301 J=1,N
         DO 302 I=1,J
            B(I,J) = A(I,J)
 302     CONTINUE
 301  CONTINUE
C     THIS IS FROM LAPACK.  IT CALCULATES A CHOLESKY FACTORIZATION
C     AND STORES IT IN THE UPPER DIAGONAL OF THE ETAINV MATRIX
C     WE NEED THIS FACTORIZATION LATER ON TO ACTUALLY GET THE INVERSE
      CALL DPOTRF("U",N,B,N,INFO)
      IF ( INFO .NE. 0 ) THEN
         WRITE(6,*)"*ERROR SYMINV CALC CHOLESKY FACTORS: DPOTRF"
         STOP
         RETURN
      END IF

C     OK, WE HAVE THE FACTORIZATION.  NOW WE NEED TO CALL A ROUTINE
C     THAT WILL TAKE THAT FACTORIZATION AND ACTUALLY PERFORM THE INVERSE
C     THE INPUT FORMAT FOR THIS ROUTINE REQUIRES THAT THE UPPER
C     DIAGONAL BE *PACKED* INTO A VECTOR... SO THAT'S WHAT WE DO HERE
      ICNT = 0
      DO 305 J=1,N
         DO 306 I=1,J
            ICNT = ICNT+1
            CHLFAC(ICNT) = B(I,J)
 306     CONTINUE
 305  CONTINUE
C     NOW WE CALL THE ROUTINE WHICH TAKES OUR PACKED FACTORIZATION
C     AND RETURNS THE INVERSE OF OUR MATRIX.  IT WILL BE RETURNED
C     IN THE PACKED FORM, HOWEVER, SO WE NEED TO UNPACK IT LATER.
      CALL DPPTRI("U",N,CHLFAC,INFO)

C     QUICK CHECK.  DID WE SUCCESSFULLY INVERT THE MATRIX?
      IF ( INFO .NE. 0 ) THEN
C     NO, WE DID NOT
         WRITE(6,*)"SYMINV ERROR CALC INVERSE WITH DPPTRI"
C     OK.  WHY DIDN'T WE?
         IF ( INFO > 0 ) THEN
C     AH.  WELL, PERHAPS THIS MATRIX DOESN'T HAVE AN INVERSE?
C     OR SOMETHING GOT SCREWED UP.
            WRITE(6,*)"THE (",INFO,",",INFO,")'th ELEMENT IS 0"
         ELSE
C     THERE WAS AN ERROR IN HOW THE ROUTINE WAS CALLED.
C     THIS WOULD BE A PROGRAMMING ERROR
            WRITE(6,*)"THE ",INFO,"'TH ARGUMENT HAD ILLEGAL VALUE"
         END IF
C     WELL, WE CAN'T REALLY DO ANYTHING IF WE CAN'T INVERT
C     THE ETA MATRIX.  WE MIGHT AS WELL STOP DOING THIS
C     BLASTED CPE STUFF AND GET ON WITH THE REST OF THE
C     MNDO97 PROGRAM!
         STOP
         RETURN
      ELSE
C     WE SUCCESSFULLY CALCULATED THE INVERSE OF THE ETA MATRIX
C     AND IT IS NOW STORED IN PACKED FORM... SO WE NEED TO UNPACK IT
         ICNT=0
         DO 307 J=1,N
            DO 308 I=1,J
               ICNT=ICNT+1
               B(I,J) = CHLFAC(ICNT)
               B(J,I) = CHLFAC(ICNT)
 308        CONTINUE
 307     CONTINUE
      END IF
      RETURN
      END SUBROUTINE


 
      SUBROUTINE SVDINV(M,A,N,AINV)
!!!****f* INVERT/SVDINV
!!!
!!! NAME
!!!   SVDINV -- SINGULAR VALUE DECOMPOSITION MATRIX INVERSION
!!! USAGE
!!!    CALL SVDINV(M,A,N,AINV)
!!! DESCRIPTION
!!!    COMPUTES INVERSE OF AN M BY N MATRIX
!!!    USING SINGULAR VALUE DECOMPOSITION
!!!    THIS ROUTINE ZERO'S OUT SINGULAR VALUES LESS THAN 1.0D-8
!!! INPUTS
!!!     DOUBLE PRECISION A(M,N)
!!!     INTEGER M,N
!!!
!!! OUTPUT
!!!     DOUBLE PRECISION AINV(N,M)
!!! USES
!!!     EIGSYS/SVDKMP
!!!     MATMUL/YCD
!!!***
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INTEGER M,N,I
      DIMENSION A(M,N),AINV(N,M)
      DIMENSION U(M,N),W(N),VT(N,N)
C     GET THE SVD DECOMPOSITION OF MATRIX A
C      WRITE(6,*)"ENTERED SVDKMP"
      CALL SVDKMP(M,A,N,U,W,VT)
C     INVERT THE W MATRIX, REMOVING SINGULAR VALUES
      DO 1 I=1,N
         IF ( W(I) .LT. 1.0D-8 ) THEN
            W(I) = 0.0D0
         ELSE
            W(I) = 1.0D0 / W(I)
         END IF
 1    CONTINUE
C      CALL PTV(W,N,N,"SVDINV:W**-1",6,.TRUE.)
C     Uprime = U.w
      CALL YAI(M,U,W,N,U)
C     Ainv = (Vt)t . (Uprime)t = (Vt)t . (U.w)t
      CALL YCD(N,VT,N,U,M,AINV)
      END SUBROUTINE
C%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
C  COULOMB INTEGRALS
C%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


!!!****h* Y77L/JINT
!!!
!!! NAME
!!!     JINT.src77 - Coulomb Integral Routines
!!! COPYRIGHT
!!!     Prof. York's Group
!!!     Department of Chemistry
!!!     University of Minnesota
!!! AUTHOR
!!!     Timothy J. Giese
!!! CREATION DATE
!!!     2004
!!! DESCRIPTION
!!!     calculates point-point, point-gaussian, and gaussian-gaussian coulomb integrals
!!! NOTES
!!!     The normalized gaussian is defined as
!!!     (Z**2/PI)**1.5D0 * EXP(-Z**2 * (R-Rc)**2)
!!!     Point: The exponent is the square of the zeta.
!!!     If your parameters correspond to an exponent which is not squared,
!!!     then take the square root of it before usign these routines.
!!! USES
!!!     INIT/CLRV
!!!     INIT/CLRM
!!!***





C-------------------------------------------------------------
C     POINT CHARGE-POINT CHARGE INTEGRALS
C-------------------------------------------------------------

      SUBROUTINE PPJSS(XI,YI,ZI,XJ,YJ,ZJ,PPJ)
!!!****f* JINT/PPJSS
!!!
!!! NAME
!!!   PPJSS
!!! USAGE
!!!    CALL PPJSS(XI,YI,ZI,XJ,YJ,ZJ,PPJ)
!!! DESCRIPTION
!!!   CALCULATES THE COULOMB INTEGRAL OF
!!!   POINT MONOPOLE WITH POINT MONOPOLE
!!! INPUTS
!!!     DOUBLE PRECISION XI,YI,ZI,XJ,YJ,ZJ
!!!
!!! OUTPUT
!!!     DOUBLE PRECISION PPJ
!!!***

      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION CRDS(3)
      PPJ = 0.0D0
      CRDS(1) = XI-XJ
      CRDS(2) = YI-YJ
      CRDS(3) = ZI-ZJ
      RIJ    = SQRT( CRDS(1)**2+CRDS(2)**2+CRDS(3)**2 )
      IF ( RIJ.LT.1.0D-8 ) RETURN
      PPJ = 1.0D0/RIJ
      END SUBROUTINE



      SUBROUTINE PPJSP(XI,YI,ZI,XJ,YJ,ZJ,PPJ)
!!!****f* JINT/PPJSP
!!!
!!! NAME
!!!   PPJSP
!!! USAGE
!!!    CALL PPJSP(XI,YI,ZI,XJ,YJ,ZJ,PPJ)
!!! DESCRIPTION
!!!   CALCULATES THE COULOMB INTEGRAL OF
!!!   POINT MONOPOLE WITH POINT DIPOLE
!!! INPUTS
!!!     DOUBLE PRECISION XI,YI,ZI,XJ,YJ,ZJ
!!!
!!! OUTPUT
!!!     DOUBLE PRECISION PPJ(3)
!!!***
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INTEGER ICRD
      DIMENSION PPJ(3),CRDS(3)
      CALL CLRV(PPJ,3)
      CRDS(1) = XI-XJ
      CRDS(2) = YI-YJ
      CRDS(3) = ZI-ZJ
      RIJ    = SQRT( CRDS(1)**2+CRDS(2)**2+CRDS(3)**2 )
      IF ( RIJ.LT.1.0D-8 ) RETURN
      RIJ3 = RIJ**3
      DO 100 ICRD=1,3
         PPJ(ICRD)=CRDS(ICRD)/RIJ3
 100  CONTINUE
      END SUBROUTINE



      SUBROUTINE PPJPS(XI,YI,ZI,XJ,YJ,ZJ,PPJ)
!!!****f* JINT/PPJPS
!!!
!!! NAME
!!!   PPJPS
!!! USAGE
!!!    CALL PPJPS(XI,YI,ZI,XJ,YJ,ZJ,PPJ)
!!! DESCRIPTION
!!!   CALCULATES THE COULOMB INTEGRAL OF
!!!   POINT DIPOLE WITH POINT MONOPOLE
!!! INPUTS
!!!     DOUBLE PRECISION XI,YI,ZI,XJ,YJ,ZJ
!!!
!!! OUTPUT
!!!     DOUBLE PRECISION PPJ(3)
!!!***
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION PPJ(3)
      CALL PPJSP(XJ,YJ,ZJ,XI,YI,ZI,PPJ)
      END SUBROUTINE





      SUBROUTINE PPJPP(XI,YI,ZI,XJ,YJ,ZJ,PPJ)
!!!****f* JINT/PPJPP
!!!
!!! NAME
!!!   PPJPP
!!! USAGE
!!!    CALL PPJPP(XI,YI,ZI,XJ,YJ,ZJ,PPJ)
!!! DESCRIPTION
!!!   CALCULATES THE COULOMB INTEGRAL OF
!!!   POINT DIPOLE WITH POINT DIPOLE
!!! INPUTS
!!!     DOUBLE PRECISION XI,YI,ZI,XJ,YJ,ZJ
!!!
!!! OUTPUT
!!!     DOUBLE PRECISION PPJ(3,3)
!!!***
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INTEGER ICRD,JCRD
      DIMENSION PPJ(3,3),CRDS(3)
      CALL CLRM(3,PPJ,3)
      CRDS(1) = XI-XJ
      CRDS(2) = YI-YJ
      CRDS(3) = ZI-ZJ
      RIJ    = SQRT( CRDS(1)**2+CRDS(2)**2+CRDS(3)**2 )
      IF ( RIJ.LT.1.0D-8 ) RETURN
      RIJ3 = RIJ**3
      RIJ5 = RIJ3*RIJ*RIJ
      C11OFF = -3.0D0/RIJ5
      C11ON  = 1.0D0/RIJ3
      DO 115 ICRD = 1,3
         DO 120 JCRD = 1,3
            PPJ(ICRD,JCRD)=C11OFF*CRDS(ICRD)*CRDS(JCRD)
 120     CONTINUE
         PPJ(ICRD,ICRD)=PPJ(ICRD,ICRD)+C11ON
 115  CONTINUE
      END SUBROUTINE







C-------------------------------------------------------------
C     GAUSSIAN-POINT CHARGE COULOMB INTEGRALS
C-------------------------------------------------------------



      SUBROUTINE GPJSS(ZETI,XI,YI,ZI,XJ,YJ,ZJ,GPJ)
!!!****f* JINT/GPJSS
!!!
!!! NAME
!!!   GPJSS
!!! USAGE
!!!    CALL GPJSS(ZI,XI,YI,ZI,XJ,YJ,ZJ,GPJ)
!!! DESCRIPTION
!!!   CALCULATES THE COULOMB INTEGRAL OF
!!!   GAUSSIAN MONOPOLE WITH POINT MONOPOLE
!!! INPUTS
!!!     DOUBLE PRECISION XI,YI,ZI,XJ,YJ,ZJ , ZETI
!!!
!!! OUTPUT
!!!     DOUBLE PRECISION GPJ
!!!***
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION CRDS(3)
      CRDS(1) = XI-XJ
      CRDS(2) = YI-YJ
      CRDS(3) = ZI-ZJ
      RIJ    = SQRT( CRDS(1)**2+CRDS(2)**2+CRDS(3)**2 )
      IF ( RIJ.LT.1.0D-8 ) THEN
         PI     = 3.141592653589793238462643383279502884197D0
         TSQOP  = 2.0D0/SQRT(PI)
         GPJ = TSQOP*ZETI
      ELSE
         GPJ = ERF(ZETI*RIJ)/RIJ
      END IF
      END SUBROUTINE



      SUBROUTINE PGJSS(ZETI,XI,YI,ZI,XJ,YJ,ZJ,GPJ)
!!!****f* JINT/PGJSS
!!!
!!! NAME
!!!   GPJSS
!!! USAGE
!!!    CALL PGJSS(ZETI,XI,YI,ZI,XJ,YJ,ZJ,GPJ)
!!! DESCRIPTION
!!!   CALCULATES THE COULOMB INTEGRAL OF
!!!   POINT MONOPOLE WITH GAUSSIAN MONOPOLE
!!! INPUTS
!!!     DOUBLE PRECISION XI,YI,ZI,XJ,YJ,ZJ , ZETI
!!!
!!! OUTPUT
!!!     DOUBLE PRECISION GPJ
!!!***
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CALL GPJSS(ZETI,XI,YI,ZI,XJ,YJ,ZJ,GPJ)
      END SUBROUTINE




      SUBROUTINE GPJPS(ZETI,XI,YI,ZI,XJ,YJ,ZJ,GGJ)
!!!****f* JINT/GPJPS
!!!
!!! NAME
!!!   GPJPS
!!! USAGE
!!!    CALL  GPJPS(ZETI,XI,YI,ZI,XJ,YJ,ZJ,GGJ)
!!! DESCRIPTION
!!!   CALCULATES THE COULOMB INTEGRAL OF
!!!   GAUSSIAN DIPOLE WITH POINT MONOPOLE
!!! INPUTS
!!!     DOUBLE PRECISION XI,YI,ZI,XJ,YJ,ZJ , ZETI
!!!
!!! OUTPUT
!!!     DOUBLE PRECISION GGJ(3)
!!!***
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INTEGER ICRD
      DIMENSION GGJ(3),CRDS(3)
      PI     = 3.141592653589793238462643383279502884197D0
      TSQOP  = 2.0D0/SQRT(PI)
      CRDS(1) = XI-XJ
      CRDS(2) = YI-YJ
      CRDS(3) = ZI-ZJ
      RIJ    = SQRT( CRDS(1)**2+CRDS(2)**2+CRDS(3)**2 )
      IF ( RIJ.LT.1.0D-8 ) THEN
         DO 10 ICRD=1,3
            GGJ(ICRD) = 0.0D0
 10      CONTINUE
         RETURN
      END IF
      RIJ3   = RIJ**3
      ZIR    = ZETI*RIJ
      ERFZIR = ERF(ZIR)
      CPENUT = TSQOP*ZIR*EXP(-ZIR*ZIR)-ERFZIR
      CPENUT = CPENUT/RIJ3
      DO 150 ICRD = 1,3
         GGJ(ICRD)=CPENUT*CRDS(ICRD)
 150  CONTINUE
      END SUBROUTINE



      SUBROUTINE PGJPS(ZETI,XI,YI,ZI,XJ,YJ,ZJ,GGJ)
!!!****f* JINT/PGJPS
!!!
!!! NAME
!!!   PGJPS
!!! USAGE
!!!    CALL PGJPS(ZETI,XI,YI,ZI,XJ,YJ,ZJ,GGJ)
!!! DESCRIPTION
!!!   CALCULATES THE COULOMB INTEGRAL OF
!!!   POINT DIPOLE WITH GAUSSIAN MONOPOLE
!!! INPUTS
!!!     DOUBLE PRECISION XI,YI,ZI,XJ,YJ,ZJ , ZETI
!!!
!!! OUTPUT
!!!     DOUBLE PRECISION GGJ(3)
!!!***
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION GGJ(3)
      CALL GPJPS(ZETI,XI,YI,ZI,XJ,YJ,ZJ,GGJ)
      END SUBROUTINE



      SUBROUTINE GPJSP(ZETI,XI,YI,ZI,XJ,YJ,ZJ,GGJ)
!!!****f* JINT/GPJSP
!!!
!!! NAME
!!!   GPJSP
!!! USAGE
!!!    CALL GPJSP(ZETI,XI,YI,ZI,XJ,YJ,ZJ,GGJ)
!!! DESCRIPTION
!!!   CALCULATES THE COULOMB INTEGRAL OF
!!!   GAUSSIAN MONOPOLE WITH POINT DIPOLE
!!! INPUTS
!!!     DOUBLE PRECISION XI,YI,ZI,XJ,YJ,ZJ , ZETI
!!!
!!! OUTPUT
!!!     DOUBLE PRECISION GGJ(3)
!!!***
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION GGJ(3)
      CALL GPJPS(ZETI,XJ,YJ,ZJ,XI,YI,ZI,GGJ)
      END SUBROUTINE



      SUBROUTINE PGJSP(ZETI,XI,YI,ZI,XJ,YJ,ZJ,GGJ)
!!!****f* JINT/PGJSP
!!!
!!! NAME
!!!   PGJSP
!!! USAGE
!!!    CALL PGJSP(ZETI,XI,YI,ZI,XJ,YJ,ZJ,GGJ)
!!! DESCRIPTION
!!!   CALCULATES THE COULOMB INTEGRAL OF
!!!   POINT MONOPOLE WITH GAUSSIAN DIPOLE
!!! INPUTS
!!!     DOUBLE PRECISION XI,YI,ZI,XJ,YJ,ZJ , ZETI
!!!
!!! OUTPUT
!!!     DOUBLE PRECISION GGJ(3)
!!!***
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION GGJ(3)
      CALL GPJPS(ZETI,XJ,YJ,ZJ,XI,YI,ZI,GGJ)
      END SUBROUTINE



      SUBROUTINE GPJPP(ZETI,XI,YI,ZI,XJ,YJ,ZJ,GGJ)
!!!****f* JINT/GPJPP
!!!
!!! NAME
!!!   GPJPP
!!! USAGE
!!!    CALL GPJPP(ZETI,XI,YI,ZI,XJ,YJ,ZJ,GGJ)
!!! DESCRIPTION
!!!   CALCULATES THE COULOMB INTEGRAL OF
!!!   GAUSSIAN DIPOLE WITH POINT DIPOLE
!!! INPUTS
!!!     DOUBLE PRECISION XI,YI,ZI,XJ,YJ,ZJ , ZETI
!!!
!!! OUTPUT
!!!     DOUBLE PRECISION GGJ(3,3)
!!!***
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INTEGER ICRD,JCRD
      DIMENSION GGJ(3,3),CRDS(3)
      CALL CLRM(3,GGJ,3)
      PI     = 3.141592653589793238462643383279502884197D0
      TSQOP  = 2.0D0/SQRT(PI)
      CRDS(1) = XI-XJ
      CRDS(2) = YI-YJ
      CRDS(3) = ZI-ZJ
      RIJ    = SQRT( CRDS(1)**2+CRDS(2)**2+CRDS(3)**2 )
      IF ( RIJ.LT.1.0D-8 ) THEN
         DO 100 ICRD = 1,3
            GGJ(ICRD,ICRD) = (ZETI**3)*TSQOP*2.0D0/3.0D0
 100     CONTINUE
         RETURN
      END IF
      ZR = ZETI*RIJ
      ZR2 = ZR*ZR
      C11OFF = TSQOP*ZR*EXP(-ZR2)*(3.0D0+2.0D0*ZR2)-3.0D0*ERF(ZR)
      C11ON  = ERF(ZR)-TSQOP*ZR*EXP(-ZR2)
      DO 115 ICRD = 1,3
         DO 120 JCRD = 1,3
            GGJ(ICRD,JCRD)=C11OFF*CRDS(ICRD)*CRDS(JCRD)
 120     CONTINUE
         GGJ(ICRD,ICRD)=GGJ(ICRD,ICRD)+C11ON
 115  CONTINUE
      END SUBROUTINE



      SUBROUTINE PGJPP(ZETI,XI,YI,ZI,XJ,YJ,ZJ,GGJ)
!!!****f* JINT/PGJPP
!!!
!!! NAME
!!!   PGJPP
!!! USAGE
!!!    CALL PGJPP(ZETI,XI,YI,ZI,XJ,YJ,ZJ,GGJ)
!!! DESCRIPTION
!!!   CALCULATES THE COULOMB INTEGRAL OF
!!!   POINT DIPOLE WITH GAUSSIAN DIPOLE
!!! INPUTS
!!!     DOUBLE PRECISION XI,YI,ZI,XJ,YJ,ZJ , ZETI
!!!
!!! OUTPUT
!!!     DOUBLE PRECISION GGJ(3,3)
!!!***
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION GGJ(3,3)
      CALL GPJPP(ZETI,XI,YI,ZI,XJ,YJ,ZJ,GGJ)
      END SUBROUTINE




C-------------------------------------------------------------
C     GAUSSIAN-GAUSSIAN INTEGRALS
C-------------------------------------------------------------



      SUBROUTINE GGJSS(ZA,ZB,XI,YI,ZI,XJ,YJ,ZJ,GGJ)
!!!****f* JINT/GGJSS
!!!
!!! NAME
!!!   GGJSS
!!! USAGE
!!!    CALL GGJSS(ZA,ZB,XI,YI,ZI,XJ,YJ,ZJ,GGJ)
!!! DESCRIPTION
!!!   CALCULATES THE COULOMB INTEGRAL OF
!!!   GAUSSIAN MONOPOLE WITH GAUSSIAN MONOPOLE
!!! INPUTS
!!!     DOUBLE PRECISION XI,YI,ZI,XJ,YJ,ZJ , ZA,ZB
!!!
!!! OUTPUT
!!!     DOUBLE PRECISION GGJ
!!!***
C*************************************************************
C     GAUSSIAN MONOPOLE/GAUSSIAN MONOPOLE COULOMB INETERACTION
C*************************************************************
      DOUBLE PRECISION GGJ,ZA,ZB,RAB,XI,YI,ZI,XJ,YJ,ZJ
      DOUBLE PRECISION BAB,PI
      DOUBLE PRECISION ERF
      PI     = 3.141592653589793238462643383279502884197D0
      RAB=SQRT((XI-XJ)**2+(YI-YJ)**2+(ZI-ZJ)**2)
      BAB = ZA*ZB / SQRT(ZA**2+ZB**2)
      IF ( RAB .GT. 1.0D-8 ) THEN
         GGJ = ERF(BAB*RAB)/RAB
      ELSE
         GGJ = 2.0D0*BAB/SQRT(PI)
      END IF
      END SUBROUTINE


 
      
      SUBROUTINE GGJSP(ZETI,ZETJ,XI,YI,ZI,XJ,YJ,ZJ,GGJ)
!!!****f* JINT/GGJSP
!!!
!!! NAME
!!!   GGJSP
!!! USAGE
!!!    CALL GGJSP(ZETI,ZETJ,XI,YI,ZI,XJ,YJ,ZJ,GGJ)
!!! DESCRIPTION
!!!   CALCULATES THE COULOMB INTEGRAL OF
!!!   GAUSSIAN MONOPOLE WITH GAUSSIAN DIPOLE
!!! INPUTS
!!!     DOUBLE PRECISION XI,YI,ZI,XJ,YJ,ZJ , ZETI,ZETJ
!!!
!!! OUTPUT
!!!     DOUBLE PRECISION GGJ(3)
!!!***
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INTEGER ICRD
      DIMENSION GGJ(3),CRDS(3)
      CALL CLRV(GGJ,3)
      PI     = 3.141592653589793238462643383279502884197D0
      TSQOP  = 2.0D0/SQRT(PI)
      CRDS(1) = XI-XJ
      CRDS(2) = YI-YJ
      CRDS(3) = ZI-ZJ
      RIJ    = SQRT( CRDS(1)**2+CRDS(2)**2+CRDS(3)**2 )
      ZIJ    = ZETI*ZETJ/SQRT(ZETI**2+ZETJ**2)
      IF ( RIJ .LT. 1.0D-8 ) RETURN
      RIJ3   = RIJ**3
      ZR     = ZIJ * RIJ
      ZR2    = ZR*ZR
      ERFZR  = ERF(ZR)
      ZEXR   = TSQOP*ZR*EXP(-ZR2)
      CPENUT = ERFZR-ZEXR
      DO 100 ICRD=1,3
         GGJ(ICRD) = CPENUT*CRDS(ICRD)
 100  CONTINUE
      END SUBROUTINE



      SUBROUTINE GGJPS(ZETI,ZETJ,XI,YI,ZI,XJ,YJ,ZJ,GGJ)
!!!****f* JINT/GGJPS
!!!
!!! NAME
!!!   GGJPS
!!! USAGE
!!!    CALL GGJPS(ZETI,ZETJ,XI,YI,ZI,XJ,YJ,ZJ,GGJ)
!!! DESCRIPTION
!!!   CALCULATES THE COULOMB INTEGRAL OF
!!!   GAUSSIAN DIPOLE WITH GAUSSIAN MONOPOLE
!!! INPUTS
!!!     DOUBLE PRECISION XI,YI,ZI,XJ,YJ,ZJ , ZETI,ZETJ
!!!
!!! OUTPUT
!!!     DOUBLE PRECISION GGJ(3)
!!!***
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION GGJ(3)
      CALL GGJSP(ZETJ,ZETI,XJ,YJ,ZJ,XI,YI,ZI,GGJ)
      END SUBROUTINE


      
      SUBROUTINE GGJPP(ZETI,ZETJ,XI,YI,ZI,XJ,YJ,ZJ,GGJ)
!!!****f* JINT/GGJPP
!!!
!!! NAME
!!!   GGJPP
!!! USAGE
!!!    CALL GGJPP(ZETI,ZETJ,XI,YI,ZI,XJ,YJ,ZJ,GGJ)
!!! DESCRIPTION
!!!   CALCULATES THE COULOMB INTEGRAL OF
!!!   GAUSSIAN DIPOLE WITH GAUSSIAN DIPOLE
!!! INPUTS
!!!     DOUBLE PRECISION XI,YI,ZI,XJ,YJ,ZJ , ZETI,ZETJ
!!!
!!! OUTPUT
!!!     DOUBLE PRECISION GGJ(3,3)
!!!***
C*********************************************************
C     GAUSSIAN DIPOLE/GAUSSIAN DIPOLE COULOMB INTERACTION
C*********************************************************
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INTEGER ICRD,JCRD
      DIMENSION GGJ(3,3),CRDS(3)
      DOUBLE PRECISION ZR,ERFZR
      CALL CLRM(3,GGJ,3)
      PI     = 3.141592653589793238462643383279502884197D0
      TSQOP  = 2.0D0/SQRT(PI)
      CRDS(1) = XI-XJ
      CRDS(2) = YI-YJ
      CRDS(3) = ZI-ZJ
      RIJ    = SQRT( CRDS(1)**2+CRDS(2)**2+CRDS(3)**2 )
      ZIJ    = ZETI*ZETJ/SQRT(ZETI**2+ZETJ**2)
      IF ( RIJ .LT. 1.0D-8 ) THEN
         C11ON = ZIJ**3*TSQOP*2.0D0/3.0D0
         DO 10 ICRD=1,3
            GGJ(ICRD,ICRD)=C11ON
 10      CONTINUE
      END IF
      RIJ5   = RIJ**5
      RIJ3   = RIJ**3
      ZR     = ZIJ * RIJ
      ZR2    = ZR*ZR
      ERFZR  = ERF(ZR)
      ZEXR   = TSQOP*ZR*EXP(-ZR2)
      TZR    = 3.0D0+2.0D0*ZR2
      C11OFF = (TZR*ZEXR-3.0D0*ERFZR)/RIJ5
      C11ON  = (ERFZR-ZEXR)/RIJ3
C     ICRD AND JCRD LOOP OVER THE X Y Z CARTESIAN INDEX
C     THESE LOOPS PERFORM A CROSS PRODUCT
      DO 115 ICRD = 1,3
         DO 120 JCRD = 1,3
            GGJ(ICRD,JCRD)=C11OFF*CRDS(ICRD)*CRDS(JCRD)
 120     CONTINUE
         GGJ(ICRD,ICRD)=GGJ(ICRD,ICRD)+C11ON
 115  CONTINUE
      END SUBROUTINE


!!!****h* Y77L/LINEQ
!!!
!!! NAME
!!!     LINEQ - linear equation routines
!!! COPYRIGHT
!!!     Prof. York's Group
!!!     Department of Chemistry
!!!     University of Minnesota
!!! AUTHOR
!!!     Timothy J. Giese
!!! CREATION DATE
!!!     2004
!!! DESCRIPTION
!!!     Solves systems of linear equations
!!! USES
!!!   INVERT/SVDINV
!!!   EIGSYS/SVDKMP
!!!   MATMUL/YSA
!!!   MATMUL/YAV
!!!   MATMUL/YSV
!!!   MATMUL/YCSA
!!!   MATMUL/TRANSP
!!!   INIT/CPYV
!!!   ERROR/I1ERR
!!!   
!!!***


      SUBROUTINE SYMLIN(A,N,B,X,DMAT,NC,C)
!!!   ****f* LINEQ/SYMLIN
!!!   
!!!   NAME
!!!   SYMLIN -- SOLVES A.X = B FOR X
!!!   USAGE
!!!   CALL SYMLIN(A,N,B,X,DMAT,NC,C)
!!!   DESCRIPTION
!!!   GIVEN SYMMETRIC MATRIX A(N,N) AND RESULT B(N),
!!!   LINEQ SOLVES VOR VECTOR X(N) UNDER THE CONSTRAINTS
!!!   DMAT(N,NC) (WHICH ARE CONSTRAINED TO VALUES C(NC))
!!!   
!!!   IF NC=0, THEN THE SOLUTION IS A^{-1}.B = X
!!!   IF THE CONSTRAINTS ARE OVER DETERMINED, THEN
!!!   AN SVD ALGORITHM IS USED.
!!!   INPUTS
!!!   DOUBLE PRECISION A(N,N),B(N),DMAT(N,NC),C(NC)
!!!   INTEGER N,NC
!!!   
!!!   OUTPUT
!!!   DOUBLE PRECISION X(N)
!!!   USES
!!!   INVERT/SVDINV
!!!   EIGSYS/SVDKMP
!!!   MATMUL/YSA
!!!   MATMUL/YAV
!!!   MATMUL/YSV
!!!   MATMUL/YCV
!!!   MATMUL/YCSA
!!!   MATMUL/TRANSP
!!!   INIT/CPYV
!!!   ERROR/I1ERR
!!!   ***
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INTEGER N,NC,NFREE
      DIMENSION A(N,N),B(N),X(N)
      DIMENSION C(NC)
      DIMENSION DMAT(N,NC)
c---------------------------------
      DIMENSION U(N,N),W(N),VT(N,N),V(N,N)
      DIMENSION AINV(N,N)
      DIMENSION DNN(N,N)
C----------------------------
      DIMENSION AC(NC,NC),AIB(N),ACAIB(NC)
      DOUBLE PRECISION LAMBDA,AIDV,DV
      DIMENSION LAMBDA(NC)
      DOUBLE PRECISION CONDEN,CONNUM
      DIMENSION AIDV(N),DV(N)
C----------------------------
      INTEGER I,J


C     RETURN IF INPUT IS STUPID
      IF ( N .LT. 1 ) THEN
         CALL I1ERR("LINEQ.src77","SLEQ0",
     1        "IF ( N .LT. 1 ) THEN",
     1        "ARRAY SIZE INVALID",
     1        .TRUE.,.TRUE.,
     1        "N",N)
      END IF
      IF ( NC .LT. 0 ) THEN
         CALL I1ERR("LINEQ.src77","SLEQ0",
     1        "IF ( NC .LT. 0 ) THEN",
     1        "NUMBER OF CONSTRAINTS INVALID",
     1        .TRUE.,.TRUE.,
     1        "NC",NC)
      END IF

C     RETURN THE SIMPLE ANSWER IF THERE ARE NO CONSTRAINTS
      IF ( NC.EQ.0 ) THEN
C     CALCULATE A INVERSE
         CALL SYMINV(A,N,AINV)
         CALL YSA(N,AINV,B,X)
         RETURN
C     RETURN A DIFFERENT SIMPLE ANSWER IF THERE IS ONLY 1 CONSTRAINT
      ELSE IF ( NC.EQ.1 ) THEN
         DO 5 I=1,N
            DV(I) = DMAT(I,1)
 5       CONTINUE
         CALL SYMINV(A,N,AINV)
         CALL YSV(N,AINV,DV,AIDV)
         CALL YSV(N,AINV,B,AIB)
         CALL DOTPRD(DV,N,AIDV,CONDEN)
         CALL DOTPRD(DV,N,AIB,CONNUM)
         LAMBDA(1) = -CONNUM/CONDEN
         CALL ADDVV(LAMBDA(1),AIDV,N,1.0D0,AIB,X)
         RETURN
      END IF






C     CALCULATE THE EIGENVALUES/VECTORS OF THE CONSTRAINT MATRIX
C     COPY THE FIRST NC COLUMNS OF DMAT INTO DNN
      DO 10 I=1,N
         DO 20 J=1,NC
            DNN(I,J) = DMAT(I,J)
 20      CONTINUE
         DO 25 J=NC+1,N
            DNN(I,J) = 0.0000D0
 25      CONTINUE
 10   CONTINUE

      CALL SVDKMP(N,DNN,N, U,W,VT)
      CALL TRANSP(N,VT,N, V)

C     CALL PTV(W,N,N,"W",6,.FALSE.)

C     COUNT THE NUMBER OF REDUNDENT CONSTRAINTS
      J=0
      DO 30 I=1,N
         IF ( W(I) .LT. 1.0D-8 ) J=J+1
 30   CONTINUE
      NFREE = J
      IF ( NFREE.EQ.0 ) THEN
C     WE DON'T DO ANY FANCY SVD STUFF
C     AC = MATMUL(TRANSPOSE(DMAT),MATMUL(AINV,DMAT))
         CALL SYMINV(A,N,AINV)
C     AC = SVDINVERSE(AC)
         CALL YCSA(N,AINV,DMAT,NC , AC)
C     LAMBDA = MATMUL(AC,C-MATMUL(TRANSPOSE(DMAT),MATMUL(AINV,B)))
         CALL SVDINV(NC,AC,NC,  AC)
         CALL YSV( N,AINV,B, AIB )
         CALL YCV(NC,DMAT,N,AIB, ACAIB)
         DO 40 I=1,NC
            ACAIB(I) = C(I) - ACAIB(I)
 40      CONTINUE
         CALL YAV(NC,AC,NC,ACAIB, LAMBDA)
C     X = MATMUL(AINV,B+MATMUL(DMAT,LAMBDA))
         CALL YAV(N,DMAT,NC,LAMBDA, AIB)
         DO 50 I=1,N
            AIB(I) = AIB(I) + B(I)
 50      CONTINUE
         CALL YSV(N,AINV,AIB, X)
         RETURN
      ELSE
C     DO THE REST WITHIN THE DRIVER
         CALL LINSVD(N,NC,NFREE,A,B,X,U,W,V,C)
      END IF
      END SUBROUTINE





      SUBROUTINE LINSVD(N,NC,NFREE,A,B,X,U,W,V,C)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INTEGER N,NC,NFREE
      DIMENSION A(N,N),B(N),X(N)
      DIMENSION C(NC)
      DIMENSION U(N,N),W(N),V(N,N)
C---------------------------------------------
c      DIMENSION LAMBDA(NC)
      DIMENSION CR(N,NFREE)
      DIMENSION CB(NC)
      DIMENSION CA(N,NC)
      DIMENSION CT(N)
      DIMENSION AP(NFREE,NFREE)
      DIMENSION BP(NFREE),XP(NFREE)
      INTEGER I,J,K,L
      DIMENSION ACT(N)

      CALL CPYV(C,NC,CB)
      DO 10 I=1,N
         L=0
         DO 20 J=N-NFREE+1,N
            L=L+1
            CR(I,L) = 0.0D0
            DO 30 K=1,N
               IF(W(K).LT.1.0D-8) THEN
                  CR(I,L)=CR(I,L)+U(I,K)*V(J,K)
               END IF
 30         CONTINUE
 20      CONTINUE
 10   CONTINUE

      DO 50 I=1,N
         DO 60 J=1,NC
            CA(I,J) = 0.0D0
            DO 70 K=1,N
               IF(W(K).GT.1.0D-8) THEN
                  CA(I,J)=CA(I,J)+U(I,K)*V(J,K)/W(K)
               END IF
 70         CONTINUE
 60      CONTINUE
 50   CONTINUE

C     CT = MATMUL(CA,CB)
      CALL YAV(N,CA,NC,CB, CT)
C     AP = MATMUL(TRANSPOSE(CR),MATMUL(A,CR))
      CALL YCSA(N,A,CR,NFREE, AP)
C     BP = MATMUL(TRANSPOSE(CR),
C     (B-MATMUL(A,CT)))
      CALL YSV(N,A,CT, ACT)
      DO 80 I=1,N
         ACT(I) = B(I) - ACT(I)
 80   CONTINUE
      CALL YCV(NFREE,CR,N,ACT, BP)
C     XP = MATMUL(SVDINV(AP),BP)
      CALL SVDINV(NFREE,AP,NFREE,AP)
      CALL YAV(NFREE,AP,NFREE,BP,  XP)
C     C = MATMUL(CR,XP)+CT
      CALL YAV(N,CR,NFREE,XP, X)
      DO 90 I=1,N
         X(I)=X(I)+CT(I)
 90   CONTINUE
      END SUBROUTINE
!!!****h* Y77L/MATMUL
!!!
!!! NAME
!!!     MATMUL - matrix multiply routines acting as a front-end to BLAS
!!! COPYRIGHT
!!!     Prof. York's Group
!!!     Department of Chemistry
!!!     University of Minnesota
!!! AUTHOR
!!!     Timothy J. Giese
!!! CREATION DATE
!!!     2004
!!! DESCRIPTION
!!!     matrix multiply routines
!!!     primarily acting as a front-end to blas
!!!     BLAS (LEVELS 1,2,3) LIBRARY
!!!    ***************************************
!!!    *The following describes the notation.*
!!!    ***************************************
!!!     With exception to TRANSP and DOTPRD, all routines start 
!!!     with "Y" to avoid naming clashes with variables.
!!!     The output variable is always the last variable.
!!!     The input variables and dimensions are related to their 
!!!     size (and operation)***.
!!!     The dimension of the output variable is the first and 
!!!     last dimension in the list of input variables.
!!!
!!!     FOR EXAMPLE, consider the following matrix-matrix 
!!!     multiplication
!!!        Z    =    A    .    B
!!!      M x O     M x N     N x O
!!!     Notice that the last dimension of A and the first 
!!!     dimension of B are the same, so that dimension appears 
!!!     twice... but it shouldn't NEED to.  Also note that 
!!!     the dimensions of Z correspond to the first dimension 
!!!     of A and the last dimension of B, therefore, there is 
!!!     no need to specify the dimensions of Z explicitly.
!!!
!!!     This example corresponds to the routine
!!!     CALL YAB( M , A , N , B , O , Z )
!!!     By looking at the arguments, we see that the output is 
!!!     Z and has dimensions M x O and the dimensions of the 
!!!     input arrays are "sandwiched" between their dimensions,
!!!     e.g., A is sandwiched by MxN and B is sandwiched 
!!!     between NxO
!!!
!!!     The routines are named by FORM and operation.
!!!         A and B correspond to matricies
!!!         V corresponds to a vector
!!!     That is how the FORM enters into the name.
!!!         C and D corresponds to the matricies A and B, 
!!!         respectively, but acts as a flag to transpose.
!!!     Therefore replacement of A with C and/or B with D is 
!!!     how OPERATION enters into the name. For clarity, 
!!!         C = TRANSP(A) and D = TRANSP(B)
!!!
!!!     ***Note: The DIMENSIONS correspond to the size AND 
!!!     OPERATION.  Meaning, the dimensions sandwiching a matrix
!!!     are those AFTER the operation is performed.
!!!
!!!     FOR EXAMPLE, consider the followinf matrix-matrix 
!!!     multiplication
!!!        Z   = (A)t  .  B
!!!      M x O (N x M)t N x O  <-- Before transpose operation
!!!      M x O  M x N   N x O  <-- After transpose operation
!!!     This example corresponds to
!!!     CALL YCB( M , A , N , B , O , Z )
!!!     Note that the dimensions are those AFTER the 
!!!     operation A->C
!!!
!!!     **Think of it like this** If the procedure name replaces 
!!!     A by C, then it means that A is being input, but needs 
!!!     to be transposed in order to correspond to the dimensions 
!!!     listed in the argument list.
!!!
!!!     The outer dimension of vectors are 1, so they are not 
!!!     included.
!!!     SCALAR   =  Ut    .  A   .    V
!!!      1 x 1     1 x N   N x M    M x 1
!!!     CALL VAV( Ut , N , A , M , V , SCALAR )
!!!
!!!     The trailing dimension of a symmetric matrix is excluded
!!!     since it is redundent, and the leading value is also the 
!!!     first dimension of what comes after it - since it must 
!!!     also be the same.
!!!        SV   =    S    .    V
!!!       N x 1    N x N     N x 1
!!!     CALL YSV( N , S , V , SV )
!!!     N only appears before S since the last dimension of S is 
!!!     excluded.  Since S is symmetric, N is also the leading 
!!!     dimension of what comes after S, which is V. 
!!!     
!!! USES
!!!    BLAS/DGEMM
!!!    BLAS/DSYMM
!!!    BLAS/DGEMV
!!!    BLAS/DSYMV
!!!    INIT/CPYV
!!!   ERROR/I1ERR
!!!
!!! TODO
!!!    THIS MODULE NEEDS EXTENSIVE TESTING. PLEASE MARK OFF THE TODO'S WHEN TESTED.    
!!!***
 
 





      SUBROUTINE TRANSP(M,A,N,AT)
!!!****f* MATMUL/TRANSP
!!!
!!! NAME
!!!   TRANSP -- TRANSPOSE(A)
!!! USAGE
!!!    CALL TRANSP(M,A,N,AT)
!!! DESCRIPTION
!!!    STORES THE TRANSPOSE OF A IN AT
!!! INPUTS
!!!     DOUBLE PRECISION A(N,M)
!!!     INTEGER M,N
!!!
!!! OUTPUT
!!!     DOUBLE PRECISION AT(M,N)
!!! NOTES
!!!     VERIFIED 08/04
!!!***
      INTEGER M,N,I,J
      DOUBLE PRECISION A,AT
      DIMENSION A(N,M), AT(M,N)
      IF ( N .LT. 1 ) THEN
         CALL I1ERR("MATMUL.src77","TRANSP",
     1        "IF ( N .LT. 1 ) THEN",
     2        "THE LEADING MATRIX DIMENSION IS INVALID",
     3        .TRUE.,.TRUE.,"N",N)
      END IF
      IF ( M .LT. 1 ) THEN
         CALL I1ERR("MATMUL.src77","TRANSP",
     1        "IF ( M .LT. 1 ) THEN",
     2        "THE TRAILING MATRIX DIMENSION IS INVALID",
     3        .TRUE.,.TRUE.,"M",M)
      END IF
      DO 1 I=1,M
         DO 2 J=1,N
            AT(I,J) = A(J,I)
 2       CONTINUE
 1    CONTINUE
      END SUBROUTINE





 
 
      SUBROUTINE DOTPRD(U,N,V,UV)
!!!****f* MATMUL/DOTPRD
!!!
!!! NAME
!!!   DOTPRD -- DOT_PRODUCT(U,V)
!!! USAGE
!!!    CALL DOTPRD(U,N,V,UV)
!!! DESCRIPTION
!!!   UV = Ut . V
!!! INPUTS
!!!     DOUBLE PRECISION U(N), V(N)
!!!     INTEGER N
!!!
!!! OUTPUT
!!!     DOUBLE PRECISION UV
!!! NOTES
!!!     VERIFIED 08/04
!!!***
      INTEGER I,N
      DOUBLE PRECISION U, V, UV
      DIMENSION U(N), V(N)
      IF ( N .LT. 1 ) THEN
         CALL I1ERR("MATMUL.src77","DOTPRD",
     1        "IF ( N .LT. 1 ) THEN",
     2        "THE DIMENSIONS ARE INVALID",
     3        .TRUE.,.TRUE.,"N",N)
      END IF
      UV = 0.00000000D0
      DO 1 I=1,N
         UV = UV + U(I)*V(I)
 1    CONTINUE
      END SUBROUTINE


      FUNCTION VLEN(V,N)
      INTEGER N,I
      DOUBLE PRECISION V,VLEN
      DIMENSION V(N)

      VLEN = 0.0D0
      DO 10 I=1,N
         VLEN = VLEN + V(I)**2
 10   CONTINUE
      VLEN = SQRT(VLEN)
      END FUNCTION

      FUNCTION VIJLEN(U,N,V)
      INTEGER N,I
      DOUBLE PRECISION U,V,VIJLEN
      DIMENSION U(N),V(N)
      VIJLEN=0.0D0
      DO 10 I=1,N
         VIJLEN = VIJLEN + (U(I)-V(I))**2
 10   CONTINUE
      VIJLEN = SQRT(VIJLEN)
      END FUNCTION


      SUBROUTINE SUMV(V,N,SM)
!!!****f* MATMUL/SUMV
!!!
!!! NAME
!!!   SUMV -- SUM(V)
!!! USAGE
!!!    CALL SUMV(V,N,SM)
!!! DESCRIPTION
!!!   SM = 1 . V
!!! INPUTS
!!!     DOUBLE PRECISION V(N)
!!!     INTEGER N
!!!
!!! OUTPUT
!!!     DOUBLE PRECISION SM
!!! NOTES
!!!     VERIFIED 08/04
!!!***
      INTEGER I,N
      DOUBLE PRECISION V, SM
      DIMENSION V(N)
      IF ( N .LT. 1 ) THEN
         CALL I1ERR("MATMUL.src77","SUMV",
     1        "IF ( N .LT. 1 ) THEN",
     2        "THE DIMENSIONS ARE INVALID",
     3        .TRUE.,.TRUE.,"N",N)
      END IF
      SM = 0.00000000D0
      DO 1 I=1,N
         SM = SM + V(I)
 1    CONTINUE
      END SUBROUTINE



      SUBROUTINE SCLV(PREFV,V,N,W)
!!!****f* MATMUL/SCLV
!!!
!!! NAME
!!!   SCLV -- PREFV*V(1:N)
!!! USAGE
!!!    CALL SCLV(PREFV,V,N,W)
!!! DESCRIPTION
!!!   W(1:N) = PREFV*V(1:N)
!!! INPUTS
!!!     DOUBLE PRECISION V(N)
!!!     INTEGER N
!!!     DOUBLE PRECISION PREFV
!!!
!!! OUTPUT
!!!     DOUBLE PRECISION W(N)
!!! NOTES
!!!     VERIFIED 08/04
!!!***
      INTEGER I,N
      DOUBLE PRECISION V,W,PREFV
      DIMENSION V(N),W(N)
      IF ( N .LT. 1 ) THEN
         CALL I1ERR("MATMUL.src77","SCLV",
     1        "IF ( N .LT. 1 ) THEN",
     2        "THE DIMENSIONS ARE INVALID",
     3        .TRUE.,.TRUE.,"N",N)
      END IF
      DO 1 I=1,N
         W(I) = PREFV*V(I)
 1    CONTINUE
      END SUBROUTINE




      SUBROUTINE ADDVV(PREFU,U,N,PREFV,V,W)
!!!****f* MATMUL/ADDVV
!!!
!!! NAME
!!!   ADDVV -- PREFU*U(1:N) + PREFV*V(1:N)
!!! USAGE
!!!    CALL ADDVV(PREFU,U,N,PREFV,V,W)
!!! DESCRIPTION
!!!   W(1:N) = PREFU*U(1:N) + PREFV*V(1:N)
!!! INPUTS
!!!     DOUBLE PRECISION U(N),V(N)
!!!     INTEGER N
!!!     DOUBLE PRECISION PREFU,PREFV
!!!
!!! OUTPUT
!!!     DOUBLE PRECISION W(N)
!!! NOTES
!!!     VERIFIED 08/04
!!!***
      INTEGER I,N
      DOUBLE PRECISION U,V,W,PREFU,PREFV
      DIMENSION U(N),V(N),W(N)
      IF ( N .LT. 1 ) THEN
         CALL I1ERR("MATMUL.src77","ADDVV",
     1        "IF ( N .LT. 1 ) THEN",
     2        "THE DIMENSIONS ARE INVALID",
     3        .TRUE.,.TRUE.,"N",N)
      END IF
      DO 1 I=1,N
         W(I) = PREFU*U(I)+PREFV*V(I)
 1    CONTINUE
      END SUBROUTINE





      SUBROUTINE SUMABV(V,N,SM)
!!!****f* MATMUL/SUMABV
!!!
!!! NAME
!!!   SUMABV -- SUM(ABS(V))
!!! USAGE
!!!    CALL SUMABV(V,N,SM)
!!! DESCRIPTION
!!!   SM = 1 . ABS(V)
!!! INPUTS
!!!     DOUBLE PRECISION V(N)
!!!     INTEGER N
!!!
!!! OUTPUT
!!!     DOUBLE PRECISION SM
!!! NOTES
!!!     VERIFIED 08/04
!!!***
      INTEGER I,N
      DOUBLE PRECISION V, SM
      DIMENSION V(N)
      IF ( N .LT. 1 ) THEN
         CALL I1ERR("MATMUL.src77","SUMABV",
     1        "IF ( N .LT. 1 ) THEN",
     2        "THE DIMENSIONS ARE INVALID",
     3        .TRUE.,.TRUE.,"N",N)
      END IF
      SM = 0.00000000D0
      DO 1 I=1,N
         SM = SM + ABS(V(I))
 1    CONTINUE
      END SUBROUTINE




      SUBROUTINE YAV(M,A,N,V,ADV)
!!!****f* MATMUL/YAV
!!!
!!! NAME
!!!   YAV -- MATMUL(A,V) 
!!! USAGE
!!!    CALL YAV(M,A,N,V,ADV)
!!! DESCRIPTION
!!!    COMPUTES VECTOR ADV FROM MATRIX A AND VECTOR V
!!! INPUTS
!!!     DOUBLE PRECISION A(M,N), V(N)
!!!     INTEGER M,N
!!!
!!! OUTPUT
!!!     DOUBLE PRECISION ADV(M)
!!! USES
!!!     BLAS/DGEMV
!!! NOTES
!!!     VERIFIED 08/04
!!!***
      INTEGER M,N
      DOUBLE PRECISION A,V,ADV
      DIMENSION A(M,N),V(N),ADV(M)
      IF ( N .LT. 1 ) THEN
         CALL I1ERR("MATMUL.src77","YAV",
     1        "IF ( N .LT. 1 ) THEN",
     2        "THE LEADING MATRIX DIMENSION IS INVALID",
     3        .TRUE.,.TRUE.,"N",N)
      END IF
      IF ( M .LT. 1 ) THEN
         CALL I1ERR("MATMUL.src77","YAV",
     1        "IF ( M .LT. 1 ) THEN",
     2        "THE SECOND MATRIX DIMENSION IS INVALID",
     3        .TRUE.,.TRUE.,"M",M)
      END IF
      CALL DGEMV("N",M,N,1.D0,A,M,V,1,0.D0,ADV,1)
      END SUBROUTINE




      SUBROUTINE YCV(M,A,N,V,CDV)
!!!****f* MATMUL/YCV
!!!
!!! NAME
!!!   YCV -- MATMUL(TRANSPOSE(A),V)
!!! USAGE
!!!    CALL YCV(M,A,N,V,CDV)
!!! DESCRIPTION
!!!    COMPUTES VECTOR CDV FROM THE TRANSPOSE OF MATRIX A
!!!    AND VECTOR V
!!! INPUTS
!!!     DOUBLE PRECISION A(N,M),V(M)
!!!     INTEGER N,M
!!!
!!! OUTPUT
!!!     DOUBLE PRECISION CDV(N)
!!! USES
!!!     BLAS/DGEMV
!!! NOTES
!!!     VERIFIED 08/04
!!!***
      INTEGER M,N
      DOUBLE PRECISION A,V,CDV
      DIMENSION A(N,M),V(N),CDV(M)
      IF ( N .LT. 1 ) THEN
         CALL I1ERR("MATMUL.src77","YCV",
     1        "IF ( N .LT. 1 ) THEN",
     2        "THE LEADING MATRIX DIMENSION IS INVALID",
     3        .TRUE.,.TRUE.,"N",N)
      END IF
      IF ( M .LT. 1 ) THEN
         CALL I1ERR("MATMUL.src77","YCV",
     1        "IF ( M .LT. 1 ) THEN",
     2        "THE SECOND MATRIX DIMENSION IS INVALID",
     3        .TRUE.,.TRUE.,"M",M)
      END IF
      CALL DGEMV("T",N,M,1.D0,A,N,V,1,0.D0,CDV,1)
      END SUBROUTINE


      SUBROUTINE YSV(N,A,V,SDV)
!!!****f* MATMUL/YSV
!!!
!!! NAME
!!!   YSV -- MATMUL(S,V) (where S is a SYMMETRIC matrix)
!!! USAGE
!!!    CALL YSV(N,A,V,SDV)
!!! DESCRIPTION
!!!    COMPUTES SDV FROM SYMMETRIC MATRIX S AND VECTOR V
!!! INPUTS
!!!     DOUBLE PRECISION S(N,N),V(N)
!!!     INTEGER N
!!!
!!! OUTPUT
!!!     DOUBLE PRECISION SDV(N)
!!! USES
!!!     BLAS/DSYMV
!!! NOTES
!!!     VERIFIED 08/04
!!!***
      INTEGER N
      DOUBLE PRECISION A,V,SDV,TMP
      DIMENSION A(N,N),V(N),SDV(N),TMP(N)
      IF ( N .LT. 1 ) THEN
         CALL I1ERR("MATMUL.src77","YSV",
     1        "IF ( N .LT. 1 ) THEN",
     2        "THE VECTOR AND MATRIX DIMENSIONS ARE INVALID",
     3        .TRUE.,.TRUE.,"N",N)
      END IF
      CALL DSYMV("U",N,1.D0,A,N,V,1,0.D0,TMP,1)
      CALL CPYV(TMP,N,SDV)
      END SUBROUTINE





      SUBROUTINE YAB(M,A,N,B,O,ADB)
!!!****f* MATMUL/YAB
!!!
!!! NAME
!!!   YAB -- MATMUL(A,B) 
!!! USAGE
!!!    CALL YAB(M,A,N,B,O,ADB)
!!! DESCRIPTION
!!!    COMPUTES MATRIX ADB FROM MATRICIES A AND B
!!! INPUTS
!!!     DOUBLE PRECISION A(M,N),B(N,O)
!!!     INTEGER M,N,O
!!!
!!! OUTPUT
!!!     DOUBLE PRECISION ADB(M,O)
!!! USES
!!!     BLAS/DGEMM
!!! NOTES
!!!     VERIFIED 08/04
!!!***
      INTEGER M,N,O
      DOUBLE PRECISION A,B,ADB
      DIMENSION A(M,N),B(N,O),ADB(M,O)
      IF ( M .LT. 1 ) THEN
         CALL I1ERR("MATMUL.src77","YAB",
     1        "IF ( M .LT. 1 ) THEN",
     2        "THE LEADING DIMENSION OF A IS INVALID",
     3        .TRUE.,.TRUE.,"M",M)
      END IF
      IF ( N .LT. 1 ) THEN
         CALL I1ERR("MATMUL.src77","YAB",
     1        "IF ( N .LT. 1 ) THEN",
     2        "THE LEADING DIMENSION OF B IS INVALID",
     3        .TRUE.,.TRUE.,"N",N)
      END IF
      IF ( O .LT. 1 ) THEN
         CALL I1ERR("MATMUL.src77","YAB",
     1        "IF ( O .LT. 1 ) THEN",
     2        "THE LAST DIMENSION OF B IS INVALID",
     3        .TRUE.,.TRUE.,"O",O)
      END IF

      CALL DGEMM( "N","N",
C     rows of ADB, cols of ADB, dimension shared by A and B
     1     M,O,N,
     2     1.0D0,
     3     A,M,
     4     B,N,
     5     0.0D0,
     6     ADB,M)
      END SUBROUTINE



      SUBROUTINE YCB(M,A,N,B,O,CDB)
!!!****f* MATMUL/YCB
!!!
!!! NAME
!!!   YCB -- MATMUL(TRANSPOSE(A),B) 
!!! USAGE
!!!    CALL YCB(M,A,N,B,O,CDB)
!!! DESCRIPTION
!!!    COMPUTES MATRIX CDB FROM MATRIX TRANSPOSE(A) AND MATRIX B
!!! INPUTS
!!!     DOUBLE PRECISION A(N,M),B(N,O)
!!!     INTEGER M,N,O
!!!
!!! OUTPUT
!!!     DOUBLE PRECISION CDB(M,O)
!!! USES
!!!     BLAS/DGEMM
!!! NOTES
!!!     VERIFIED 08/04
!!!***
      INTEGER M,N,O
      DOUBLE PRECISION A,B,CDB
      DIMENSION A(N,M),B(N,O),CDB(M,O)
      IF ( M .LT. 1 ) THEN
         CALL I1ERR("MATMUL.src77","YCB",
     1        "IF ( M .LT. 1 ) THEN",
     2        "THE LAST DIMENSION OF A IS INVALID",
     3        .TRUE.,.TRUE.,"M",M)
      END IF
      IF ( N .LT. 1 ) THEN
         CALL I1ERR("MATMUL.src77","YCB",
     1        "IF ( N .LT. 1 ) THEN",
     2        "THE LEADING DIMENSION OF A IS INVALID",
     3        .TRUE.,.TRUE.,"N",N)
      END IF
      IF ( O .LT. 1 ) THEN
         CALL I1ERR("MATMUL.src77","YCB",
     1        "IF ( O .LT. 1 ) THEN",
     2        "THE LAST DIMENSION OF B IS INVALID",
     3        .TRUE.,.TRUE.,"O",O)
      END IF
      CALL DGEMM("T","N",M,O,N,1.D0,A,N,B,N,0.D0,CDB,M)
      END SUBROUTINE


      SUBROUTINE YAD(M,A,N,B,O,ADD)
!!!****f* MATMUL/YAD
!!!
!!! NAME
!!!   YAD -- MATMUL(A,TRANSPOSE(B)) 
!!! USAGE
!!!    CALL YAD(M,A,N,B,O,ADD)
!!! DESCRIPTION
!!!    COMPUTES MATRIX ADD FROM MATRIX A AND MATRIX TRANSPOSE(B)
!!! INPUTS
!!!     DOUBLE PRECISION A(M,N),B(O,N)
!!!     INTEGER M,N,O
!!!
!!! OUTPUT
!!!     DOUBLE PRECISION ADD(M,O)
!!! USES
!!!     BLAS/DGEMM
!!! NOTES
!!!     VERIFIED 08/04
!!!***
      INTEGER M,N,O
      DOUBLE PRECISION A,B,ADD
      DIMENSION A(M,N),B(O,N),ADD(M,O)
      IF ( M .LT. 1 ) THEN
         CALL I1ERR("MATMUL.src77","YAD",
     1        "IF ( M .LT. 1 ) THEN",
     2        "THE LEADING DIMENSION OF A IS INVALID",
     3        .TRUE.,.TRUE.,"M",M)
      END IF
      IF ( N .LT. 1 ) THEN
         CALL I1ERR("MATMUL.src77","YAD",
     1        "IF ( N .LT. 1 ) THEN",
     2        "THE LAST DIMENSION OF B IS INVALID",
     3        .TRUE.,.TRUE.,"N",N)
      END IF
      IF ( O .LT. 1 ) THEN
         CALL I1ERR("MATMUL.src77","YAD",
     1        "IF ( O .LT. 1 ) THEN",
     2        "THE FIRST DIMENSION OF B IS INVALID",
     3        .TRUE.,.TRUE.,"O",O)
      END IF
      CALL DGEMM("N","T",M,O,N,1.D0,A,M,B,O,0.D0,ADD,M)
      END SUBROUTINE



      SUBROUTINE YCD(M,A,N,B,O,CDD)
!!!****f* MATMUL/YCD
!!!
!!! NAME
!!!   YCD -- MATMUL(TRANSPOSE(A),TRANSPOSE(B)) 
!!! USAGE
!!!    CALL YCD(M,A,N,B,O,CDD)
!!! DESCRIPTION
!!!    COMPUTES MATRIX CDD FROM MATRIX TRANSPOSE(A) AND MATRIX TRANSPOSE(B)
!!! INPUTS
!!!     DOUBLE PRECISION A(N,M),B(O,N)
!!!     INTEGER M,N,O
!!!
!!! OUTPUT
!!!     DOUBLE PRECISION CDD(M,O)
!!! USES
!!!     BLAS/DGEMM
!!! NOTES
!!!     VERIFIED 08/04
!!!***
      INTEGER M,N,O
      DOUBLE PRECISION A,B,CDD
      DIMENSION A(N,M),B(O,N),CDD(M,O)
      IF ( M .LT. 1 ) THEN
         CALL I1ERR("MATMUL.src77","YCD",
     1        "IF ( M .LT. 1 ) THEN",
     2        "THE LAST DIMENSION OF A IS INVALID",
     3        .TRUE.,.TRUE.,"M",M)
      END IF
      IF ( N .LT. 1 ) THEN
         CALL I1ERR("MATMUL.src77","YCD",
     1        "IF ( N .LT. 1 ) THEN",
     2        "THE LAST DIMENSION OF B IS INVALID",
     3        .TRUE.,.TRUE.,"N",N)
      END IF
      IF ( O .LT. 1 ) THEN
         CALL I1ERR("MATMUL.src77","YCD",
     1        "IF ( O .LT. 1 ) THEN",
     2        "THE FIRST DIMENSION OF B IS INVALID",
     3        .TRUE.,.TRUE.,"O",O)
      END IF
      CALL DGEMM("T","T",M,O,N,1.D0,A,N,B,O,0.D0,CDD,M)
      END SUBROUTINE



      SUBROUTINE YSA(M,S,A,O,SDA)
!!!****f* MATMUL/YSA
!!!
!!! NAME
!!!   YSA -- MATMUL(S,A)
!!! USAGE
!!!    CALL YSA(M,S,A,O,SDA)
!!! DESCRIPTION
!!!    CALCULATES MATRIX SDA FROM MATMUL(S,A), WHERE S IS A SYMMTRIC MATRIX
!!! INPUTS
!!!     DOUBLE PRECISION S(M,M),A(M,O)
!!!     INTEGER M,O
!!!
!!! OUTPUT
!!!     DOUBLE PRECISION SDA(M,O)
!!! USES
!!!     BLAS/DSYMM
!!! NOTES
!!!     VERIFIED 08/04
!!!***
      INTEGER M,O
      DOUBLE PRECISION S,A,SDA
      DIMENSION S(M,M),A(M,O),SDA(M,O)
      IF ( M .LT. 1 ) THEN
         CALL I1ERR("MATMUL.src77","YSA",
     1        "IF ( M .LT. 1 ) THEN",
     2        "THE FIRST DIMENSION OF A IS INVALID",
     3        .TRUE.,.TRUE.,"M",M)
      END IF
      IF ( O .LT. 1 ) THEN
         CALL I1ERR("MATMUL.src77","YSA",
     1        "IF ( O .LT. 1 ) THEN",
     2        "THE LAST DIMENSION OF A IS INVALID",
     3        .TRUE.,.TRUE.,"O",O)
      END IF
      CALL DSYMM("L","U",M,O,1.0D0,S,M,A,M,0.0D0,SDA,M)
      END SUBROUTINE


      SUBROUTINE YSC(M,S,A,O,SDC)
!!!****f* MATMUL/YSC
!!!
!!! NAME
!!!   YSC -- MATMUL(S,TRANSPOSE(A))
!!! USAGE
!!!    CALL YSC(M,S,A,O,SDC)
!!! DESCRIPTION
!!!    CALCULATES MATRIX SDC FROM MATMUL(S,TRANSPOSE(A)), WHERE S IS A SYMMTRIC MATRIX
!!!
!!! INPUTS
!!!     DOUBLE PRECISION S(M,M),A(O,M)
!!!     INTEGER M,O
!!!
!!! OUTPUT
!!!     DOUBLE PRECISION SDC(M,O)
!!! USES
!!!     MATMUL/TRANSP
!!!     BLAS/DSYMM
!!! NOTES
!!!     VERIFIED 08/04
!!!***
      INTEGER M,O
      DOUBLE PRECISION S,A,AT,SDC
      DIMENSION S(M,M),A(O,M),AT(M,O),SDC(M,O)
      IF ( M .LT. 1 ) THEN
         CALL I1ERR("MATMUL.src77","YSC",
     1        "IF ( M .LT. 1 ) THEN",
     2        "THE FIRST DIMENSION OF A IS INVALID",
     3        .TRUE.,.TRUE.,"M",M)
      END IF
      IF ( O .LT. 1 ) THEN
         CALL I1ERR("MATMUL.src77","YSC",
     1        "IF ( O .LT. 1 ) THEN",
     2        "THE LAST DIMENSION OF A IS INVALID",
     3        .TRUE.,.TRUE.,"O",O)
      END IF
      CALL TRANSP(M,A,O,AT)
      CALL DSYMM("L","U",M,O,1.0D0,S,M,AT,M,0.0D0,SDC,M)
      END SUBROUTINE



      SUBROUTINE YCSA(M,S,A,O,CSA)
!!!****f* MATMUL/YCSA
!!!
!!! NAME
!!!   YCSA -- MATMUL(TRANSPOSE(A),MATMUL(S,A)) 
!!! USAGE
!!!    CALL YCSA(M,S,A,O,CSA)
!!! DESCRIPTION
!!!    CALCULATES MATRIX CSA FROM MATMUL(TRANSPOSE(A),MATMUL(S,A)),
!!!    WHERE S IS SYMMETRIC
!!! INPUTS
!!!     DOUBLE PRECISION S(M,M),A(M,O)
!!!     INTEGER M,O
!!! OUTPUT
!!!     DOUBLE PRECISION CSA(O,O)
!!! NOTES
!!!     VERIFIED 08/04
!!!     THE ELEMENTS M AND O ARE THE DIMENSIONS OF MATMUL(S,A)
!!!     THE DIMENSIONS OF CSA, ARE THE LAST ELEMENT, I.E., CSA(O,O)
!!!***
      INTEGER M,O
      DOUBLE PRECISION S,A,SDA,CSA
      DIMENSION S(M,M),A(M,O),SDA(M,O),CSA(O,O)
      IF ( M .LT. 1 ) THEN
         CALL I1ERR("MATMUL.src77","YCSA",
     1        "IF ( M .LT. 1 ) THEN",
     2        "THE FIRST DIMENSION OF A IS INVALID",
     3        .TRUE.,.TRUE.,"M",M)
      END IF
      IF ( O .LT. 1 ) THEN
         CALL I1ERR("MATMUL.src77","YCSA",
     1        "IF ( O .LT. 1 ) THEN",
     2        "THE LAST DIMENSION OF A IS INVALID",
     3        .TRUE.,.TRUE.,"O",O)
      END IF
      CALL YSA(M,S,A,O,SDA)
      CALL YCB(O,A,M,SDA,O,CSA)
      END SUBROUTINE






      SUBROUTINE YCBA(M,B,A,O,CBA)
!!!****f* MATMUL/YCBA
!!!
!!! NAME
!!!   YCBA -- MATMUL(TRANSPOSE(A),MATMUL(B,A)) 
!!! USAGE
!!!    CALL YCBA(M,B,N,A,O,CBA)
!!! DESCRIPTION
!!!    CALCULATES MATRIX CBA FROM MATMUL(TRANSPOSE(A),MATMUL(B,A)),
!!!    WHERE B IS A SQUARE (NOT NECESSARILY SYMMETRIC) MATRIX
!!! INPUTS
!!!     DOUBLE PRECISION B(M,M),A(M,O)
!!!     INTEGER M,O
!!! OUTPUT
!!!     DOUBLE PRECISION CBA(O,O)
!!! NOTES
!!!     THE ELEMENTS M AND O ARE THE DIMENSIONS OF MATMUL(B,A)
!!!     THE DIMENSIONS OF CBA, ARE THE LAST ELEMENT, I.E., CBA(O,O)
!!!***
      INTEGER M,O
      DOUBLE PRECISION B,A,BDA,CBA
      DIMENSION B(M,M),A(M,O),BDA(M,O),CBA(O,O)
      IF ( M .LT. 1 ) THEN
         CALL I1ERR("MATMUL.src77","YCBA",
     1        "IF ( M .LT. 1 ) THEN",
     2        "THE FIRST DIMENSION OF B IS INVALID",
     3        .TRUE.,.TRUE.,"M",M)
      END IF
      IF ( O .LT. 1 ) THEN
         CALL I1ERR("MATMUL.src77","YCBA",
     1        "IF ( O .LT. 1 ) THEN",
     2        "THE LAST DIMENSION OF B IS INVALID",
     3        .TRUE.,.TRUE.,"O",O)
      END IF
      CALL YAB(M,B,M,A,O,BDA)
      CALL YCB(O,A,M,BDA,O,CBA)
      END SUBROUTINE



      SUBROUTINE YABC(M,B,A,O,ABC)
!!!****f* MATMUL/YABC
!!!
!!! NAME
!!!   YCBA -- MATMUL(A,MATMUL(B,TRANSPOSE(A))) 
!!! USAGE
!!!    CALL YABC(M,B,N,A,O,ABC)
!!! DESCRIPTION
!!!    CALCULATES MATRIX ABC FROM MATMUL(A,MATMUL(B,TRANSPOSE(A))),
!!!    WHERE B IS A SQUARE (NOT NECESSARILY SYMMETRIC) MATRIX
!!! INPUTS
!!!     DOUBLE PRECISION B(M,M),A(O,M)
!!!     INTEGER M,O
!!! OUTPUT
!!!     DOUBLE PRECISION ABC(O,O)
!!! NOTES
!!!     THE ELEMENTS M AND O ARE THE DIMENSIONS OF MATMUL(B,TRANSPOSE(A))
!!!     THE DIMENSIONS OF ABC, ARE THE LAST ELEMENT, I.E., ABC(O,O)
!!!***
      INTEGER M,O
      DOUBLE PRECISION B,A,BDC,ABC
      DIMENSION B(M,M),A(O,M),BDC(M,O),ABC(O,O)
      IF ( M .LT. 1 ) THEN
         CALL I1ERR("MATMUL.src77","YABC",
     1        "IF ( M .LT. 1 ) THEN",
     2        "THE FIRST DIMENSION OF B IS INVALID",
     3        .TRUE.,.TRUE.,"M",M)
      END IF
      IF ( O .LT. 1 ) THEN
         CALL I1ERR("MATMUL.src77","YABC",
     1        "IF ( O .LT. 1 ) THEN",
     2        "THE LAST DIMENSION OF B IS INVALID",
     3        .TRUE.,.TRUE.,"O",O)
      END IF
      CALL YAD(M,B,M,A,O,BDC)
      CALL YAB(O,A,M,BDC,O,ABC)
      END SUBROUTINE




      SUBROUTINE YASC(M,S,A,O,ASC)
!!!****f* MATMUL/YASC
!!!
!!! NAME
!!!   YASC -- MATMUL(A,MATMUL(S,TRANSPOSE(A)))
!!! USAGE
!!!    CALL YASC(M,S,A,O,ASC)
!!! DESCRIPTION
!!!    CALCULATES MATRIX ASC FROM MATMUL(A,MATMUL(S,TRANSPOSE(A))),
!!!    WHERE S IS SYMMETRIX
!!! INPUTS
!!!     DOUBLE PRECISION S(M,M),A(M,O)
!!!     INTEGER M,O
!!! OUTPUT
!!!     DOUBLE PRECISION ASC(O,O)
!!! USES
!!!     MATMUL/YSC
!!!     MATMUL/YAB
!!! NOTES
!!!     VERIFIED 08/04
!!!***
      INTEGER M,O
      DOUBLE PRECISION S,A,SDC,ASC
      DIMENSION S(M,M),A(M,O),SDC(M,O),ASC(O,O)
      IF ( M .LT. 1 ) THEN
         CALL I1ERR("MATMUL.src77","YASC",
     1        "IF ( M .LT. 1 ) THEN",
     2        "THE FIRST DIMENSION OF A IS INVALID",
     3        .TRUE.,.TRUE.,"M",M)
      END IF
      IF ( O .LT. 1 ) THEN
         CALL I1ERR("MATMUL.src77","YASC",
     1        "IF ( O .LT. 1 ) THEN",
     2        "THE LAST DIMENSION OF A IS INVALID",
     3        .TRUE.,.TRUE.,"O",O)
      END IF
      CALL YSC(M,S,A,O,SDC)
      CALL YAB(O,A,M,SDC,O,ASC)
      END SUBROUTINE




      SUBROUTINE YVAV(U,M,A,N,V,UAV)
!!!****f* MATMUL/YVAV
!!!
!!! NAME
!!!   YASC -- DOT_PRODUCT(U,MATMUL(A,V))
!!! USAGE
!!!    CALL YVAV(U,N,A,M,V,UAV)
!!! DESCRIPTION
!!!    CALCULATES SCALAR UAV FROM VECTORS U AND V AND MATRIX A
!!! INPUTS
!!!     DOUBLE PRECISION U(M),A(M,N),V(N)
!!!     INTEGER M,N
!!!
!!! OUTPUT
!!!     DOUBLE PRECISION UAV
!!! USES
!!!     MATMUL/YAV
!!!     MATMUL/DOTPRD
!!! TODO
!!!     TEST
!!!***
      INTEGER M,N
      DOUBLE PRECISION A,U,V,ADV,UAV
      DIMENSION A(M,N),U(M),V(N),ADV(M)
      IF ( M .LT. 1 ) THEN
         CALL I1ERR("MATMUL.src77","YVAV",
     1        "IF ( M .LT. 1 ) THEN",
     2        "THE FIRST DIMENSION OF A IS INVALID",
     3        .TRUE.,.TRUE.,"M",M)
      END IF
      IF ( N .LT. 1 ) THEN
         CALL I1ERR("MATMUL.src77","YVAV",
     1        "IF ( N .LT. 1 ) THEN",
     2        "THE LAST DIMENSION OF A IS INVALID",
     3        .TRUE.,.TRUE.,"N",N)
      END IF
      CALL YAV(M,A,N,V,ADV)
      CALL DOTPRD(U,M,ADV,UAV)
      END SUBROUTINE


      SUBROUTINE YVSV(U,N,A,V,USV)
!!!****f* MATMUL/YVSV
!!!
!!! NAME
!!!   YVSV -- DOT_PRODUCT(U,MATMUL(A,V))
!!! USAGE
!!!    CALL YVSV(U,N,A,M,V,UAV)
!!! DESCRIPTION
!!!    CALCULATES SCALAR UAV FROM VECTORS U AND V AND MATRIX A,
!!!    WHERE A IS SYMMETRIC
!!! INPUTS
!!!     DOUBLE PRECISION U(N),A(N,N),V(N)
!!!     INTEGER N
!!!
!!! OUTPUT
!!!     DOUBLE PRECISION USV
!!! USES
!!!     MATMUL/YAV
!!!     MATMUL/DOTPRD
!!! TODO
!!!     TEST
!!!***
      INTEGER N
      DOUBLE PRECISION A,U,V,SDV,USV
      DIMENSION A(N,N),U(N),V(N),SDV(N)
      IF ( N .LT. 1 ) THEN
         CALL I1ERR("MATMUL.src77","YVSV",
     1        "IF ( N .LT. 1 ) THEN",
     2        "THE DIMENSIONS OF A ARE INVALID",
     3        .TRUE.,.TRUE.,"N",N)
      END IF
      CALL YSV(N,A,V,SDV)
      CALL DOTPRD(U,N,SDV,USV)
      END SUBROUTINE


      SUBROUTINE YIA(M,I,A,N,IA)
!!!****f* MATMUL/YIA
!!!
!!! NAME
!!!   YIA -- MATMUL( DIAGONAL_MATRIX_I , A )
!!! USAGE
!!!    CALL YIA(M,I,A,N,IA)
!!! DESCRIPTION
!!!    CALCULATES MATRIX IA FROM MATRIX A AND
!!!    THE DIAGONAL MATRIX I, WHERE THE DIAGONAL
!!!    IS INPUT AS A VECTOR
!!! INPUTS
!!!     DOUBLE PRECISION I(M),A(M,N)
!!!     INTEGER M,N
!!!
!!! OUTPUT
!!!     DOUBLE PRECISION IA(M,N)
!!! NOTES
!!!     VERIFIED 08/04
!!!***
      INTEGER M,N,J,K
      DOUBLE PRECISION I,A,IA
      DIMENSION I(M),A(M,N),IA(M,N)
      IF ( N .LT. 1 ) THEN
         CALL I1ERR("MATMUL.src77","YIA",
     1        "IF ( N .LT. 1 ) THEN",
     2        "THE TRAILING DIMENSION OF A IS INVALID",
     3        .TRUE.,.TRUE.,"N",N)
      END IF
      IF ( M .LT. 1 ) THEN
         CALL I1ERR("MATMUL.src77","YIA",
     1        "IF ( M .LT. 1 ) THEN",
     2        "THE LEADING DIMENSION OF A IS INVALID",
     3        .TRUE.,.TRUE.,"M",M)
      END IF
      DO 1 J=1,N
c         T = I(J)
         DO 2 K=1,M
            IA(K,J) = A(K,J)*I(J)
 2       CONTINUE
 1    CONTINUE
      END SUBROUTINE


      SUBROUTINE YIC(M,I,A,N,IA)
!!!****f* MATMUL/YIC
!!!
!!! NAME
!!!   YIC -- MATMUL( DIAGONAL_MATRIX_I , TRANSPOSE(A) )
!!! USAGE
!!!    CALL YIC(M,I,A,N,IC)
!!! DESCRIPTION
!!!    CALCULATES MATRIX IA FROM MATRIX TRANSPOSE A AND
!!!    THE DIAGONAL MATRIX I, WHERE THE DIAGONAL
!!!    IS INPUT AS A VECTOR
!!! INPUTS
!!!     DOUBLE PRECISION I(M),A(N,M)
!!!     INTEGER M,N
!!!
!!! OUTPUT
!!!     DOUBLE PRECISION IC(M,N)
!!! TODO
!!!     TEST
!!!***
      INTEGER M,N,J,K
      DOUBLE PRECISION I,A,IA
      DIMENSION I(M),A(M,N),IA(M,N)
      IF ( N .LT. 1 ) THEN
         CALL I1ERR("MATMUL.src77","YIC",
     1        "IF ( N .LT. 1 ) THEN",
     2        "THE LEADING DIMENSION OF A IS INVALID",
     3        .TRUE.,.TRUE.,"N",N)
      END IF
      IF ( M .LT. 1 ) THEN
         CALL I1ERR("MATMUL.src77","YIC",
     1        "IF ( M .LT. 1 ) THEN",
     2        "THE TRAINLING DIMENSION OF A IS INVALID",
     3        .TRUE.,.TRUE.,"M",M)
      END IF
      DO 1 J=1,N
         DO 2 K=1,M
            IA(K,J) = A(J,K)*I(K)
 2       CONTINUE
 1    CONTINUE
      END SUBROUTINE




      SUBROUTINE YAI(M,A,I,N,AI)
!!!****f* MATMUL/YAI
!!!
!!! NAME
!!!   YAI -- MATMUL( A, DIAGONAL_MATRIX_I )
!!! USAGE
!!!    CALL YAI(M,A,I,N,IA)
!!! DESCRIPTION
!!!    CALCULATES MATRIX IA FROM MATRIX A AND
!!!    THE DIAGONAL MATRIX I, WHERE THE DIAGONAL
!!!    IS INPUT AS A VECTOR
!!! INPUTS
!!!     DOUBLE PRECISION I(N),A(M,N)
!!!     INTEGER M,N
!!!
!!! OUTPUT
!!!     DOUBLE PRECISION AI(M,N)
!!! NOTES
!!!     VERIFIED 08/04
!!!***
      INTEGER M,N,J,K
      DOUBLE PRECISION I,A,AI
      DIMENSION I(N),A(M,N),AI(M,N)
      IF ( N .LT. 1 ) THEN
         CALL I1ERR("MATMUL.src77","YAI",
     1        "IF ( N .LT. 1 ) THEN",
     2        "THE TRAILING DIMENSION OF A IS INVALID",
     3        .TRUE.,.TRUE.,"N",N)
      END IF
      IF ( M .LT. 1 ) THEN
         CALL I1ERR("MATMUL.src77","YAI",
     1        "IF ( M .LT. 1 ) THEN",
     2        "THE LEADING DIMENSION OF A IS INVALID",
     3        .TRUE.,.TRUE.,"M",M)
      END IF
      DO 1 J=1,N
c     T = I(J)
         DO 2 K=1,M
            AI(K,J) = A(K,J)*I(J)
 2       CONTINUE
 1    CONTINUE
      END SUBROUTINE
!!!****h* Y77L/PRINT
!!!
!!! NAME
!!!     PRINT.src77 - printing and formatting routines
!!! COPYRIGHT
!!!     Prof. York's Group
!!!     Department of Chemistry
!!!     University of Minnesota
!!! AUTHOR
!!!     Timothy J. Giese
!!! CREATION DATE
!!!     2004
!!! DESCRIPTION
!!!     Prints vectors and matricies
!!! USES
!!!
!!!***


      SUBROUTINE PTV(V,N,NCOL,TITLE,IUNIT,LONG)
!!!****f* PRINT/PTV
!!!
!!! NAME
!!!   PTV -- PRINT A VECTOR
!!! USAGE
!!!    CALL PTV(V,N,NCOL,TITLE,IUNIT,LONG)
!!! DESCRIPTION
!!!   PRINTS VECTOR "V" OF LENGTH "N"
!!!   USING "NCOL" COLUMNS
!!!   GIVING THE PRINT OUT THE TITLE "TITLE"
!!!   TO UNIT "IUNIT"
!!!   IF LONG = .TRUE., THEN SCIENTIFIC NOTATION IS USED
!!! INPUTS
!!!     INTEGER N,NCOL,IUNIT
!!!     DOUBLE PRECISION V(N)
!!!     CHARACTER(LEN=*)TITLE
!!!     LOGICAL LONG
!!! OUTPUT
!!!     NONE
!!!***
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      INTEGER N,NCOL,IUNIT
      DIMENSION V(N)
      CHARACTER(LEN=*) TITLE
      LOGICAL LONG
      INTEGER NROW,IR,I,J
      CHARACTER(LEN=30) FMT
      INTEGER LENTRM
      INTEGER LENTIT
      CHARACTER(LEN=200) PROC
      LENTIT = LENTRM(TITLE)
      PROC = "PTV W/TITLE="//TITLE(1:LENTIT)
C     IS THERE A VALID NUMBER OF COLUMNS?
      IF ( NCOL.LT.1 ) THEN
         CALL I1ERR("PRINT.src77",PROC,
     1        "IF ( NCOL.LT.1 ) THEN",
     2        "THERE MUST BE AT LEAST 1 COLUMN",
     3        .TRUE.,.TRUE.,
     4        "NCOL",NCOL)
      END IF
C     IS THE ARRAY OF VALID SIZE?
      IF ( N.LT.1 ) THEN
         CALL I1ERR("PRINT.src77",PROC,
     1        "IF ( N.LT.1 ) THEN",
     2        "THE ARRAY DOES NOT HAVE A VALID SIZE",
     3        .TRUE.,.TRUE.,
     4        "N",N)
      END IF
C     THE NUMBER OF ROWS THAT WILL BE PRINTED
      NROW = N/NCOL
C     IF THE LAST ROW WILL NOT FILL ALL THE COLUMNS, 
C     THEN GIVE A WARNING
      IF ( N - NROW*NCOL .NE. 0 ) THEN
         CALL I2ERR("PRINT.src77",PROC,
     1        "IF ( N - NROW*NCOL .NE. 0 ) THEN",
     2        "THE LAST ROW DOES NOT FILL THE COLUMNS",
     3        .FALSE.,.TRUE.,
     4        "N",N,"NCOL",NCOL)
         WRITE(6,'(A)')"RETURNING WITHOUT REQUESTED OUTPUT"
         RETURN
      END IF

      IF ( LONG ) THEN
         FMT = "(100E15.7)"
      ELSE
         FMT = "(100F15.7)"
      END IF
      IF ( LENTRM(TITLE).GT.0 ) WRITE(IUNIT,'(A)')TITLE
      DO 1 I=1,NROW
         IR = (I-1)*NCOL
         WRITE(IUNIT,FMT)(V(IR+J),J=1,NCOL)
 1    CONTINUE

      END SUBROUTINE





      SUBROUTINE PTPV(V,N,NCOL,TITLE,IUNIT,LONG,COLBL)
!!!****f* PRINT/PTPV
!!!
!!! NAME
!!!   PTPV -- PRINT A "PRETTY" VECTOR
!!! USAGE
!!!    CALL PTPV(V,N,NCOL,TITLE,IUNIT,LONG,COLBL)
!!! DESCRIPTION
!!!   PRINTS VECTOR "V" OF LENGTH "N"
!!!   USING "NCOL" COLUMNS
!!!   GIVING THE PRINT OUT THE TITLE "TITLE"
!!!   TO UNIT "IUNIT"
!!!   IF LONG = .TRUE., THEN SCIENTIFIC NOTATION IS USED
!!!   THE I'TH COLUMN IS GIVEN THE I'TH LABEL COLBL(I)
!!! INPUTS
!!!     INTEGER N,NCOL,IUNIT
!!!     DOUBLE PRECISION V(N)
!!!     CHARACTER(LEN=*)TITLE,COLBL(NCOL)
!!!     LOGICAL LONG
!!! OUTPUT
!!!     NONE
!!!***
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      INTEGER N,NCOL,IUNIT
      DIMENSION V(N)
      CHARACTER(LEN=*) TITLE
      CHARACTER(LEN=*) COLBL(NCOL)
      CHARACTER(LEN=15) COLL(NCOL)
      CHARACTER(LEN=50) FMT
      LOGICAL LONG
      INTEGER NROW,J,L,NI,I   
      INTEGER LENTRM
      INTEGER LENTIT
      CHARACTER(LEN=200) PROC
      LENTIT = LENTRM(TITLE)
      PROC = "PTPV W/TITLE="//TITLE(1:LENTIT)
C     IS THERE A VALID NUMBER OF COLUMNS?
      IF ( NCOL.LT.1 ) THEN
         CALL I1ERR("PRINT.src77",PROC,
     1        "IF ( NCOL.LT.1 ) THEN",
     2        "THERE MUST BE AT LEAST 1 COLUMN",
     3        .TRUE.,.TRUE.,
     4        "NCOL",NCOL)
      END IF
C     IS THE ARRAY OF VALID SIZE?
      IF ( N.LT.1 ) THEN
         CALL I1ERR("PRINT.src77",PROC,
     1        "IF ( N.LT.1 ) THEN",
     2        "THE ARRAY DOES NOT HAVE A VALID SIZE",
     3        .TRUE.,.TRUE.,
     4        "N",N)
      END IF
C     THE NUMBER OF ROWS THAT WILL BE PRINTED
      NROW = N/NCOL
C     IF THE LAST ROW WILL NOT FILL ALL THE COLUMNS, 
C     THEN GIVE A WARNING
      IF ( N - NROW*NCOL .NE. 0 ) THEN
         CALL I2ERR("PRINT.src77",PROC,
     1        "IF ( N - NROW*NCOL .NE. 0 ) THEN",
     2        "THE LAST ROW DOES NOT FILL THE COLUMNS",
     3        .FALSE.,.TRUE.,
     4        "N",N,"NCOL",NCOL)
         WRITE(6,'(A)')"RETURNING WITHOUT REQUESTED OUTPUT"
         RETURN
      END IF

      IF ( LONG ) THEN
         FMT = "(I3,1X,100E15.7)"
      ELSE
         FMT = "(I3,1X,100F15.7)"
      END IF

      DO 5 I=1,NCOL
         L = LENTRM(COLBL(I))
         CALL CLRS(COLL(I),LEN(COLL(I)))
         IF ( L .GT. 15 ) L = 15
         COLL(I)(1:L) = COLBL(I)(1:L)
         CALL ADJC(COLL(I))
 5    CONTINUE

      WRITE(IUNIT,*)
      WRITE(IUNIT,'(A)')TITLE
      WRITE(IUNIT,'(A,1X,100A)')"IND ",(COLL(I),I=1,NCOL)
      DO 10 I=1,NROW
         NI = (I-1)*NCOL
         WRITE(IUNIT,FMT)I,(V(NI+J),J=1,NCOL)
 10   CONTINUE
      WRITE(IUNIT,*)

      END SUBROUTINE





      SUBROUTINE PTM(M,A,N,MB,NB,TITLE,IUNIT,LONG)
!!!****f* PRINT/PTM
!!!
!!! NAME
!!!   PTV -- PRINT A MATRIX
!!! USAGE
!!!    CALL PTM(M,A,N,MB,NB,TITLE,IUNIT,LONG)
!!! DESCRIPTION
!!!   PRINTS MATRIX "A" OF LENGTH "M" BY "N"
!!!   BY SUBBLOCKS, WHERE THE SUBBLOCKS ARE OF 
!!!   LENGTH "MB" BY "NB"
!!!   GIVING THE PRINT OUT THE TITLE "TITLE"
!!!   TO UNIT "IUNIT"
!!!   IF LONG = .TRUE., THEN SCIENTIFIC NOTATION IS USED
!!! INPUTS
!!!     INTEGER M,N,MB,NB,IUNIT
!!!     DOUBLE PRECISION A(M,N)
!!!     CHARACTER(LEN=*)TITLE
!!!     LOGICAL LONG
!!! OUTPUT
!!!     NONE
!!!***
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      INTEGER M,N,MB,NB,IUNIT
      DIMENSION A(M,N)
      CHARACTER(LEN=*) TITLE
      LOGICAL LONG

      INTEGER I,J,IC,IR,JC,JR
      INTEGER NBR,NBC
      CHARACTER(LEN=30) FMT
      INTEGER LENTRM
      INTEGER LENTIT
      CHARACTER(LEN=9) SR,SC
      CHARACTER(LEN=4) SRR,SRC,SCR,SCC
      CHARACTER(LEN=200) PROC
      LENTIT = LENTRM(TITLE)
      PROC = "PTM W/TITLE="//TITLE(1:LENTIT)

C     IS THERE A VALID NUMBER OF BLOCKS?
      IF ( MB.LT.1 ) THEN
         CALL I1ERR("PRINT.src77",PROC,
     1        "IF ( MB.LT.1 ) THEN",
     2        "MBxNB BLOCK LENGTH ILL-DEFINED",
     3        .TRUE.,.TRUE.,
     4        "MB",MB)
      END IF
      IF ( NB.LT.1 ) THEN
         CALL I1ERR("PRINT.src77",PROC,
     1        "IF ( NB.LT.1 ) THEN",
     2        "MBxNB BLOCK LENGTH ILL-DEFINED",
     3        .TRUE.,.TRUE.,
     4        "NB",NB)
      END IF
C     IS THE ARRAY OF VALID SIZE?
      IF ( N.LT.1 ) THEN
         CALL I1ERR("PRINT.src77",PROC,
     1        "IF ( N.LT.1 ) THEN",
     2        "MxN ARRAY LENGTH ILL-DEFINED",
     3        .TRUE.,.TRUE.,
     4        "N",N)
      END IF
      IF ( M.LT.1 ) THEN
         CALL I1ERR("PRINT.src77",PROC,
     1        "IF ( M.LT.1 ) THEN",
     2        "MxN ARRAY LENGTH ILL-DEFINED",
     3        .TRUE.,.TRUE.,
     4        "M",M)
      END IF
C     THE NUMBER OF BLOCK ROWS THAT WILL BE PRINTED
      NBC = N/NB
      IF ( N - NBC*NB .NE. 0 ) THEN
         CALL I2ERR("PRINT.src77",PROC,
     1        "IF ( N - NBC*NB .NE. 0 ) THEN",
     2        "NBC BLOCKS OF LENGTH MB DOES NOT FIT IN N",
     3        .FALSE.,.TRUE.,
     4        "N",N,"NB",NB)
         WRITE(6,'(A)')"RETURNING WITHOUT REQUESTED OUTPUT"
         RETURN
      END IF
C     THE NUMBER OF BLOCK COLUMNS THAT WILL BE PRINTED
      NBR = M/MB
      IF ( M - NBR*MB .NE. 0 ) THEN
         CALL I2ERR("PRINT.src77",PROC,
     1        "IF ( M - NBR*MB .NE. 0 ) THEN",
     2        "NBR BLOCKS OF LENGTH MB DOES NOT FIT IN M",
     3        .FALSE.,.TRUE.,
     4        "M",M,"MB",MB)
         WRITE(6,'(A)')"RETURNING WITHOUT REQUESTED OUTPUT"
         RETURN
      END IF



      IF ( LONG ) THEN
         FMT = "(100E15.7)"
      ELSE
         FMT = "(100F15.7)"
      END IF
C      IF ( LENTRM(TITLE).GT.0 ) WRITE(IUNIT,'(A)')TITLE

      IF ( NB .EQ. 1 ) THEN
         DO 1 I=1,NBR
            IR = (I-1)*MB
            DO 2 J=1,NBC
               IC = (J-1)*NB
               DO 3 JR=1,MB
                  WRITE(IUNIT,FMT)(A(IR+JR,IC+JC),JC=1,NB)
 3             CONTINUE
 2          CONTINUE
 1       CONTINUE
      ELSE
         DO 11 I=1,NBR
            IR = (I-1)*MB
            CALL I2C(I    ,SR )
            CALL I2C(IR+1 ,SRR)
            CALL I2C(IR+NB,SRC)
            DO 12 J=1,NBC
               IC = (J-1)*NB
               CALL I2C(J    ,SC )
               CALL I2C(IC+1 ,SCR)
               CALL I2C(IC+MB,SCC)
               WRITE(IUNIT,*)
               WRITE(IUNIT,'(6A)')TITLE," SUBBLOCK (",
     1              SR,")x(",SC,")"
               WRITE(IUNIT,'(10A)')TITLE," ELEMENTS (",
     1              SRR,"-",SRC,")x(",SCR,"-",SCC,")"
               DO 13 JR=1,MB
                  WRITE(IUNIT,FMT)(A(IR+JR,IC+JC),JC=1,NB)
 13            CONTINUE
 12         CONTINUE
 11      CONTINUE
         WRITE(IUNIT,*)
      END IF
      END SUBROUTINE





      SUBROUTINE PTSM(A,N,NB,TITLE,IUNIT,LONG)
!!!****f* PRINT/PTSM
!!!
!!! NAME
!!!   PTV -- PRINT A SYMMETRIC MATRIX
!!! USAGE
!!!    CALL PTSM(A,N,NB,TITLE,IUNIT,LONG)
!!! DESCRIPTION
!!!   PRINTS A SYMMTRIC MATRIX "A" OF LENGTH "N" BY "N"
!!!   BY UNIQUE SUBBLOCKS, WHERE THE SUBBLOCKS ARE OF 
!!!   LENGTH "NB" BY "NB"
!!!   GIVING THE PRINT OUT THE TITLE "TITLE"
!!!   TO UNIT "IUNIT"
!!!   IF LONG = .TRUE., THEN SCIENTIFIC NOTATION IS USED
!!! INPUTS
!!!     INTEGER N,NB,IUNIT
!!!     DOUBLE PRECISION A(N,N)
!!!     CHARACTER(LEN=*)TITLE
!!!     LOGICAL LONG
!!! OUTPUT
!!!     NONE
!!!***
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      INTEGER M,N,MB,NB,IUNIT
      DIMENSION A(N,N)
      CHARACTER(LEN=*) TITLE
      LOGICAL LONG

      INTEGER I,J,IC,IR,JC,JR
      INTEGER NBR,NBC
      CHARACTER(LEN=30) FMT
      INTEGER LENTRM
      INTEGER LENTIT
      CHARACTER(LEN=9) SR,SC
      CHARACTER(LEN=4) SRR,SRC,SCR,SCC
      CHARACTER(LEN=200) PROC
      LENTIT = LENTRM(TITLE)
      PROC = "PTSM W/TITLE="//TITLE(1:LENTIT)
      M = N
      MB = NB


C     IS THERE A VALID NUMBER OF BLOCKS?
      IF ( MB.LT.1 ) THEN
         CALL I1ERR("PRINT.src77",PROC,
     1        "IF ( MB.LT.1 ) THEN",
     2        "MBxNB BLOCK LENGTH ILL-DEFINED",
     3        .TRUE.,.TRUE.,
     4        "MB",MB)
      END IF
      IF ( NB.LT.1 ) THEN
         CALL I1ERR("PRINT.src77",PROC,
     1        "IF ( NB.LT.1 ) THEN",
     2        "MBxNB BLOCK LENGTH ILL-DEFINED",
     3        .TRUE.,.TRUE.,
     4        "NB",NB)
      END IF
C     IS THE ARRAY OF VALID SIZE?
      IF ( N.LT.1 ) THEN
         CALL I1ERR("PRINT.src77",PROC,
     1        "IF ( N.LT.1 ) THEN",
     2        "MxN ARRAY LENGTH ILL-DEFINED",
     3        .TRUE.,.TRUE.,
     4        "N",N)
      END IF
      IF ( M.LT.1 ) THEN
         CALL I1ERR("PRINT.src77",PROC,
     1        "IF ( M.LT.1 ) THEN",
     2        "MxN ARRAY LENGTH ILL-DEFINED",
     3        .TRUE.,.TRUE.,
     4        "M",M)
      END IF
C     THE NUMBER OF BLOCK ROWS THAT WILL BE PRINTED
      NBC = N/NB
      IF ( N - NBC*NB .NE. 0 ) THEN
         CALL I2ERR("PRINT.src77",PROC,
     1        "IF ( N - NBC*NB .NE. 0 ) THEN",
     2        "NBC BLOCKS OF LENGTH NB DOES NOT FIT IN N",
     3        .FALSE.,.TRUE.,
     4        "N",N,"NB",NB)
         WRITE(6,'(A)')"RETURNING WITHOUT REQUESTED OUTPUT"
         RETURN
      END IF
C     THE NUMBER OF BLOCK COLUMNS THAT WILL BE PRINTED
      NBR = M/MB
      IF ( M - NBR*MB .NE. 0 ) THEN
         CALL I2ERR("PRINT.src77",PROC,
     1        "IF ( M - NBR*MB .NE. 0 ) THEN",
     2        "NBR BLOCKS OF LENGTH MB DOES NOT FIT IN M",
     3        .FALSE.,.TRUE.,
     4        "M",N,"MB",NB)
         WRITE(6,'(A)')"RETURNING WITHOUT REQUESTED OUTPUT"
         RETURN
      END IF



      IF ( LONG ) THEN
         FMT = "(100E15.7)"
      ELSE
         FMT = "(100F15.7)"
      END IF
C      IF ( LENTRM(TITLE).GT.0 ) WRITE(IUNIT,'(A)')TITLE

      IF ( NB .EQ. 1 ) THEN
         DO 1 I=1,NBR
            IR = (I-1)*MB
            DO 2 J=I,NBC
               IC = (J-1)*NB
               DO 3 JR=1,MB
                  WRITE(IUNIT,FMT)(A(IR+JR,IC+JC),JC=1,NB)
 3             CONTINUE
 2          CONTINUE
 1       CONTINUE
      ELSE
         DO 11 I=1,NBR
            IR = (I-1)*MB
            CALL I2C(I    ,SR )
            CALL I2C(IR+1 ,SRR)
            CALL I2C(IR+NB,SRC)
            DO 12 J=I,NBC
               IC = (J-1)*NB
               CALL I2C(J    ,SC )
               CALL I2C(IC+1 ,SCR)
               CALL I2C(IC+MB,SCC)
               WRITE(IUNIT,*)
               WRITE(IUNIT,'(6A)')TITLE," SUBBLOCK (",
     1              SR,")x(",SC,")"
               WRITE(IUNIT,'(10A)')TITLE," ELEMENTS (",
     1              SRR,"-",SRC,")x(",SCR,"-",SCC,")"
               DO 13 JR=1,MB
                  WRITE(IUNIT,FMT)(A(IR+JR,IC+JC),JC=1,NB)
 13            CONTINUE
 12         CONTINUE
 11      CONTINUE
         WRITE(IUNIT,*)
      END IF
      END SUBROUTINE
!!!****h* Y77L/SINT
!!!
!!! NAME
!!!     SINT.src77 - Gaussian overlap integrals
!!! COPYRIGHT
!!!     Prof. York's Group
!!!     Department of Chemistry
!!!     University of Minnesota
!!! AUTHOR
!!!     Timothy J. Giese
!!! CREATION DATE
!!!     2004
!!! DESCRIPTION
!!!     calculates gaussian-gaussian overlap integrals
!!! NOTES
!!!     The normalized gaussian is defined as
!!!     (Z**2/PI)**1.5D0 * EXP(-Z**2 * (R-Rc)**2)
!!!     Point: The exponent is the square of the zeta.
!!!     If your parameters correspond to an exponent which is not squared,
!!!     then take the square root of it before usign these routines.
!!! USES
!!!     INIT/CLRV
!!!     INIT/CLRM
!!!***



      SUBROUTINE GGSSS(ZETI,ZETJ,XI,YI,ZI,XJ,YJ,ZJ,GGS)
!!!****f* SINT/GGSSS
!!!
!!! NAME
!!!   GGSSS
!!! USAGE
!!!    CALL GGSSS(ZETI,ZETJ,XI,YI,ZI,XJ,YJ,ZJ,GGS)
!!! DESCRIPTION
!!!   CALCULATES THE OVERLAP INTEGRAL OF A
!!!   GAUSSIAN MONOPOLE WITH GAUSSIAN MONOPOLE
!!! INPUTS
!!!     DOUBLE PRECISION XI,YI,ZI,XJ,YJ,ZJ , ZETI,ZETJ
!!!
!!! OUTPUT
!!!     DOUBLE PRECISION GGS
!!!***
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION CRDS(3)
      PI     = 3.141592653589793238462643383279502884197D0
      SQRTPI = SQRT(PI)
      GGS = 0.0D0
      CRDS(1) = XI-XJ
      CRDS(2) = YI-YJ
      CRDS(3) = ZI-ZJ
      RIJ    = SQRT( CRDS(1)**2+CRDS(2)**2+CRDS(3)**2 )
      Z = ZETI*ZETJ/SQRT(ZETI**2+ZETJ**2)
      PREF   = (PI/(ZETI**2+ZETJ**2))**1.5D0
C     THIS IS THE OVERLAP OF 2 UNNORMALIZED GAUSSIANS
C     SEE SZABO AND OSTLUND PP.412 FOR PROOF
      GGS = PREF * EXP(-(Z*RIJ)**2)
C     NOW WE MULTIPLY IN THE NORMALIZATION CONSTANTS
      GINORM = (ZETI/SQRTPI)**3
      GJNORM = (ZETJ/SQRTPI)**3
      GGS = GGS * GINORM * GJNORM
      END SUBROUTINE
!!!****h* Y77L/STRNG
!!!
!!! NAME
!!!     STRNG.src77 - string functions
!!! COPYRIGHT
!!!     Prof. York's Group
!!!     Department of Chemistry
!!!     University of Minnesota
!!! AUTHOR
!!!     Timothy J. Giese
!!! CREATION DATE
!!!     2004
!!! DESCRIPTION
!!!     string functions
!!! USES
!!!
!!!***




      FUNCTION LENTRM(S)
!!!****f* STRNG/LENTRM
!!!
!!! NAME
!!!   FUNCTION LENTRM -- f77 analogue of f90's LEN_TRIM
!!! USAGE
!!!   LENGTH = LENTRM(S)
!!! DESCRIPTION
!!!   DETERMINS THE LENGTH OF A TRIMMED STRING
!!! INPUTS
!!!     CHARACTER(LEN=*) S
!!! OUTPUT
!!!     INTEGER LENTRM
!!!***
      CHARACTER(LEN=*) S
      INTEGER I,L,LENTRM
      L = LEN(S)
      LENTRM = L
      DO 2 I=L,1,-1
         LENTRM = I
         IF ( S(I:I) .NE. " " ) EXIT
 2    CONTINUE
      RETURN
      END FUNCTION





      SUBROUTINE ADJL(S)
!!!****f* STRNG/ADJL
!!!
!!! NAME
!!!   SUBROUTINE ADJL -- f77 analogue of f90's ADJUSTL
!!! USAGE
!!!   CALL ADJL(S)
!!! DESCRIPTION
!!!   REMOVES WHITE SPACE ON THE LEFT OF A STRING
!!! INPUTS
!!!     CHARACTER(LEN=*) S
!!! OUTPUT
!!!     CHARACTER(LEN=*) S
!!!***
      CHARACTER(LEN=*) S
      INTEGER I,L,M

      L = LEN(S)
      M = 0
      DO 1 I=1,L
         IF ( S(I:I) .NE. " " ) EXIT
         M = I
 1    CONTINUE
      S(1:L-M) = S(M+1:L)
      DO 2 I=L-M+1,L
         S(I:I) = " "
 2    CONTINUE
      RETURN
      END SUBROUTINE






      SUBROUTINE RMWHIT(S)
!!!****f* STRNG/RMWHIT
!!!
!!! NAME
!!!   SUBROUTINE RMWHIT -- f77 analogue of YorkLib's RemoveWhiteSpace
!!! USAGE
!!!   CALL RMWHIT(S)
!!! DESCRIPTION
!!!   REMOVES ALL WHITE SPACE FROM A STRING
!!! INPUTS
!!!     CHARACTER(LEN=*) S
!!! OUTPUT
!!!     CHARACTER(LEN=*) S
!!!***
      CHARACTER(LEN=*) S
      INTEGER L
      L = LEN(S)
      CALL RMWHDR(S,L)
      END SUBROUTINE

      SUBROUTINE RMWHDR(S,L)
      INTEGER L
      CHARACTER(LEN=*) S
      CHARACTER(LEN=500) T
      INTEGER I,J
      INTEGER LOW
      J = 0
      IF ( L .GT. 500 ) THEN
         LOW = 500
      ELSE
         LOW = L
      END IF
      DO 1 I=1,LOW
         IF ( S(I:I) .NE. " " ) THEN
            J=J+1
            T(J:J) = S(I:I)
         END IF
 1    CONTINUE
      S(1:LOW) = T(1:LOW)
      IF (LOW.LT.L) THEN
         DO 2 I=LOW+1,L
            S(I:I) = " "
 2       CONTINUE
      END IF
      END SUBROUTINE



      SUBROUTINE ADJC(S)
!!!****f* STRNG/ADJC
!!!
!!! NAME
!!!   SUBROUTINE ADJC -- CENTER JUSTIFICATION OF A STRING
!!! USAGE
!!!   CALL ADJC(S)
!!! DESCRIPTION
!!!   CENTERS THE NON-WHITE SPACE CHARACTERS TO THE MIDDLE OF THE STRING
!!! INPUTS
!!!     CHARACTER(LEN=*) S
!!! OUTPUT
!!!     CHARACTER(LEN=*) S
!!!***
      CHARACTER(LEN=*) S
      INTEGER L,LT,OFFSET,LOW,HI
      INTEGER LENTRM

      L = LEN(S)
      CALL ADJL(S)
      LT = LENTRM(S)
      OFFSET = (L-LT)/2+1
      LOW = OFFSET
      HI = OFFSET + LT
      S(LOW:HI) = S(1:LT)
      CALL CLRS(S,LOW-1)
      END SUBROUTINE



      SUBROUTINE CLRS(S,N)
!!!****f* STRNG/CLRS
!!!
!!! NAME
!!!   SUBROUTINE CLRS -- CLEAR A STRING
!!! USAGE
!!!   CALL CLRS(S,N)
!!! DESCRIPTION
!!!   REPLACES THE FIRST N CHARACTERS OF A STRING WITH WHITE SPACE
!!! INPUTS
!!!     CHARACTER(LEN=*) S
!!!     INTEGER N
!!! OUTPUT
!!!     CHARACTER(LEN=*) S
!!!***
      CHARACTER(LEN=*) S
      INTEGER N,L,M,I
      
      L = LEN(S)
      IF ( N.GT.L ) THEN
         M = L
      ELSE
         M = N
      END IF
      DO 10 I=1,M
         S(I:I) = " "
 10   CONTINUE
      END SUBROUTINE




      SUBROUTINE I2C(I,S)
!!!****f* STRNG/I2C
!!!
!!! NAME
!!!   SUBROUTINE I2C -- CONVERTS AN INTEGER TO A STRING
!!! USAGE
!!!   CALL I2C(I,S)
!!! DESCRIPTION
!!!   WRITES INTEGER TO STRING WITH CENTER JUSTIFICATION
!!! INPUTS
!!!     INTEGER I
!!! OUTPUT
!!!     CHARACTER(LEN=*) S
!!!***
      CHARACTER(LEN=*) S
      INTEGER I,L
      CHARACTER(LEN=10) FMT
      CHARACTER(LEN=3) FLEN

      L = LEN(S)
      WRITE(FLEN,'(I3)')L
      CALL ADJL(FLEN)
      FMT = "(I"//FLEN//")"
      WRITE(S,FMT)I
      CALL ADJC(S)
      END SUBROUTINE
!!!****h* Y77L/UTILS
!!!
!!! NAME
!!!     UTILS.src77 - Utility Module
!!! COPYRIGHT
!!!     Prof. York's Group
!!!     Department of Chemistry
!!!     University of Minnesota
!!! AUTHOR
!!!     Timothy J. Giese
!!! CREATION DATE
!!!     2004
!!! DESCRIPTION
!!!     Misc utitlies such as vector sorting, 
!!!     even/odd integer checks,
!!!     and weighted averages.
!!! USES
!!!***


      SUBROUTINE MINLV(V,N,I,VAL)
!!!****f* UTILS/MINLV
!!!
!!! NAME
!!!   MINLV - RETURNS THE ELEMENT AND INDEX OF THE 
!!!           MINIMUM VALUE
!!! USAGE
!!!    CALL MINLV(V,N,I,VAL)
!!! DESCRIPTION
!!!    GIVEN VECTOR V OF LENGTH N, RETURNS
!!!    THE INDEX I AND VALUE VAL=V(I) OF THE
!!!    SMALLEST (LEAST POSITIVE OR MOST NEGATIVE)
!!!    ELEMENT
!!! INPUTS
!!!     DOUBLE PRECISION V(N)
!!!     INTEGER N
!!!
!!! OUTPUT
!!!     DOUBLE PRECISION VAL
!!!     INTEGER I
!!! USES
!!!     
!!!***
C********************************************
C     FINDS THE MINIMUM VALUE IN VECTOR V(N)
C     STORES THE MINIMUM VALUE IN VAL
C     AND STORES THE INDEX IN I
C********************************************
      INTEGER N,I
      DOUBLE PRECISION V,VAL
      DIMENSION V(N)
      INTEGER J
      VAL = 1.0D+32
      DO 10 J=1,N
         IF ( V(J).LT.VAL ) THEN
            I=J
            VAL = V(J)
         END IF
 10   CONTINUE
      END SUBROUTINE



      SUBROUTINE MAXLV(V,N,I,VAL)
!!!****f* UTILS/MAXLV
!!!
!!! NAME
!!!   MAXLV - RETURNS THE ELEMENT AND INDEX OF THE 
!!!           MINIMUM VALUE
!!! USAGE
!!!    CALL MAXLV(V,N,I,VAL)
!!! DESCRIPTION
!!!    GIVEN VECTOR V OF LENGTH N, RETURNS
!!!    THE INDEX I AND VALUE VAL=V(I) OF THE
!!!    LARGEST (LEAST NEGATIVE OR MOST POSITIVE)
!!!    ELEMENT
!!! INPUTS
!!!     DOUBLE PRECISION V(N)
!!!     INTEGER N
!!!
!!! OUTPUT
!!!     DOUBLE PRECISION VAL
!!!     INTEGER I
!!! USES
!!!     
!!!***
      INTEGER N,I
      DOUBLE PRECISION V,VAL
      DIMENSION V(N)
      INTEGER J
      VAL = -1.0D+32
      DO 10 J=1,N
         IF ( V(J).GT.VAL ) THEN
            I=J
            VAL = V(J)
         END IF
 10   CONTINUE
      END SUBROUTINE


      SUBROUTINE SORTV(V,N,IMAP,ORDER)
!!!****f* UTILS/SORTV
!!!
!!! NAME
!!!   SORTV - VECTOR SORTING
!!! USAGE
!!!    CALL SORTV(V,N,IMAP,ORDER)
!!! DESCRIPTION
!!!    SORTS THE ELEMENTS OF VECTOR V
!!!    AND PROVIDES THE MAPPING TO THE
!!!    ORIGINAL ORDER VIA IMAP, E.G.
!!!    VINP(I) = VOUT(IMAP(I))
!!!    IF ORDER = "A", THEN THE ORDER IS ASCENDING
!!!    IF ORDER = "D", THEN THE ORDER IS DESCENDING
!!!    OTHERWISE, NO ORDERING IS PERFORMED
!!! INPUTS
!!!     DOUBLE PRECISION V(N)
!!!     INTEGER N
!!!     CHARACTER(LEN=1) ORDER
!!!
!!! OUTPUT
!!!     DOUBLE PRECISION V(N)
!!!     INTEGER IMAP(N)
!!! USES
!!!     UTILS/MINLV
!!!***

      INTEGER N,IMAP
      DOUBLE PRECISION V
      DIMENSION IMAP(N),V(N)
      INTEGER I,IMIN
      DOUBLE PRECISION VT,VMIN
      DIMENSION VT(N)
      CHARACTER*1 ORDER

      IF ( ORDER .EQ. "A" .OR. ORDER .EQ. "a" ) THEN
         DO 10 I=1,N
            CALL MINLV(V,N,IMIN,VMIN)
            IMAP(I) = IMIN
            VT(I)   = VMIN
            V(IMIN)    = 1.0D+32
 10      CONTINUE
         CALL CPYV(VT,N,V)
      ELSE IF ( ORDER .EQ. "D" .OR. ORDER .EQ. "d" ) THEN
         DO 20 I=1,N
            CALL MAXLV(V,N,IMIN,VMIN)
            IMAP(I) = IMIN
            VT(I)   = VMIN
            V(IMIN)    = -1.0D+32
 20      CONTINUE
         CALL CPYV(VT,N,V)
      ELSE
         DO 30 I=1,N
            IMAP(I) = I
 30      CONTINUE
      END IF
      END SUBROUTINE


      LOGICAL FUNCTION LISODD(L)
!!!****f* UTILS/LISODD
!!!
!!! NAME
!!!    LISODD - CHECKS FOR ODD INTEGER
!!! USAGE
!!!    LOGFLG = LISODD(L)
!!! DESCRIPTION
!!!    IF L IS AN ODD INTEGER, THEN TRUE IS RETURNED,
!!!    ELSE FALSE
!!! INPUTS
!!!     INTEGER L
!!!
!!! OUTPUT
!!!     LOGICAL LISODD
!!! USES
!!!     
!!!***
      INTEGER L
C      LOGICAL LISODD
      IF ( MOD(L,2).NE.0 ) THEN
         LISODD = .TRUE.
      ELSE
         LISODD = .FALSE.
      END IF
      END FUNCTION


      LOGICAL FUNCTION LISEVN(L)
!!!****f* UTILS/LISEVN
!!!
!!! NAME
!!!    LISEVN - CHECKS FOR EVEN INTEGER
!!! USAGE
!!!    LOGFLG = LISEVN(L)
!!! DESCRIPTION
!!!    IF L IS AN EVEN INTEGER, THEN TRUE IS RETURNED,
!!!    ELSE FALSE
!!! INPUTS
!!!     INTEGER L
!!!
!!! OUTPUT
!!!     LOGICAL LISEVN
!!! USES
!!!     UTILS/LISODD
!!!***
      INTEGER L
      LOGICAL LISODD
      LISEVN = (.NOT. LISODD(L))
      END FUNCTION





      DOUBLE PRECISION FUNCTION WTAVG(WT1,VAL1,WT2,VAL2)
!!!****f* UTILS/WTAVG
!!!
!!! NAME
!!!    WTAVG - WEIGHTED AVERAGE
!!! USAGE
!!!    WAVG = WTAVG(WT1,VAL1,WT2,VAL2)
!!! DESCRIPTION
!!!    WAVG = (WT1*VAL2+WT2*VAL2)/(WT1+WT2)
!!!    PERFORMS A SAFE DIVISION CHECK ON THE DENOMINATOR
!!! INPUTS
!!!     DOUBLE PRECISION WT1,VAL1,WT2,VAL2
!!!
!!! OUTPUT
!!!     DOUBLE PRECISION WTAVG
!!! USES
!!!     
!!!***
      DOUBLE PRECISION WT1,VAL1,WT2,VAL2
      DOUBLE PRECISION WT12
      WT12 = WT1+WT2
      IF ( WT12 .LT. 1.0D-16 ) THEN
         CALL F1ERR("UTILS.src77","WTAVG",
     a        "IF ( WT12 .LT. 1.0D-16 ) THEN",
     b        "DIVISION BY ZERO - WEIGHTS ARE TOO SMALL",
     c        .TRUE.,.TRUE.,"WT12",WT12)
      END IF
      WTAVG = (WT1*VAL1+WT2*VAL2)/WT12
      END FUNCTION
