      SUBROUTINE FLEPO (H,LFA,ARRAY,LM5,ICALL,SCFCAL)
C     *
C     GEOMETRY OPTIMIZATION: BFGS AND DFP QUASI-NEWTON METHODS.
C     *
C     NOTATION. I=INPUT,O=OUTPUT, S=SCRATCH.
C     H(LFA)    BUFFER FOR INVERSION HESSIAN (S).
C     ARRAY()   AVAILABLE GENERAL BUFFER (I,O,S).
C     LM5       DIMENSION OF AVAILABLE BUFFER (I).
C     ICALL     CALLING CODE TO DEFINE TYPE OF CALCULATION (I),
C               NEGATIVE VALUE UPON RETURN SIGNALS AN ERROR (O).
C     SCFCAL    EXTERNAL ROUTINE FOR ENERGY EVALUATION (I).
C     *
      USE LIMIT, ONLY: LMV
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C     *
C     THIS SUBROUTINE ATTEMPTS TO MINIMIZE A FUNCTION F OF THE
C     N-COMPONENT VECTOR X BY THE DAVIDON-FLETCHER-POWELL (DFP)
C     OR THE BROYDEN-FLETCHER-GOLDFARB-SHANNO (BFGS) ALGORITHM.
C     THE USER MUST SUPPLY THE SUBROUTINE  COMPFG  WHICH COMPUTES
C     FUNCTION VALUES  F  AND GRADIENTS  G  AT GIVEN VALUES OF
C     THE VARIABLES X.  THE MINIMIZATION PROCEEDS BY A SEQUENCE
C     OF ONE-DIMENSIONAL MINIMIZATIONS.  THESE ARE CARRIED OUT BY
C     SUBROUTINES LINMIN/LOCMIN/FSTMIN WHICH SOLVE THE SUBPROBLEM OF
C     MINIMIZING THE FUNCTION  F  ALONG THE LINE  X+ALPHA*P, WHERE X
C     IS THE VECTOR OF CURRENT VARIABLE VALUES,  ALPHA IS A SCALAR
C     VARIABLE, AND  P  IS A SEARCH-DIRECTION VECTOR PROVIDED BY THE
C     DFP OR BFGS ALGORITHM. EACH ITERATION STEP WHICH IS CARRIED
C     OUT BY FLEPO PROCEEDS BY FINDING A VALUE FOR THE STEP SIZE
C     ALPHA WHICH MINIMIZES  F  ALONG  X+ALPHA*P, BY UPDATING THE
C     VECTOR  X  BY THE AMOUNT  ALPHA*P,  AND FINALLY BY GENERATING A
C     NEW VECTOR  P.
C     *
C     CONVERGENCE TESTS IN FLEPO USE THE 4-ELEMENT VECTOR TOLEND.
C     THE TEST ON X IS SATISFIED, IF THE RELATIVE CHANGE IN THE NORM
C     OF X OVER TWO SUCCESSIVE ITERATIONS DROPS BELOW TOLEND(1).
C     THE TEST ON F IS SATISFIED, IF THE ABSOLUTE CHANGE IN F OVER
C     TWO SUCCESSIVE ITERATIONS DROPS BELOW TOLEND(2), IN KCAL/MOL.
C     THE TEST ON G IS SATISFIED, IF ALL GRADIENT COMPONENTS DROP
C     BELOW TOLEND(3), IN KCAL/(MOL*ANGSTROM) OR KCAL/(MOL*RADIAN).
C     THE TEST ON GNORM IS SATISFIED, IF THE GRADIENT NORM DROPS
C     BELOW TOLEND(3), IN KCAL/(MOL*ANGSTROM) OR KCAL/(MOL*RADIAN).
C     THE TEST ON ALPHA.P.G IS SATISFIED, IF THE PREDICTED DECREASE
C     IN F FOR THE NEXT CYCLE DROPS BELOW TOLEND(4), IN KCAL/MOL.
C     THE VARIABLE NSUCC INDICATES THE RESULTS OF THESE TESTS.
C     NSUCC = 0  TEST ON G SATISFIED.
C     NSUCC = 1  TEST ON G AND F SATISFIED.
C     NSUCC = 2  TEST ON G AND X SATISFIED.
C     NSUCC = 3  TEST ON F OR  X SATISFIED FOR NREPET CYCLES.
C     NSUCC = 4  TEST ON ALPHA.P.G SATISFIED.
C     NSUCC = 5  TEST ON GNORM SATISFIED.
C     NSUCC = 6  TEST ON PROJECTED EXCITED STATE GRADIENT SATISFIED.
C     THE CONVERGENCE CRITERIA DEPEND ON THE VARIABLE ICONV.
C     ICONV = 0  CONVERGENCE FOR NSUCC=1-4.
C     ICONV = 1  CONVERGENCE FOR NSUCC=1-3.
C     ICONV = 2  CONVERGENCE FOR NSUCC=0-3.
C     ICONV = 3  CONVERGENCE FOR NSUCC=5.
C     IN THE CASE OF BEARPARK CONICAL INTERSECTION SEARCH,
C     CONVERGENCE CRITERION IS ALWAYS NSUCC=6.
C     *
C     THERE ARE TWO CASES OF UNSUCCESSFUL TERMINATION.
C     NSUCC =10  F CANNOT BE LOWERED IN TWO CONSECUTIVE CYCLES.
C     NSUCC =11  THE NUMBER OF FUNCTION EVALUATIONS EXCEEDS MAXEND.
C     AN UNSUCCESSFUL TERMINATION NORMALLY IMPLIES THAT FURTHER
C     CALCULATIONS ARE NOT CARRIED OUT ANY MORE FOR THIS MOLECULE.
C     EXCEPTIONS DEPEND ON THE VARIABLE LCONVG THAT SPECIFIES THE
C     ACCEPTABLE GRADIENT NORM IN CASE OF UNSUCCESSFUL TERMINATION.
C     NSUCC = 9  GNORM.LT.TOLEND(3)*LCONVG, CALCULATIONS ALLOWED.
C     NSUCC = 9  ALSO FOR NEGATIVE  LCONVG, CALCULATIONS ALLOWED.
C     *
      PARAMETER (NITEM=10)
      EXTERNAL SCFCAL
      CHARACTER*80 KTITLE,KOMENT
      LOGICAL PRT,PRTMIN
C     SAVE
      COMMON
     ./BESAFE/ TLIMIT
     ./CONINF/ ESTAT0,ESTAT1,GF2NRM
     ./CONSTF/ A0,AFACT,EV,EVCAL,PI,W1,W2,BIGEXP
     ./CONSTN/ ZERO,ONE,TWO,THREE,FOUR,PT5,PT25
     ./CYCLES/ ICYC,NCOUNT
     ./DFP   / X(LMV),N
     ./DFPGO / GLAST(LMV),XLAST(LMV)
     ./ERG1  / CNORM1
     ./FLAG1 / KTITLE,KOMENT
     ./FLAG2 / SECADD,TIME1
     ./FLPOCM/ G(LMV),P(LMV),ALPHA,FIP1
     ./INOPT2/ IN2(300)
      COMMON
     ./NBFILE/ NBF(20)
     ./OPCOM1/ XD(LMV),GD(LMV),GNORM,PNORM,SMVAL,TX1,ZDUM(4)
     ./OPCOM2/ IRTL,IREPET,IRST,IHDIM
     ./OPTCRT/ NSUCC
     ./OPTRST/ CNCADD,CNCOS,DEL,DELL,PMSTE,TDEL,ZCONS
     ./OPTTOL/ TOLEND(4),TOLIN(4),XMAXST
     ./OVERLY/ IOV,JOV,KOV,LOV
     ./PARM3 / LOC(LMV),NVAR3
     ./SKIPA / ISKPA
CRAY  COMMON
CRAY ./UCHEM4/ DELTAH,ICOORD,TSNORM
CRAY ./UCHEM9/ INDEXG,INDEXA
      DIMENSION H(LFA)
      DIMENSION ARRAY(LM5)
C *** FILE NUMBERS.
      NB6    = NBF(6)
C     *
C     SETUP PHASE (EXECUTED ONLY ONCE)
C     *
      IF(N.LE.0) THEN
         WRITE(NB6,540)
         ICALL=-3
         RETURN
      ENDIF
C     INPUT OPTIONS.
      IGEOM  = IN2(4)
      MAXEND = IN2(32)
      MAXLIN = IN2(33)
      MAXRTL = IN2(34)
      MIDDLE = IN2(37)
      IPRINT = IN2(38)
      IPREC  = IN2(43)
      ICONV  = IN2(44)
      IHESS  = IN2(45)
      IDFP   = IN2(46)
      NREPET = IN2(47)
      LCONVG = IN2(49)
      ICROSS = IN2(160)
      NRST   = IN2(191)
      LDROP  = IN2(192)
      LDELL  = IN2(193)
      LSUB   = IN2(194)
      LALPHA = IN2(195)
      LCONV  = IN2(196)
      LTOLF  = IN2(197)
      LMAXST = IN2(198)
C     INITIALIZATION.
      IOV    = 0
      JOV    = 0
      KOV    = 0
      PRT    = IPRINT.GE. 0
      PRTMIN = IPRINT.GE.-1
      IF(PRTMIN) WRITE(NB6,500) KOMENT,KTITLE
C     RESTART OPTIONS.
      FLOATN = N
      CNCADD = ONE/SQRT(FLOATN)
      IF(CNCADD.GT.0.15D0) CNCADD=0.15D0
      CNCOS  = 0.05D0
      IF(LDELL.GT.0) THEN
         DELL= 0.001D0*LDELL
      ELSE
         DELL= 0.01D0
      ENDIF
      DEL    = DELL
      PMSTE  = 0.10D0
      TDEL   = 6.00D0
      ZCONS  = 1.0D-09
C     OVERALL CONVERGENCE CRITERIA.
C     CONVENTION: NEGATIVE IPREC VALUES ARE USED FOR KEYWORD INPUT AND
C     MOPAC-TYPE INPUT TO INDICATE THAT THE CRITERIA HAVE BEEN DEFINED
C     ELSEWHERE (KEYDEF) AND MAY NOT BE REDEFINED HERE. NEGATIVE IPREC
C     VALUES DO NOT OCCUR FOR STANDARD INPUT (RESET IN METHOD).
      IF(IPREC.GE.0) THEN
         IF(IPREC.EQ.0) IPREC=1
         FPREC = ONE/IPREC
         IF(ICONV.EQ.3 .OR. ICROSS.EQ.4) THEN
            TOLEND(1) = ZERO
            TOLEND(2) = ZERO
            TOLEND(3) = FPREC
            TOLEND(4) = ZERO
         ELSE
            TOLEND(1) = FPREC*1.0D-04
            TOLEND(2) = FPREC*2.0D-03
            TOLEND(3) = FPREC
            TOLEND(4) = FPREC*1.0D-03
         ENDIF
      ENDIF
C     LINE SEARCH OPTIONS.
      IF(LMAXST.LE.0) LMAXST=1
      IF(LCONV .LE.0) LCONV=1
      FCONV    = LCONV
      TOLIN(1) = TOLEND(1)
      TOLIN(2) = TOLEND(2)*PT5*LTOLF
      TOLIN(3) = FCONV*1.0D-02
      TOLIN(4) = FCONV*1.0D-02
      IF(ICONV.EQ.3) THEN
         TOLIN(1) = TOLEND(3)*1.0D-04
         TOLIN(2) = TOLEND(3)*1.0D-03*LTOLF
      ENDIF
      IF(ISKPA.EQ.1 .OR. N.EQ.1) THEN
         TOLIN(3) = 1.0D-02
         TOLIN(4) = 1.0D-02
      ENDIF
      LLDROP = LDROP
      XMAXST = LMAXST*0.1D0
      IF(N.EQ.1) THEN
         IF(LDROP.EQ.10) LLDROP=1000
         IF(LMAXST.EQ.1) XMAXST=1.0D0
      ENDIF
C     VARIOUS FLAGS.
      IHDIM  = (N*(N+1))/2
      ICYC   = 0
      IREPET = 0
      IRST   = 0
      IRTL   = 0
      NCOUNT = 0
      NTO    = 1+(N-1)/NITEM
      NREM   = N-(NTO-1)*NITEM
      CNORM1 = ZERO
      DROP10 = 10.0D0
      PNORM  = ONE
      SFDFP  = 1.5D0
CRAY  IF(IGEOM.EQ.0) THEN
CRAY     ICOORD = 1
CRAY  ELSE
CRAY     ICOORD = 0
CRAY  ENDIF
C     *
C     CONTINUATION OF A PREVIOUS JOB
C     *
      IF(MIDDLE.GT.0) THEN
         CALL DFPSAV (H,IHDIM,1,MIDDLE)
         CALL DENSAV (0,ARRAY,LM5,1)
         CALL CPUSEC(TX1)
         IF(LOV.EQ.5) GO TO 30
         IF(LOV.EQ.6) GO TO 210
         IF(LOV.EQ.4 .AND. MIDDLE.LT.2) GO TO 350
         IF(LOV.EQ.4 .AND. MIDDLE.GE.2) GO TO 30
         WRITE(NB6,510)
         STOP 'FLEPO'
      ENDIF
C     *
C     INITIAL FUNCTION EVALUATION.
C     *
      ICALL  = 21
      LOV    = 1
      CALL COMPFG(N,X,FIP1,FIP1,G,ARRAY,LM5,ICALL,SCFCAL)
      IF(ICALL.EQ.-1) RETURN
      CALL GCHECK (PRTMIN)
      IF(NSUCC.GE.0) GO TO 350
      CALL CPUSEC(TX1)
         IF(PRTMIN) THEN
         GNORM = DNRM2(N,G,1)
         WRITE(NB6,750) TX1,FIP1,GNORM
         IF(ICROSS.EQ.4) WRITE(NB6,605) GF2NRM
      ENDIF
C     *
C     START OF EACH ITERATION CYCLE ...
C     *
   30 IF(PRT) WRITE(NB6,730)
      ICYC   = ICYC+1
      IRTL   = IRTL+1
      IRST   = IRST+1
      IF(IRST.LT.NRST .AND. ICYC.GT.1) GO TO 100
C     *
C     RESTART SECTION
C     *
   40 IRST   = 0
      IF(ICYC.EQ.1 .AND. IHESS.EQ.-1) GO TO 160
      IF(ICYC.EQ.1 .AND. IHESS.EQ.2) THEN
         CALL DFPSAV(H,IHDIM,2,MIDDLE)
         GO TO 160
      ENDIF
      IF(IHESS.EQ.3) THEN
         DO 50 I=1,IHDIM
         H(I) = ZERO
   50    CONTINUE
         DO 55 I=1,N
         II   = I*(I+1)/2
         H(II)= ONE
   55    CONTINUE
         GO TO 160
      ENDIF
      DO 60 I=1,N
      XD(I)  = X(I)-SIGN(DEL,G(I))
   60 CONTINUE
C     FUNCTION EVALUATION AT SECOND POINT.
      LOV    = 2
      CALL COMPFG(N,XD,FIP2,FIP1,GD,ARRAY,LM5,ICALL,SCFCAL)
      IF(ICALL.EQ.-1) RETURN
C     ESTIMATE DIAGONAL INVERSE HESSIAN MATRIX.
C     FINITE-DIFFERENCE APPROXIMATION FOR DIAGONAL ELEMENTS
C     WITH SOME EMPIRICAL CHECKS TO AVOID NUMERICAL PROBLEMS.
C     PMSTE  : LIMIT FOR STEP SIZE IN X AFTER RESTART.
C     TDEL   : EMPIRICAL PREFACTOR TO REDEFINE H(II) IF NEGATIVE.
C     ZCONS  : THRESHOLD TO AVOID DIVISION BY TINY NUMBERS.
      DO 70 I=1,IHDIM
      H(I)   = ZERO
   70 CONTINUE
      DO 80 I=1,N
      II     = I*(I+1)/2
      DELG   = G(I)-GD(I)
      DELX   = X(I)-XD(I)
      IF(ABS(DELG).GT.ZCONS) THEN
         H(II) = DELX/DELG
      ELSE
         H(II) = 0.01D0
         GO TO 80
      ENDIF
      IF(FIP2.GE.FIP1) THEN
         GGD = ABS(G(I))
      ELSE
         GGD = ABS(GD(I))
      ENDIF
      IF(H(II).LT.ZERO) THEN
         IF(GGD.LT.ZCONS) THEN
            H(II) = 0.01D0
         ELSE
            H(II) = TDEL*DEL/GGD
CPP         H(II) = MIN(H(II), 0.01D0)
CPP         PREVIOUS LINE AVOIDED OVERFLOWS IN PP PROGRAM.
CPP         AD-HOC BUG FIX NOT JUSTIFIED AND THUS REMOVED.
CPP         CHECK ORIGIN OF PROBLEMS IN PP PROGRAM.
         ENDIF
      ENDIF
      GGD    = MAX(GGD,ZCONS)
      H(II)  = MIN(H(II),ABS(PMSTE/GGD))
   80 CONTINUE
C     START FROM POINT WITH LOWER ENERGY.
      IF(FIP2.GE.FIP1) THEN
         IF(PRT) WRITE(NB6,530) FIP1,FIP2
      ELSE
         IF(PRT) WRITE(NB6,520) FIP1,FIP2
         FIP1 = FIP2
         DO 90 I=1,N
         X(I) = XD(I)
         G(I) = GD(I)
   90    CONTINUE
      ENDIF
      GO TO 160
C     *
C     UPDATE VARIABLE-METRIC MATRIX
C     *
  100 CALL DFPSAV (H,IHDIM,2,MIDDLE)
      SY     = ZERO
      YHY    = ZERO
      DO 140 I=1,N
      S      = ZERO
      DO 110 K=1,I
      IK     = I*(I-1)/2+K
      S      = S+H(IK)*(G(K)-GLAST(K))
  110 CONTINUE
      IF(I.EQ.N) GO TO 130
      I1     = I+1
      DO 120 K=I1,N
      IK     = K*(K-1)/2+I
      S      = S+H(IK)*(G(K)-GLAST(K))
  120 CONTINUE
  130 GD(I)  = S
      Y      = G(I)-GLAST(I)
      YHY    = YHY+S*Y
      SY     = SY+(X(I)-XLAST(I))*Y
  140 CONTINUE
C *** CHECK FOR DIVISION BY ZERO.
C *** WOLFGANG WEBER, 13/01/95 (SY).
      SYR    = ONE/SY
      YHYR   = ONE/YHY
C     DFP UPDATE.
      DO 151 I=1,N
      TEMP   = (X(I)-XLAST(I))*SYR
      DO 150 K=I,N
      IK     = K*(K-1)/2+I
      H(IK)  = H(IK)+TEMP*(X(K)-XLAST(K))-GD(I)*GD(K)*YHYR
  150 CONTINUE
  151 CONTINUE
      IF(IDFP.EQ.1) GO TO 160
C     BFGS UPDATE.
      DO 156 I=1,N
      TEMP   = (X(I)-XLAST(I))*SYR*YHY-GD(I)
      DO 155 K=I,N
      IK     = K*(K-1)/2+I
      H(IK)  = H(IK)+TEMP*((X(K)-XLAST(K))*SYR-GD(K)*YHYR)
  155 CONTINUE
  156 CONTINUE
C     *
C     ESTABLISH NEW SEARCH DIRECTION
C     *
  160 PNLAST = PNORM
      GNORM  = ZERO
      PNORM  = ZERO
      DOT    = ZERO
      DO 200 K=1,N
      S      = ZERO
      DO 170 I=1,K
      IK     = K*(K-1)/2+I
      S      = S-H(IK)*G(I)
  170 CONTINUE
      IF(K.EQ.N) GO TO 190
      DO 180 I=K+1,N
      IK     = I*(I-1)/2+K
      S      = S-H(IK)*G(I)
  180 CONTINUE
  190 P(K)   = S
      GNORM  = GNORM+G(K)*G(K)
      PNORM  = PNORM+S*S
      DOT    = DOT+S*G(K)
  200 CONTINUE
      GNORM  = SQRT(GNORM)
      PNORM  = SQRT(PNORM)
      COS    = -DOT/(PNORM*GNORM)
C     DEFINE INITIAL STEP SIZE FOR LINE SEARCH
      IF(IRST.GT.0) THEN
         YEAD = ABS(ALPHA*DOT)*PNLAST/PNORM
         IF((LALPHA.EQ.0 .AND. LCONV.GT.25 .AND. ISKPA.LE.0) .OR.
     1       LALPHA.EQ.1) THEN
            ALPHA = ONE
         ELSE IF(LSUB.GT.0) THEN
            ALPHA = ALPHA*PNLAST/PNORM
         ENDIF
      ELSE
         ALPHA = ONE
         YEAD  = ABS(DOT)
      ENDIF
C     *
C     CHECK FOR NECESSITY OF RESTART
C     *
      IF(IRST.GT.0 .AND. ((COS.LE.CNCADD .AND. YEAD.GT.ONE) .OR.
     1   (COS.LE.CNCOS .AND. IGEOM.EQ.0)) .AND. NRST.NE.99999) THEN
         PNORM = PNLAST
         IF(PRTMIN) THEN
            WRITE(NB6,680) COS
            WRITE(NB6,560)
         ENDIF
         GO TO 40
      ENDIF
      LOV    = 6
      CALL DFPSAV (H,IHDIM,0,MIDDLE)
C     *
C     PRINTING SECTION
C     *
  210 IF(IPRINT.LT.0) GO TO 240
      WRITE(NB6,580) ICYC,FIP1
      DO 220 I=1,N
      XD(I)  = X(I)
      LOC2   = LOC(I)-3*((LOC(I)-1)/3)
      IF(IGEOM.GT.0 .OR. LOC2.EQ.1) GO TO 220
      XD(I)  = X(I)*AFACT
  220 CONTINUE
      JMIN   = 1-NITEM
      DO 230 I=1,NTO
      JMIN   = JMIN+NITEM
      JMAX   = JMIN+NITEM-1
      IF(I.EQ.NTO) JMAX = JMIN+NREM-1
      WRITE(NB6,690) (J,J=JMIN,JMAX)
      WRITE(NB6,700) (XD(J),J=JMIN,JMAX)
      WRITE(NB6,710) (G(J),J=JMIN,JMAX)
      IF(IPRINT.GT.0) WRITE(NB6,720) (P(J),J=JMIN,JMAX)
  230 CONTINUE
      WRITE(NB6,590) COS,YEAD
      IF(IRST.EQ.0) WRITE(NB6,595) GNORM
      IF(IPRINT.GE.5) THEN
         WRITE(NB6,770)
         CALL VECPRT(H,IHDIM,N)
      ENDIF
  240 CONTINUE
C     *
C     ALPHA.P.G TEST BEFORE LINE SEARCH
C     *
      IF(IRST.GT.0 .AND. ICONV.EQ.0 .AND. YEAD.LT.TOLEND(4)) THEN
         IF(PRT) WRITE(NB6,650)
         ICYC  = ICYC-1
         NSUCC = 4
         GO TO 340
      ENDIF
C     *
C     PREPARE FOR LINE SEARCH
C     *
      SMVAL  = FIP1
      DO 250 I=1,N
      GLAST(I) = G(I)
      XLAST(I) = X(I)
  250 CONTINUE
C     *
C     LINE SEARCH
C     *
CMS   EXPERIMENTAL CODE ON COMMENT LINES.
CMS   REPEAT LINE SEARCH UP TO THREE TIMES USING SMALLER STEPS.
CMS   NLINES = 1
C 260 CONTINUE
      KOV    = 1
      ICALL  = 20
      IF(ICROSS .EQ. 4) THEN
         CALL BPARKD(X,G,P,N,ALPHA,FIP1,IPRINT,
     1               ARRAY,LM5,ICALL,SCFCAL)
      ELSE IF(LSUB.EQ.0) THEN
         CALL FSTMIN(X,G,P,XD,GD,N,ALPHA,FIP1,MAXLIN,IPRINT,
     1               ARRAY,LM5,ICALL,SCFCAL)
      ELSE IF(LSUB.EQ.2 .AND. ISKPA.LE.0) THEN
         CALL LINMIN(X,G,P,XD,GD,N,ALPHA,FIP1,MAXLIN,IPRINT,
     1               ARRAY,LM5,ICALL,SCFCAL)
      ELSE
         CALL LOCMIN(X,G,P,XD,GD,N,ALPHA,FIP1,MAXLIN,IPRINT,
     1               ARRAY,LM5,ICALL,SCFCAL)
      ENDIF
      IF(ICALL.EQ.-1) RETURN
      ICALL  = 21
      KOV    = 0
CMS   IF(FIP1.GE.SMVAL .AND. NLINES.LE.3)
CMS      NLINES = NLINES+1
CMS      ALPHA  = ALPHA*PT5
CMS      GO TO 260
CMS   ENDIF
C     *
C     CHECK SUCCESS OF LINE SEARCH
C     *
       IF(FIP1.GE.SMVAL .AND. ICROSS .NE. 4) THEN
         IF(IRST.GT.0) THEN
            IF(PRTMIN) THEN
               WRITE(NB6,550)
               WRITE(NB6,560)
            ENDIF
            IRST = NRST
            GO TO 330
         ELSE
            NSUCC = 10
            IF(PRTMIN) THEN
               WRITE(NB6,550)
               WRITE(NB6,570)
               WRITE(NB6,670) FIP1
            ENDIF
            GO TO 340
         ENDIF
      ENDIF
C     *
C     ADDITIONAL GRADIENT CALCULATION (IF NECESSARY).
C     *
      LOV    = 3
      IF(LSUB.EQ.1 .OR. (LSUB.EQ.2 .AND. ISKPA.EQ.1)) THEN
         CALL COMPFG(N,X,FIP1,FIP1,G,ARRAY,LM5,ICALL,SCFCAL)
         IF(ICALL.EQ.-1) RETURN
      ENDIF
C     *
C     COMPUTE VARIOUS NORMS.
C     *
      GNORM  = ZERO
      XNORM  = ZERO
      DO 300 K=1,N
      GNORM  = GNORM+G(K)*G(K)
      XNORM  = XNORM+X(K)*X(K)
  300 CONTINUE
      GNORM  = SQRT(GNORM)
      XNORM  = SQRT(XNORM)
      TX     = ABS(ALPHA*PNORM)
      IF(XNORM.NE.ZERO) TX=TX/XNORM
      TF     = ABS(SMVAL-FIP1)
      IF(PRT) WRITE(NB6,600) NCOUNT,TX,TF,GNORM
      IF(ICROSS.EQ.4 .AND. PRT) WRITE(NB6,605) GF2NRM
C     *
C     TERMINATION TESTS
C     *
      NSUCC  = -1
      IF(ICROSS.EQ.4) THEN
         IF(GF2NRM.LT.TOLEND(3)) THEN
            IF(PRTMIN) WRITE(NB6,656)
            NSUCC = 6
            GO TO 340
         ELSE
            GO TO 330
         ENDIF
      ENDIF
      IF(ICONV.EQ.3) THEN
         IF(GNORM.LT.TOLEND(3)) THEN
            IF(PRTMIN) WRITE(NB6,655)
            NSUCC = 5
            GO TO 340
         ELSE
            GO TO 330
         ENDIF
      ENDIF
      DO 310 I=1,N
      IF(ABS(G(I)).GT.TOLEND(3)) GO TO 320
  310 CONTINUE
      IF(PRTMIN) WRITE(NB6,640)
      NSUCC  = 0
  320 IF(TX.LT.TOLEND(1)) THEN
         IF(PRT .AND. NSUCC.LT.0) WRITE(NB6,780)
         IF(PRTMIN) WRITE(NB6,620)
         IF(NSUCC.EQ.0) NSUCC=1
         IREPET = IREPET+1
      ELSE IF(TF.LT.TOLEND(2)) THEN
         IF(PRT .AND. NSUCC.LT.0) WRITE(NB6,780)
         IF(PRTMIN) WRITE(NB6,630)
         IF(NSUCC.EQ.0) NSUCC=2
         IREPET = IREPET+1
      ELSE
         IREPET = 0
      ENDIF
      IF(NSUCC.GT.0 .OR. (NSUCC.EQ.0 .AND. ICONV.EQ.2)) GO TO 340
      IF(IREPET.GT.NREPET) THEN
         IF(PRTMIN) WRITE(NB6,660)
         NSUCC = 3
         GO TO 340
      ENDIF
      IF(NCOUNT.GE.MAXEND) THEN
         NSUCC = 11
         IF(PRTMIN) WRITE(NB6,610)
         IF(PRTMIN) WRITE(NB6,670) FIP1
         GO TO 340
      ENDIF
C     *
C     PREPARE NEXT CYCLE AND CHECK FOR TIME LIMIT
C     *
  330 BSMVF  = ABS(SMVAL-FIP1)
      DROP   = LLDROP
      DEL    = DELL*0.2D0
      IF(BSMVF.GT.ONE) DEL=DELL*0.5D0
      IF(BSMVF.GT.5.0D0) DEL=DELL
      IF(BSMVF.GT.MAX(DROP,DROP10)) IRST=NRST
      LOV    = 5
      IF(MIDDLE.GE.0) THEN
         CALL DFPSAV (H,IHDIM,0,MIDDLE)
         CALL DENSAV (0,ARRAY,LM5,0)
      ENDIF
      CALL CPUSEC(TX2)
      TCYCLE = TX2-TX1
      TX1    = TX2
      IF(PRT) THEN
         WRITE(NB6,740) TX2+SECADD
      ELSE IF(PRTMIN) THEN
         WRITE(NB6,760) ICYC,TX2+SECADD,FIP1,GNORM
      ENDIF
CRAY  UniChem MONITOR CALL.
CRAY  DELTAH = FIP1-SMVAL
CRAY  INDEXG = ISAMAX(N,G,1)
CRAY  INDEXA = (LOC(INDEXG)-1)/3+1
CRAY  GMAX   = G(INDEXG)
CRAY  CALL UNIGEOMON (ICYC,FIP1,DELTAH,ICOORD,GMAX,INDEXG,INDEXA)
      IF(IRTL.LT.MAXRTL .AND. TLIMIT.GT.TX2+SFDFP*TCYCLE) GO TO 30
      CALL PRTDFP(1)
      ICALL  = -8
CRAY  UniChem MONITOR CALL.
CRAY  CALL CTGEOFINAL
C     STOP 'FLEPO'
C     THIS STOP HAS BEEN SHIFTED TO THE CALLING PROGRAM.
      RETURN
C     *
C     EXIT AFTER FINISHING THE OPTIMIZATION
C     *
  340 LOV    = 4
      CALL DFPSAV (H,IHDIM,0,MIDDLE)
      CALL CPUSEC(TX2)
      IF(PRT) THEN
         WRITE(NB6,740) TX2+SECADD
      ELSE IF(PRTMIN) THEN
         WRITE(NB6,760) ICYC,TX2+SECADD,FIP1,GNORM
      ENDIF
      IF(NSUCC.GE.10) THEN
         IF(LCONVG.LT.0 .OR. GNORM.LT.TOLEND(3)*LCONVG) NSUCC=9
      ENDIF
  350 LOV    = 4
      ICALL  = 10
      CALL COMPFG(N,X,FIP1,FIP1,G,ARRAY,LM5,ICALL,SCFCAL)
      IF(ICALL.EQ.-1) RETURN
      CALL PRTDFP(0)
CRAY  UniChem MONITOR CALL.
CRAY  CALL CTGEOFINAL
      RETURN
  500 FORMAT(///1X,'GEOMETRY OPTIMIZATION FOR ENERGY MINIMUM',
     1       /  1X,A,/1X,A)
  510 FORMAT(// 1X,'ILLEGAL VALUE OF LOV ON RESTART FILE. STOP.'//)
  520 FORMAT(/  1X,'FUNCTION VALUE',F12.5,5X,'IS REPLACED BY ',
     1             'VALUE',F12.5,5X,'FOUND IN RESTART PROCEDURE.',
     2       /  1X,'THE CORRESPONDING X VALUES AND GRADIENTS ARE ',
     3             'ALSO REPLACED.'/)
  530 FORMAT(/  1X,'FUNCTION VALUE',F12.5,5X,'WILL NOT BE REPLACED ',
     1             'BY VALUE',F12.5,5X,'FOUND IN RESTART PROCEDURE.'/)
  540 FORMAT(///1X,'OPTIMIZATION REQUIRES AT LEAST ONE VARIABLE.'//)
  550 FORMAT(// 1X,'NO ENERGY LOWERING IN THE LINE MINIMIZATION.')
  560 FORMAT(   1X,'RESTART WITH NEW ESTIMATE OF THE INVERSE HESSIAN.')
  570 FORMAT(   1X,'UNSUCCESSFUL RESTART. THE SEARCH IS TERMINATED.')
  580 FORMAT(/  1X,'AT THE BEGINNING OF CYCLE',I5,
     1             '  THE FUNCTION VALUE IS ',F12.5,
     2       /  1X,'THE CURRENT POINT IS ...')
  590 FORMAT(/  1X,'ANGLE COSINE   = ',E11.4,
     2       /  1X,'ALPHA.P.G TEST = ',E11.4)
  595 FORMAT(   1X,'GRADIENT NORM  = ',E11.4)
  600 FORMAT(/  1X,'TERMINATION TESTS ...',
     1       /  1X,'FUNCTION EVALUATIONS =',I4,
     2       /  1X,'RELATIVE CHANGE IN X =',E11.4,
     3       /  1X,'ABSOLUTE CHANGE IN F =',E11.4,
     4       /  1X,'GRADIENT NORM        =',E11.4)
  605 FORMAT(   1X,'PROJ EXC STATE G NRM =',E11.4)
  610 FORMAT(/  1X,'TERMINATION FROM TOO MANY COUNTS')
  620 FORMAT(   1X,'TEST ON X SATISFIED')
  630 FORMAT(   1X,'TEST ON F SATISFIED')
  640 FORMAT(/  1X,'TEST ON G SATISFIED')
  650 FORMAT(/  1X,'TEST ON ALPHA.P.G SATISFIED')
  655 FORMAT(/  1X,'TEST ON GNORM SATISFIED')
  656 FORMAT(/  1X,'TEST ON PROJECTED EXCITED STATE GRADIENT ',
     1             'NORM SATISFIED')
  660 FORMAT(/  1X,'FURTHER QUENCHING NOT REQUESTED ')
  670 FORMAT(/  1X,'UNSUCCESSFUL TERMINATION AT FUNCTION VALUE ',F12.5)
  680 FORMAT(// 1X,'THE COSINE BETWEEN GRADIENT AND SEARCH DIRECTION ',
     1             'VECTOR IS',F9.5)
  690 FORMAT(/  3X,'I',6X,I4,9(8X,I4))
  700 FORMAT(   1X,'X(I)',10(1X,F11.5))
  710 FORMAT(   1X,'G(I)',10(1X,F11.5))
  720 FORMAT(   1X,'P(I)',10(1X,F11.5))
  730 FORMAT(// 1X,'*****')
  740 FORMAT(/  1X,'TOTAL TIME',F18.3,' SECONDS')
  750 FORMAT(/  1X,'INITIAL GEOMETRY, TOTAL TIME = ',F10.3,
     1             ' , HEAT =',F12.5,' , GNORM =',F15.5)
  760 FORMAT(/  1X,'END OF CYCLE',I3,' , TOTAL TIME = ',F10.3,
     1             ' , HEAT =',F12.5,' , GNORM =',F15.5)
  770 FORMAT(// 1X,'CURRENT INVERSE HESSIAN MATRIX.')
  780 FORMAT(   1X)
  790 FORMAT(// 1X,'ESTIMATE OF BRANCHING PLANE CHANGE IS ',F9.5)
      END
