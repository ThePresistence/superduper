      FUNCTION READA (STRING,ISTART,MODE)
C     *
C     FORTRAN FUNCTION TO EXTRACT NUMBER FROM STRING.
C     ADAPTED FROM MOPAC(6.0) WRITTEN BY J.J.P.STEWART.
C     *
C     NOTATION. I=INPUT, O=OUTPUT.
C     STRING    CHARACTER STRING TO BE CHECKED (I).
C     ISTART    CHECKS STARTING AT CHARACTER ISTART (I).
C     MODE      FURTHER RESTRICTIONS (I).
C               = 0  NO RESTRICTIONS.
C               = 1  CHECKS ONLY AFTER EMBEDDED '='.
C     READA     VALUE OF THE NUMBER EXTRACTED (O).
C     *
      CHARACTER STRING*(*)
      DOUBLE PRECISION DIGIT,READA
      LOGICAL EXPNNT
C     LOGICAL DEFALT
C *** INITIALIZATION.
C     DEFINE ASCII VALUES OF NUMERIC FIELD CHARACTERS
      I0     = ICHAR('0')
      I9     = ICHAR('9')
      IDOT   = ICHAR('.')
      INEG   = ICHAR('-')
      IPOS   = ICHAR('+')
      ICAPD  = ICHAR('D')
      ICAPE  = ICHAR('E')
      ISMLD  = ICHAR('d')
      ISMLE  = ICHAR('e')
C     DETERMINE LENGTH OF STRING
      L      = LEN(STRING)
C *** DETERMINE FIRST CHARACTER TO BE CHECKED
      IF(MODE.LE.0) THEN
         ICHECK = ISTART
      ELSE
         DO 10 I=ISTART,L
         IF(STRING(I:I).EQ.'=') GO TO 20
   10    CONTINUE
   20    ICHECK = I+1
      ENDIF
C *** FIND THE START OF THE NUMERIC FIELD
      DO 30 I=ICHECK,L
      IADD   = 0
      N      = ICHAR(STRING(I:I))
C     SIGNAL START OF NUMERIC FIELD IF DIGIT FOUND
      IF(N.GE.I0 .AND. N.LE.I9) GO TO 40
C     ACCOUNT FOR CONSECUTIVE SIGNS [- AND(OR) +]
      IF(N.EQ.INEG .OR. N.EQ.IPOS) THEN
         IADD = IADD+1
         IF(I+IADD.GT.L) GO TO 70
         N   = ICHAR(STRING(I+IADD:I+IADD))
         IF(N.GE.I0 .AND. N.LE.I9) GO TO 40
      ENDIF
C     ACCOUNT FOR CONSECUTIVE DECIMAL POINTS (.)
      IF(N.EQ.IDOT) THEN
         IADD = IADD+1
         IF(I+IADD.GT.L) GO TO 70
         N    = ICHAR(STRING(I+IADD:I+IADD))
         IF(N.GE.I0 .AND. N.LE.I9) GO TO 40
      ENDIF
   30 CONTINUE
      GO TO 70
C *** FIND THE END OF THE NUMERIC FIELD
   40 EXPNNT = .FALSE.
      DO 50 J=I+1,L
      IADD = 0
      N = ICHAR(STRING(J:J))
C     CONTINUE SEARCH FOR END IF DIGIT FOUND
      IF(N.GE.I0 .AND. N.LE.I9) GO TO 50
C     CONTINUE SEARCH FOR END IF SIGN FOUND AND EXPNNT TRUE
      IF(N.EQ.INEG .OR. N.EQ.IPOS) THEN
         IF(.NOT.EXPNNT) GO TO 60
         IADD = IADD+1
         IF(J+IADD.GT.L) GO TO 60
         N    = ICHAR(STRING(J+IADD:J+IADD))
         IF(N.GE.I0 .AND. N.LE.I9) GO TO 50
      ENDIF
      IF(N.EQ.IDOT) THEN
         IADD = IADD+1
         IF(J+IADD.GT.L) GO TO 60
         N    = ICHAR(STRING(J+IADD:J+IADD))
         IF(N.GE.I0 .AND. N.LE.I9) GO TO 50
         IF(N.EQ.ICAPE.OR.N.EQ.ISMLE.OR.N.EQ.ICAPD.OR.N.EQ.ISMLD)
     1   GO TO 50
      ENDIF
      IF(N.EQ.ICAPE.OR.N.EQ.ISMLE.OR.N.EQ.ICAPD.OR.N.EQ.ISMLD)THEN
         IF(EXPNNT) GO TO 60
         EXPNNT = .TRUE.
         GO TO 50
      ENDIF
      GO TO 60
   50 CONTINUE
      J      = L+1
   60 N      = ICHAR(STRING(J-1:J-1))
      IF(N.EQ.ICAPE.OR.N.EQ.ISMLE.OR.N.EQ.ICAPD.OR.N.EQ.ISMLD)J=J-1
C *** FOUND THE END OF THE NUMERIC FIELD (IT RUNS 'I' THRU 'J-1')
      N      = 0
      N      = N+INDEX(STRING(I:J-1),'e')
      N      = N+INDEX(STRING(I:J-1),'E')
      N      = N+INDEX(STRING(I:J-1),'d')
      N      = N+INDEX(STRING(I:J-1),'D')
      IF(N.EQ.0) THEN
         READA=DIGIT(STRING(I:J-1),1)
      ELSE
         READA=DIGIT(STRING(:I+N-2),I)*1.D1**DIGIT(STRING(:J-1),I+N)
      ENDIF
C     DEFALT = .FALSE.
      RETURN
C *** DEFAULT VALUE RETURNED BECAUSE NO NUMERIC FIELD FOUND
   70 READA  = 0.0D0
C     DEFALT = .TRUE.
      RETURN
      END
