      SUBROUTINE READMO (IMOPAC,KEYMOD,ICALL)
C     *
C     INPUT OF KEYWORD-BASED OPTIONS (IMOPAC=-1 AND IMOPAC=1).
C     GENERAL INPUT ACCORDING TO MOPAC CONVENTIONS (IMOPAC=1).
C     ADAPTED FROM MOPAC(6.0) WRITTEN BY J.J.P.STEWART.
C     *
C     NOTATION. I=INPUT, O=OUTPUT.
C     IMOPAC    MODE OF INPUT. CONVENTIONS SEE ABOVE (I,O).
C     KEYMOD    ERROR FLAG FROM KEYDEF (O).
C               =-9 REQUESTED OPTION(S) NOT AVAILABLE.
C     ICALL     ERROR FLAG (O).
C               = 0 NORMAL RETURN.
C               =-9 END-OF-FILE ENCOUNTERED.
C     *
C     FOR MOPAC-TYPE INPUT, READMO PROVIDES:
C     KEYWRD    = KEYWORDS TO CONTROL CALCULATION
C     KOMENT    = COMMENT ON CALCULATION
C     KTITLE    = TITLE OF CALCULATION
C     RC        = POINTS ON REACTION COORDINATE
C     RC1,RC2   = POINTS ON TWO-DIMENSIONAL GRID
C     ADDITIONAL INPUT DATA ARE DEFINED IN GETGEO, GETGEG, AND GETSYM.
C     *
      USE LIMIT, ONLY: LMR, LMG
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*800 KEYWRD
C     CHARACTER*80  KOMENT,KTITLE
      CHARACTER*80  LINE
      COMMON
     ./CONSTF/ A0,AFACT,EV,EVCAL,PI,W1,W2,BIGEXP
     ./CONSTN/ ZERO,ONE,TWO,THREE,FOUR,PT5,PT25
     ./KEYWRD/ KEYWRD
     ./NBFILE/ NBF(20)
     ./PARM4 / RC(LMR),LREACT,LTOTAL
     ./PARM5 / RC1(LMG),RC2(LMG),LGRID1,LTOT1,LGRID2,LTOT2
C    ./FLAG1 / KTITLE,KOMENT
      DIMENSION VALUE(40)
C *** READ KEYWORDS AND TITLE.
      ICALL  = 0
      IF(IMOPAC.EQ.0) RETURN
      IF(IMOPAC.GT.0) THEN
         CALL GETTXT (KEYWRD,KEYLEN,ICALL)
      ELSE
         CALL KEYGET (KEYWRD,KEYLEN,ICALL)
      ENDIF
      IF(ICALL.EQ.-9) RETURN
C *** DEFINE AND PRINT KEYWORD-BASED OPTIONS.
      KSTOP  = 0
      KEYMOD = 0
      CALL KEYDEF (KEYWRD(:KEYLEN),IMOPAC,KEYMOD)
      IF(IMOPAC.LT.0) RETURN
      IF(KEYMOD.EQ.-8) RETURN
C *** FILE NUMBERS.
      NB5    = NBF(5)
      NB6    = NBF(6)
C *** READ EXTERNAL PARAMETERS.
C     THIS CALL HAS BEEN SHIFTED (IPAROK=1).
C     IOPPRT = 0
C     IF(INDEX(KEYWRD,'EXTERNAL').NE.0) CALL EXTERN (IOPPRT)
C *** READ INPUT GEOMETRY.
C     KEYWORD SADDLE IS NOT AVAILABLE IN THIS PROGRAM.
C     THE GEOMETRY DATA FOR SADDLE ARE READ IN TWO DUMMY CALLS
C     TO ALLOW PROCESSING OF MULTIPLE DATA SETS AS IN MOPAC(6.0).
      IF(INDEX(KEYWRD,'SADDLE').NE.0) THEN
         IF(INDEX(KEYWRD,'AIGIN').NE.0) THEN
            CALL GETGEG
            CALL GETGEG
         ELSE
            CALL GETGEO (KSTOP)
            CALL GETGEO (KSTOP)
         ENDIF
C     NORMAL INPUT OF GEOMETRY DATA.
      ELSE IF(INDEX(KEYWRD,'OLDGEO').EQ.0) THEN
         IF(INDEX(KEYWRD,'AIGIN').NE.0) THEN
            CALL GETGEG
         ELSE
            CALL GETGEO (KSTOP)
         ENDIF
      ENDIF
C *** READ SYMMETRY CONDITIONS.
      IF(INDEX(KEYWRD,'OLDGEO').EQ.0 .AND. INDEX(KEYWRD,' SYM').NE.0)
     1   CALL GETSYM
C *** READ INPUT FOR MICROSTATES (DUMMY INPUT IN THIS PROGRAM).
      IMICRO = INDEX(KEYWRD,'MICROS')
      IF(IMICRO.NE.0) THEN
         NMICRO = NINT(READA(KEYWRD,IMICRO,0))
         READ(NB5,'(A)',ERR=100,END=100) LINE
         KMICRO = INDEX(LINE,'MICRO')
         IF(KMICRO.NE.0) THEN
            DO 90 I=1,NMICRO
            READ(NB5,'(A)',ERR=110,END=110) LINE
   90       CONTINUE
         ELSE
            GO TO 100
         ENDIF
         GO TO 110
  100    WRITE(NB6,'(A)') ' FAULTY INPUT FOR OPTION MICROS=N '
         STOP 'READMO'
  110    CONTINUE
      ENDIF
C *** READ REACTION PATH VALUES.
      IF(LREACT.EQ.0 .AND. LGRID1.EQ.0) GO TO 300
      IF(INDEX(KEYWRD,'NLLSQ').NE.0)THEN
         WRITE(NB6,'(A)')' NLLSQ USED WITH REACTION PATH; '//
     1                 ' THIS OPTION IS NOT ALLOWED'
         STOP 'READMO'
      ENDIF
      IF(INDEX(KEYWRD,'SIGMA').NE.0)THEN
         WRITE(NB6,'(A)')' SIGMA USED WITH REACTION PATH; '//
     1                 ' THIS OPTION IS NOT ALLOWED'
         STOP 'READMO'
      ENDIF
      IF(LREACT.EQ.0) GO TO 200
      IF(MOD(LREACT,3).EQ.1) THEN
         AFAC = ONE
         BFAC = ONE
      ELSE
         AFAC = AFACT
         BFAC = ONE/AFACT
      ENDIF
C     INPUT OF NUMBER OF POINTS AND CONSTANT STEP SIZE.
      ISTEP  = INDEX(KEYWRD,'STEP=')
      IPTS   = INDEX(KEYWRD,'POINT=')
      IF((ISTEP+IPTS).EQ.0) GO TO 160
      IF(ISTEP.EQ.0 .OR. IPTS.EQ.0) THEN
         WRITE(NB6,'(A)') ' KEYWORDS STEP= AND POINT= MUST BE SPECIFIED'
     1                  //' SIMULTANEOUSLY FOR REACTION PATH DEFINITION'
         STOP 'READMO'
      ELSE
         LTOTAL = NINT(READA(KEYWRD,IPTS+6,0))
         IF(LTOTAL.GT.LMR) THEN
            WRITE(NB6,500) LMR
            STOP 'READMO'
         ELSE
            STEP   = READA(KEYWRD,ISTEP+5,0)*BFAC
            DO 150 I=2,LTOTAL
            RC(I)  = RC(1)+(I-1)*STEP
  150       CONTINUE
         ENDIF
      ENDIF
      GO TO 300
C     EXPLICIT DEFINITION OF REACTION PATH.
  160 IREACT = 1
  170 READ(NB5,'(A)',END=190) LINE
      CALL NUCHAR(LINE,VALUE,NREACT)
      IF(NREACT.EQ.0) GO TO 190
      DO 180 I=1,NREACT
         IJ = IREACT+I
         IF(IJ.GT.LMR) THEN
            WRITE(NB6,500) LMR
            STOP 'READMO'
         ENDIF
         RC(IJ) = VALUE(I)*BFAC
         IF(IJ.GT.1 .AND. ABS(RC(IJ)-RC(IJ-1)).LT.1.0D-5)THEN
            DUM1 = RC(IJ)*AFAC
            DUM2 = RC(IJ-1)*AFAC
            WRITE(NB6,510) DUM1,DUM2
            STOP 'READMO'
         ENDIF
  180 CONTINUE
      IREACT = IREACT+NREACT
      GO TO 170
  190 CONTINUE
      LTOTAL = IREACT
      IF(IREACT.LE.1) THEN
         WRITE(NB6,'(//10X,'' NO POINTS SUPPLIED FOR REACTION PATH'')')
         STOP 'READMO'
      ENDIF
      GO TO 300
C *** READ INPUT FOR TWO-DIMENSIONAL GRID.
C     INPUT OF NUMBER OF POINTS AND CONSTANT STEP SIZE.
  200 CONTINUE
C     FIRST GRID VARIABLE.
      ISTEP1 = INDEX(KEYWRD,'STEP1=')
      IPTS1  = INDEX(KEYWRD,'POINT1=')
      IPTSM  = INDEX(KEYWRD,' MAX')
      IF(ISTEP1.EQ.0 .OR. (IPTS1+IPTSM).EQ.0) THEN
         WRITE(NB6,'(A)') ' STEP1= AND POINT1= OR MAX MUST BE SPECIFIED'
     1                  //' SIMULTANEOUSLY FOR FIRST GRID VARIABLE'
         STOP 'READMO'
      ELSE
         IF(IPTS1.GT.0) LTOT1 = NINT(READA(KEYWRD,IPTS1+7,0))
         IF(IPTSM.GT.0) LTOT1 = 23
         IF(LTOT1.GT.LMG) THEN
            WRITE(NB6,520) LMG
            STOP 'READMO'
         ELSE
            STEP   = READA(KEYWRD,ISTEP1+6,0)
            IF(MOD(LGRID1,3).GT.1) STEP=STEP/AFACT
            DO 210 I=2,LTOT1
            RC1(I) = RC1(1)+(I-1)*STEP
  210       CONTINUE
         ENDIF
      ENDIF
C     SECOND GRID VARIABLE.
      ISTEP2 = INDEX(KEYWRD,'STEP2=')
      IPTS2  = INDEX(KEYWRD,'POINT2=')
      IF(ISTEP2.EQ.0 .OR. (IPTS2+IPTSM).EQ.0) THEN
         WRITE(NB6,'(A)') ' STEP2= AND POINT2= OR MAX MUST BE SPECIFIED'
     1                  //' SIMULTANEOUSLY FOR SECOND GRID VARIABLE'
         STOP 'READMO'
      ELSE
         IF(IPTS2.GT.0) LTOT2 = NINT(READA(KEYWRD,IPTS2+7,0))
         IF(IPTSM.GT.0) LTOT2 = 23
         IF(LTOT2.GT.LMG) THEN
            WRITE(NB6,530) LMG
            STOP 'READMO'
         ELSE
            STEP   = READA(KEYWRD,ISTEP2+6,0)
            IF(MOD(LGRID2,3).GT.1) STEP=STEP/AFACT
            DO 220 I=2,LTOT2
            RC2(I) = RC2(1)+(I-1)*STEP
  220       CONTINUE
         ENDIF
      ENDIF
C *** CHECK FOR INPUT ERRORS.
  300 CONTINUE
      IF(KSTOP.GT.0) THEN
         STOP 'READMO'
      ENDIF
      RETURN
  500 FORMAT(///,4X,'ONLY',I4,' POINTS ALLOWED IN REACTION COORDINATE')
  510 FORMAT(///,' TWO ADJACENT POINTS ARE IDENTICAL:  ',F7.3,2X,F7.3,
     1       /  ,' THIS IS NOT ALLOWED IN A PATH CALCULATION')
  520 FORMAT(///4X,'ONLY',I4,' POINTS ALLOWED FOR FIRST GRID VARIABLE')
  530 FORMAT(///4X,'ONLY',I4,' POINTS ALLOWED FOR SECOND GRID VARIABLE')
      END
